'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var lodashUnified = require('lodash-unified');
require('../../../../utils/index.js');
require('../../../../constants/index.js');
require('../../../../hooks/index.js');
require('../../../../tokens/index.js');
var shared = require('@vue/shared');
var checkbox = require('../../../../tokens/checkbox.js');
var types = require('../../../../utils/types.js');
var index = require('../../../../hooks/use-common-props/index.js');
var event = require('../../../../constants/event.js');

const setStoreValue = (props, { model }) => {
  if (props.checked) {
    if (shared.isArray(model.value) && !model.value.includes(props.value)) {
      model.value.push(props.value);
    } else {
      model.value = props.value || true;
    }
  }
};
const useCheckbox = (props, emit, slots) => {
  const selfModel = vue.ref(false);
  const isLimitExceeded = vue.ref(false);
  const checkboxGroup = vue.inject(checkbox.checkboxGroupContextKey, void 0);
  const isGroup = vue.computed(() => types.isUndefined(checkboxGroup) === false);
  const isChecked = vue.computed(() => {
    const value = model.value || (checkboxGroup == null ? void 0 : checkboxGroup.modelValue);
    if (types.isBoolean(value))
      return value;
    if (shared.isArray(value)) {
      if (shared.isObject(props.value)) {
        return value.map(vue.toRaw).some((o) => lodashUnified.isEqual(o, props.value));
      }
      return value.map(vue.toRaw).includes(props.value);
    }
    if (value !== null && value !== void 0)
      return value === props.value;
    if (props.checkedForce)
      return true;
    return !!value;
  });
  const hasOwnLabel = vue.computed(() => {
    return !!(slots.default || props.label);
  });
  const isLimitDisabled = vue.computed(() => {
    var _a, _b;
    const max = Number(((_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value) || props.max);
    const min = Number(((_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value) || props.min);
    return !lodashUnified.isNil(max) && lodashUnified.toArray(model.value).length >= max && !isChecked.value || !lodashUnified.isNil(min) && lodashUnified.toArray(model.value).length <= min && isChecked.value;
  });
  const isDisabled = index.useDisabled(
    vue.computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value)
  );
  const model = vue.computed({
    get() {
      var _a;
      return isGroup.value ? (_a = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a.value : props.modelValue || selfModel.value;
    },
    set(val) {
      var _a, _b;
      if (isDisabled.value || isLimitExceeded.value)
        return;
      if (isGroup.value && shared.isArray(val)) {
        isLimitExceeded.value = ((_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value);
        isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
        return;
      }
      let updatedValue = val;
      if (val && props.value) {
        updatedValue = props.value;
      }
      if (types.isBoolean(updatedValue)) {
        emit(event.UPDATE_MODEL_EVENT, updatedValue);
      } else if (shared.isArray(props.modelValue)) {
        const modelValueRaw = props.modelValue.map(vue.toRaw);
        const indexVal = modelValueRaw.findIndex(
          (e) => lodashUnified.isEqual(e, updatedValue)
        );
        if (indexVal == -1) {
          modelValueRaw.push(updatedValue);
        } else {
          modelValueRaw.splice(indexVal, 1);
        }
        emit("update:modelValue", modelValueRaw);
      } else {
        if (updatedValue !== props.modelValue) {
          if (val) {
            emit(event.UPDATE_MODEL_EVENT, [props.modelValue, updatedValue]);
          } else {
            emit(event.UPDATE_MODEL_EVENT, updatedValue);
          }
        } else {
          emit(event.UPDATE_MODEL_EVENT, props.notValue || false);
        }
      }
      selfModel.value = !!val;
    }
  });
  vue.onBeforeMount(() => {
    if (props.checked || props.checkedForce) {
      model.value = props.value || true;
    }
  });
  const getCheckboxValue = (value) => {
    return value === props.value || value === true;
  };
  const handleChange = (e) => {
    if (isLimitExceeded.value)
      return;
    const target = e.target;
    emit("change", getCheckboxValue(target.checked));
  };
  setStoreValue(props, { model });
  return {
    isChecked,
    isDisabled,
    hasOwnLabel,
    model,
    handleChange
  };
};

exports.useCheckbox = useCheckbox;
//# sourceMappingURL=use-checkbox.js.map
