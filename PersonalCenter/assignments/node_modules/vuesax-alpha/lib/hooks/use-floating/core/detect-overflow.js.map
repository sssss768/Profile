{"version":3,"file":"detect-overflow.js","sources":["../../../../../../packages/hooks/use-floating/core/detect-overflow.ts"],"sourcesContent":["import { evaluate, getPaddingObject, rectToClientRect } from '../utils'\nimport type { Padding, SideObject } from '../utils'\nimport type {\n  Boundary,\n  Derivable,\n  ElementContext,\n  MiddlewareState,\n  RootBoundary,\n} from './types'\n\nexport type DetectOverflowOptions = Partial<{\n  /**\n   * The clipping element(s) or area in which overflow will be checked.\n   * @default 'clippingAncestors'\n   */\n  boundary: Boundary\n\n  /**\n   * The root clipping area in which overflow will be checked.\n   * @default 'viewport'\n   */\n  rootBoundary: RootBoundary\n\n  /**\n   * The element in which overflow is being checked relative to a boundary.\n   * @default 'floating'\n   */\n  elementContext: ElementContext\n\n  /**\n   * Whether to check for overflow using the alternate element's boundary\n   * (`clippingAncestors` boundary only).\n   * @default false\n   */\n  altBoundary: boolean\n\n  /**\n   * Virtual padding for the resolved overflow detection offsets.\n   * @default 0\n   */\n  padding: Padding\n}>\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n */\nexport async function detectOverflow(\n  state: MiddlewareState,\n  options: DetectOverflowOptions | Derivable<DetectOverflowOptions> = {}\n): Promise<SideObject> {\n  const { x, y, platform, rects, elements, strategy } = state\n\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0,\n  } = evaluate(options, state)\n\n  const paddingObject = getPaddingObject(padding)\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating'\n  const element = elements[altBoundary ? altContext : elementContext]\n\n  const clippingClientRect = rectToClientRect(\n    await platform.getClippingRect({\n      element:\n        (await platform.isElement?.(element)) ?? true\n          ? element\n          : element.contextElement ||\n            (await platform.getDocumentElement?.(elements.floating)),\n      boundary,\n      rootBoundary,\n      strategy,\n    })\n  )\n\n  const rect =\n    elementContext === 'floating'\n      ? { ...rects.floating, x, y }\n      : rects.reference\n\n  const offsetParent = await platform.getOffsetParent?.(elements.floating)\n  const offsetScale = (await platform.isElement?.(offsetParent))\n    ? (await platform.getScale?.(offsetParent)) || { x: 1, y: 1 }\n    : { x: 1, y: 1 }\n\n  const elementClientRect = rectToClientRect(\n    platform.convertOffsetParentRelativeRectToViewportRelativeRect\n      ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n          rect,\n          offsetParent,\n          strategy,\n        })\n      : rect\n  )\n\n  return {\n    top:\n      (clippingClientRect.top - elementClientRect.top + paddingObject.top) /\n      offsetScale.y,\n    bottom:\n      (elementClientRect.bottom -\n        clippingClientRect.bottom +\n        paddingObject.bottom) /\n      offsetScale.y,\n    left:\n      (clippingClientRect.left - elementClientRect.left + paddingObject.left) /\n      offsetScale.x,\n    right:\n      (elementClientRect.right -\n        clippingClientRect.right +\n        paddingObject.right) /\n      offsetScale.x,\n  }\n}\n"],"names":["evaluate","getPaddingObject","rectToClientRect"],"mappings":"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"}