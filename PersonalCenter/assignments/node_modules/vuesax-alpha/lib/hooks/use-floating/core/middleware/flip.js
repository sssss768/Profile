'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var index = require('../../utils/index.js');
var detectOverflow = require('../detect-overflow.js');

const flip = (options = {}) => ({
  name: "flip",
  options,
  async fn(state) {
    var _a, _b, _c, _d, _e, _f;
    const {
      placement,
      middlewareData,
      rects,
      initialPlacement,
      platform,
      elements
    } = state;
    const {
      mainAxis: checkMainAxis = true,
      crossAxis: checkCrossAxis = true,
      fallbackPlacements: specifiedFallbackPlacements,
      fallbackStrategy = "bestFit",
      fallbackAxisSideDirection = "none",
      flipAlignment = true,
      ...detectOverflowOptions
    } = index.evaluate(options, state);
    if ((_a = middlewareData.arrow) == null ? void 0 : _a.alignmentOffset) {
      return {};
    }
    const side = index.getSide(placement);
    const isBasePlacement = index.getSide(initialPlacement) === initialPlacement;
    const rtl = await ((_b = platform.isRTL) == null ? void 0 : _b.call(platform, elements.floating));
    const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [index.getOppositePlacement(initialPlacement)] : index.getExpandedPlacements(initialPlacement));
    if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
      fallbackPlacements.push(
        ...index.getOppositeAxisPlacements(
          initialPlacement,
          flipAlignment,
          fallbackAxisSideDirection,
          rtl
        )
      );
    }
    const placements = [initialPlacement, ...fallbackPlacements];
    const overflow = await detectOverflow.detectOverflow(state, detectOverflowOptions);
    const overflows = [];
    let overflowsData = ((_c = middlewareData.flip) == null ? void 0 : _c.overflows) || [];
    if (checkMainAxis) {
      overflows.push(overflow[side]);
    }
    if (checkCrossAxis) {
      const sides = index.getAlignmentSides(placement, rects, rtl);
      overflows.push(overflow[sides[0]], overflow[sides[1]]);
    }
    overflowsData = [...overflowsData, { placement, overflows }];
    if (!overflows.every((side2) => side2 <= 0)) {
      const nextIndex = (((_d = middlewareData.flip) == null ? void 0 : _d.index) || 0) + 1;
      const nextPlacement = placements[nextIndex];
      if (nextPlacement) {
        return {
          data: {
            index: nextIndex,
            overflows: overflowsData
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      let resetPlacement = (_e = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _e.placement;
      if (!resetPlacement) {
        switch (fallbackStrategy) {
          case "bestFit": {
            const placement2 = (_f = overflowsData.map(
              (d) => [
                d.placement,
                d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)
              ]
            ).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _f[0];
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
          default:
        }
      }
      if (placement !== resetPlacement) {
        return {
          reset: {
            placement: resetPlacement
          }
        };
      }
    }
    return {};
  }
});

exports.flip = flip;
//# sourceMappingURL=flip.js.map
