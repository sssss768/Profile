'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@vueuse/core');
var index = require('../../utils/index.js');

const arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    var _a, _b;
    const { x, y, placement, rects, platform, elements, middlewareData } = state;
    const { element, padding = 0 } = index.evaluate(options, state) || {};
    const htmlElement = core.unrefElement(element);
    if (htmlElement == null) {
      return {};
    }
    const paddingObject = index.getPaddingObject(padding);
    const coords = { x, y };
    const axis = index.getAlignmentAxis(placement);
    const length = index.getAxisLength(axis);
    const arrowDimensions = await platform.getDimensions(htmlElement);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await ((_a = platform.getOffsetParent) == null ? void 0 : _a.call(platform, htmlElement));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await ((_b = platform.isElement) == null ? void 0 : _b.call(platform, arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = index.min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = index.min(paddingObject[maxProp], largestPossiblePadding);
    const min = minPadding;
    const max = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = index.clamp(min, center, max);
    const shouldAddOffset = !middlewareData.arrow && index.getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min ? center - min : center - max : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...shouldAddOffset && { alignmentOffset }
      },
      reset: shouldAddOffset
    };
  }
});

exports.arrow = arrow;
//# sourceMappingURL=arrow.js.map
