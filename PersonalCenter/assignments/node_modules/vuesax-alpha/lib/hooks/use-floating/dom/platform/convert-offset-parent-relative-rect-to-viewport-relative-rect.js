'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var index = require('../../utils/index.js');
var dom = require('../../utils/dom.js');
var getBoundingClientRect = require('../utils/get-bounding-client-rect.js');
var getScale = require('./get-scale.js');

function convertOffsetParentRelativeRectToViewportRelativeRect({
  rect,
  offsetParent,
  strategy
}) {
  const isOffsetParentAnElement = dom.isHTMLElement(offsetParent);
  const documentElement = dom.getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = { scrollLeft: 0, scrollTop: 0 };
  let scale = index.createCoords(1);
  const offsets = index.createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (dom.getNodeName(offsetParent) !== "body" || dom.isOverflowElement(documentElement)) {
      scroll = dom.getNodeScroll(offsetParent);
    }
    if (dom.isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect.getBoundingClientRect(offsetParent);
      scale = getScale.getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}

exports.convertOffsetParentRelativeRectToViewportRelativeRect = convertOffsetParentRelativeRectToViewportRelativeRect;
//# sourceMappingURL=convert-offset-parent-relative-rect-to-viewport-relative-rect.js.map
