'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lodashUnified = require('lodash-unified');
var index = require('../../utils/index.js');
var dom = require('../../utils/dom.js');
var getBoundingClientRect = require('../utils/get-bounding-client-rect.js');
var getDocumentRect = require('../utils/get-document-rect.js');
var getViewportRect = require('../utils/get-viewport-rect.js');
var getVisualOffsets = require('../utils/get-visual-offsets.js');
var getScale = require('./get-scale.js');
var isElement = require('./is-element.js');

function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect.getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = dom.isHTMLElement(element) ? getScale.getScale(element) : index.createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect.getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect.getDocumentRect(dom.getDocumentElement(element));
  } else if (isElement.isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets.getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return index.rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = dom.getParentNode(element);
  if (parentNode === stopNode || !isElement.isElement(parentNode) || dom.isLastTraversableNode(parentNode)) {
    return false;
  }
  return dom.getComputedStyle(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache == null ? void 0 : cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = dom.getOverflowAncestors(element, [], false).filter(
    (el) => isElement.isElement(el) && dom.getNodeName(el) !== "body"
  );
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = dom.getComputedStyle(element).position === "fixed";
  let currentNode = elementIsFixed ? dom.getParentNode(element) : element;
  while (isElement.isElement(currentNode) && !dom.isLastTraversableNode(currentNode)) {
    const computedStyle = dom.getComputedStyle(currentNode);
    const currentNodeIsContaining = dom.isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(
      currentContainingBlockComputedStyle.position
    ) || dom.isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = dom.getParentNode(currentNode);
  }
  cache == null ? void 0 : cache.set(element, result);
  return result;
}
function getClippingRect({
  element,
  boundary,
  rootBoundary,
  strategy
}) {
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : lodashUnified.concat([], boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce(
    (accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(
        element,
        clippingAncestor,
        strategy
      );
      accRect.top = index.max(rect.top, accRect.top);
      accRect.right = index.min(rect.right, accRect.right);
      accRect.bottom = index.min(rect.bottom, accRect.bottom);
      accRect.left = index.max(rect.left, accRect.left);
      return accRect;
    },
    getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy)
  );
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

exports.getClippingRect = getClippingRect;
//# sourceMappingURL=get-clipping-rect.js.map
