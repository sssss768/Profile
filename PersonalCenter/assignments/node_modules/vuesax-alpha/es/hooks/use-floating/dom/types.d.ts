import type { ClientRectObject, Dimensions, ElementRects, Rect, Strategy } from 'vuesax-alpha/es/hooks/use-floating/utils';
import type { ArrowOptions as CoreArrowOptions, ComputePositionConfig as CoreComputePositionConfig, DetectOverflowOptions as CoreDetectOverflowOptions, FlipOptions as CoreFlipOptions, Middleware as CoreMiddleware, MiddlewareState as CoreMiddlewareState, ShiftOptions as CoreShiftOptions, MiddlewareReturn, RootBoundary } from 'vuesax-alpha/es/hooks/use-floating/core';
declare type Prettify<T> = {
    [K in keyof T]: T[K];
} & unknown;
declare type Promisable<T> = T | Promise<T>;
export declare type Derivable<T> = (state: MiddlewareState) => T;
export interface Platform {
    getElementRects: (args: {
        reference: ReferenceElement;
        floating: FloatingElement;
        strategy: Strategy;
    }) => Promisable<ElementRects>;
    getClippingRect: (args: {
        element: Element;
        boundary: Boundary;
        rootBoundary: RootBoundary;
        strategy: Strategy;
    }) => Promisable<Rect>;
    getDimensions: (element: Element) => Promisable<Dimensions>;
    convertOffsetParentRelativeRectToViewportRelativeRect?: (args: {
        rect: Rect;
        offsetParent: Element;
        strategy: Strategy;
    }) => Promisable<Rect>;
    getOffsetParent?: (element: Element, polyfill?: (element: HTMLElement) => Element | null) => Promisable<Element | Window>;
    isElement?: (value: unknown) => Promisable<boolean>;
    getDocumentElement?: (element: Element) => Promisable<HTMLElement>;
    getClientRects?: (element: Element) => Promisable<Array<ClientRectObject>>;
    isRTL?: (element: Element) => Promisable<boolean>;
    getScale?: (element: HTMLElement) => Promisable<{
        x: number;
        y: number;
    }>;
}
export interface NodeScroll {
    scrollLeft: number;
    scrollTop: number;
}
export declare type Boundary = 'clippingAncestors' | Element | Array<Element> | Rect;
export declare type DetectOverflowOptions = Prettify<Omit<CoreDetectOverflowOptions, 'boundary'> & {
    boundary?: Boundary;
}>;
export declare type ComputePositionConfig = Prettify<Omit<CoreComputePositionConfig, 'middleware' | 'platform'> & {
    middleware?: Array<Middleware | null | undefined | false>;
    platform?: Platform;
}>;
export interface VirtualElement {
    getBoundingClientRect(): ClientRectObject;
    contextElement?: Element;
}
export declare type ReferenceElement = Element | VirtualElement;
export declare type FloatingElement = HTMLElement;
export interface Elements {
    reference: ReferenceElement;
    floating: FloatingElement;
}
export declare type MiddlewareState = Prettify<Omit<CoreMiddlewareState, 'elements'> & {
    elements: Elements;
}>;
export declare type Middleware = Prettify<Omit<CoreMiddleware, 'fn'> & {
    fn(state: MiddlewareState): Promisable<MiddlewareReturn>;
}>;
export declare type ArrowOptions = Prettify<Omit<CoreArrowOptions, 'element'> & {
    element: Element;
}>;
export declare type ShiftOptions = Prettify<Omit<CoreShiftOptions, 'boundary'> & DetectOverflowOptions>;
export declare type FlipOptions = Prettify<Omit<CoreFlipOptions, 'boundary'> & DetectOverflowOptions>;
export {};
