import type { PropType } from 'vue';
import type { IfNativePropType, IfVsProp, NativePropType, VsProp, VsPropConvert, VsPropFinalized, VsPropInput, VsPropMergeType } from './types';
export declare const vsPropKey = "__vsPropKey";
export declare const definePropType: <T>(val: any) => PropType<T>;
export declare const isVsProp: (val: unknown) => val is VsProp<any, any, any>;
/**
 * @description Build prop. It can better optimize prop types
 * @example
  // limited options
  // the type will be PropType<'light' | 'dark'>
  buildProp({
    type: String,
    values: ['light', 'dark'],
  } as const)
  * @example
  // limited options and other types
  // the type will be PropType<'small' | 'large' | number>
  buildProp({
    type: [String, Number],
    values: ['small', 'large'],
    validator: (val: unknown): val is number => typeof val === 'number',
  } as const)
  @link see more: https://github.com/vuesax-alphax/vuesax-alpha/pull/3341
 */
export declare const buildProp: <Type = never, Value = never, Validator = never, Default extends VsPropMergeType<Type, Value, Validator> = never, Required_1 extends boolean = false>(prop: VsPropInput<Type, Value, Validator, Default, Required_1>, key?: string | undefined) => VsPropFinalized<Type, Value, Validator, Default, Required_1>;
export declare const buildProps: <Props extends Record<string, {
    __vsPropKey: true;
} | NativePropType | VsPropInput<any, any, any, any, any>>>(props: Props) => { [K in keyof Props]: IfVsProp<Props[K], Props[K], IfNativePropType<Props[K], Props[K], VsPropConvert<Props[K]>>>; };
