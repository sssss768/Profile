import type { FocusLayer } from './utils';
declare const _default: import("vue").DefineComponent<{
    readonly loop: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    readonly trapped: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    readonly focusTrapEl: {
        readonly type: import("vue").PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    readonly focusStartEl: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => (HTMLElement | "first" | "container") & {}) | (() => HTMLElement | "first" | "container") | ((new (...args: any[]) => (HTMLElement | "first" | "container") & {}) | (() => HTMLElement | "first" | "container"))[], unknown, unknown, "first", boolean>;
}, {
    props: import("@vue/shared").LooseRequired<{
        readonly focusStartEl: import("vuesax-alpha/es/utils").VsPropMergeType<(new (...args: any[]) => (HTMLElement | "first" | "container") & {}) | (() => HTMLElement | "first" | "container") | ((new (...args: any[]) => (HTMLElement | "first" | "container") & {}) | (() => HTMLElement | "first" | "container"))[], unknown, unknown>;
        readonly loop?: import("vuesax-alpha/es/utils").VsPropMergeType<BooleanConstructor, unknown, unknown> | undefined;
        readonly trapped?: import("vuesax-alpha/es/utils").VsPropMergeType<BooleanConstructor, unknown, unknown> | undefined;
        readonly focusTrapEl?: HTMLElement | undefined;
        readonly onFocusAfterTrapped?: ((e: Event) => any) | undefined;
        readonly onFocusAfterReleased?: ((e: CustomEvent<any>) => any) | undefined;
        readonly onFocusin?: ((e: Event | FocusEvent) => any) | undefined;
        readonly onFocusout?: ((e: Event | FocusEvent) => any) | undefined;
        readonly onFocusoutPrevented?: ((e: CustomEvent<any>) => any) | undefined;
        readonly onReleaseRequested?: ((e: KeyboardEvent | Event) => any) | undefined;
    } & {}>;
    emit: ((event: "focusAfterTrapped", e: Event) => void) & ((event: "focusAfterReleased", e: CustomEvent<any>) => void) & ((event: "focusin", e: Event | FocusEvent) => void) & ((event: "focusout", e: Event | FocusEvent) => void) & ((event: "focusoutPrevented", e: CustomEvent<any>) => void) & ((event: "releaseRequested", e: KeyboardEvent | Event) => void);
    forwardRef: import("vue").Ref<HTMLElement | undefined>;
    lastFocusBeforeTrapped: HTMLElement | null;
    lastFocusAfterTrapped: HTMLElement | null;
    focusReason: import("vue").Ref<"pointer" | "keyboard" | undefined>;
    focusLayer: FocusLayer;
    onKeydown: (e: KeyboardEvent) => void;
    trapOnFocus: (e: Event) => void;
    releaseOnFocus: (e: unknown) => void;
    onFocusIn: (e: FocusEvent) => void;
    onFocusOut: (e: Event) => void;
    startTrap: () => Promise<void>;
    stopTrap: () => void;
}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
    focusAfterTrapped: (e: Event) => boolean;
    focusAfterReleased: (e: CustomEvent<any>) => CustomEvent<any>;
    focusin: (e: Event | FocusEvent) => boolean;
    focusout: (e: Event | FocusEvent) => boolean;
    focusoutPrevented: (e: CustomEvent<any>) => CustomEvent<any>;
    releaseRequested: (e: KeyboardEvent | Event) => boolean;
}, string, import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, Readonly<import("vue").ExtractPropTypes<{
    readonly loop: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    readonly trapped: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    readonly focusTrapEl: {
        readonly type: import("vue").PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    readonly focusStartEl: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => (HTMLElement | "first" | "container") & {}) | (() => HTMLElement | "first" | "container") | ((new (...args: any[]) => (HTMLElement | "first" | "container") & {}) | (() => HTMLElement | "first" | "container"))[], unknown, unknown, "first", boolean>;
}>> & {
    onFocusAfterTrapped?: ((e: Event) => any) | undefined;
    onFocusAfterReleased?: ((e: CustomEvent<any>) => any) | undefined;
    onFocusin?: ((e: Event | FocusEvent) => any) | undefined;
    onFocusout?: ((e: Event | FocusEvent) => any) | undefined;
    onFocusoutPrevented?: ((e: CustomEvent<any>) => any) | undefined;
    onReleaseRequested?: ((e: KeyboardEvent | Event) => any) | undefined;
}, {
    readonly focusStartEl: import("vuesax-alpha/es/utils").VsPropMergeType<(new (...args: any[]) => (HTMLElement | "first" | "container") & {}) | (() => HTMLElement | "first" | "container") | ((new (...args: any[]) => (HTMLElement | "first" | "container") & {}) | (() => HTMLElement | "first" | "container"))[], unknown, unknown>;
}, {}>;
export default _default;
