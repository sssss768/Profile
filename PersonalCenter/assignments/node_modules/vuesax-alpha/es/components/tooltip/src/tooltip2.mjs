import { defineComponent, ref, computed, openBlock, createBlock, unref, withCtx, renderSlot } from 'vue';
import '../../../hooks/index.mjs';
import { VsPopper } from '../../popper/index.mjs';
import '../../../utils/index.mjs';
import { tooltipProps } from './tooltip.mjs';
import { useTooltipDeprecated } from './useTooltipDeprecated.mjs';
import _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';
import { useNamespace } from '../../../hooks/use-namespace/index.mjs';
import { getVsColor } from '../../../utils/color.mjs';
import { useVuesaxBaseComponent } from '../../../hooks/use-base-component/index.mjs';
import { useColor } from '../../../hooks/use-common-props/index.mjs';

const __default__ = defineComponent({
  name: "VsTooltip"
});
const _sfc_main = defineComponent({
  ...__default__,
  props: tooltipProps,
  setup(__props, { expose: __expose }) {
    const props = __props;
    const ns = useNamespace("tooltip");
    const popperRef = ref();
    const tooltipStyle = computed(() => [
      ns.cssVar({
        color: getVsColor(props.color)
      })
    ]);
    const vsBaseClasses = useVuesaxBaseComponent(useColor());
    const tooltipKls = computed(() => [
      ns.b(),
      vsBaseClasses,
      ns.is("loading", props.loading),
      ns.is(props.type, !!props.type),
      ns.is(props.shape, !!props.shape),
      ns.is("not-arrow", !props.showArrow),
      ns.is(props.effect)
    ]);
    useTooltipDeprecated(props);
    __expose({ popperRef });
    return (_ctx, _cache) => {
      var _a, _b;
      return openBlock(), createBlock(unref(VsPopper), {
        ref_key: "popperRef",
        ref: popperRef,
        interactivity: _ctx.interactivity,
        "popper-class": [tooltipKls.value, (_a = _ctx.popperClass) != null ? _a : ""],
        "popper-style": [(_b = _ctx.popperStyle) != null ? _b : "", tooltipStyle.value],
        animation: _ctx.animation,
        "append-to": _ctx.appendTo,
        flip: _ctx.flip,
        shift: _ctx.shift,
        "window-resize": _ctx.windowResize,
        "window-scroll": _ctx.windowScroll,
        disabled: _ctx.disabled,
        fit: _ctx.fit,
        loading: _ctx.loading,
        "hide-after": _ctx.hideAfter,
        offset: _ctx.offset,
        placement: _ctx.placement,
        "show-after": _ctx.showAfter,
        "show-arrow": _ctx.showArrow,
        strategy: _ctx.strategy,
        teleported: _ctx.teleported,
        trigger: _ctx.trigger,
        "trigger-class": _ctx.triggerClass,
        "trigger-style": _ctx.triggerStyle,
        "virtual-ref": _ctx.virtualRef,
        "virtual-triggering": _ctx.virtualTriggering,
        "z-index": _ctx.zIndex,
        "on-blur": _ctx.onBlur,
        "on-click": _ctx.onClick,
        "on-focus": _ctx.onFocus,
        "on-keydown": _ctx.onKeydown,
        "on-contextmenu": _ctx.onContextmenu,
        "on-mouseenter": _ctx.onMouseenter,
        "on-mouseleave": _ctx.onMouseleave
      }, {
        content: withCtx(() => [
          renderSlot(_ctx.$slots, "content")
        ]),
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["interactivity", "popper-class", "popper-style", "animation", "append-to", "flip", "shift", "window-resize", "window-scroll", "disabled", "fit", "loading", "hide-after", "offset", "placement", "show-after", "show-arrow", "strategy", "teleported", "trigger", "trigger-class", "trigger-style", "virtual-ref", "virtual-triggering", "z-index", "on-blur", "on-click", "on-focus", "on-keydown", "on-contextmenu", "on-mouseenter", "on-mouseleave"]);
    };
  }
});
var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main, [["__file", "/home/runner/work/vuesax-alpha/vuesax-alpha/packages/components/tooltip/src/tooltip.vue"]]);

export { Tooltip as default };
//# sourceMappingURL=tooltip2.mjs.map
