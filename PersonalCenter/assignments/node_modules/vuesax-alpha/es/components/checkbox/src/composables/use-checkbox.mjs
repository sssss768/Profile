import { ref, inject, computed, toRaw, onBeforeMount } from 'vue';
import { isEqual, isNil, toArray } from 'lodash-unified';
import '../../../../utils/index.mjs';
import '../../../../constants/index.mjs';
import '../../../../hooks/index.mjs';
import '../../../../tokens/index.mjs';
import { isArray, isObject } from '@vue/shared';
import { checkboxGroupContextKey } from '../../../../tokens/checkbox.mjs';
import { isUndefined, isBoolean } from '../../../../utils/types.mjs';
import { useDisabled } from '../../../../hooks/use-common-props/index.mjs';
import { UPDATE_MODEL_EVENT } from '../../../../constants/event.mjs';

const setStoreValue = (props, { model }) => {
  if (props.checked) {
    if (isArray(model.value) && !model.value.includes(props.value)) {
      model.value.push(props.value);
    } else {
      model.value = props.value || true;
    }
  }
};
const useCheckbox = (props, emit, slots) => {
  const selfModel = ref(false);
  const isLimitExceeded = ref(false);
  const checkboxGroup = inject(checkboxGroupContextKey, void 0);
  const isGroup = computed(() => isUndefined(checkboxGroup) === false);
  const isChecked = computed(() => {
    const value = model.value || (checkboxGroup == null ? void 0 : checkboxGroup.modelValue);
    if (isBoolean(value))
      return value;
    if (isArray(value)) {
      if (isObject(props.value)) {
        return value.map(toRaw).some((o) => isEqual(o, props.value));
      }
      return value.map(toRaw).includes(props.value);
    }
    if (value !== null && value !== void 0)
      return value === props.value;
    if (props.checkedForce)
      return true;
    return !!value;
  });
  const hasOwnLabel = computed(() => {
    return !!(slots.default || props.label);
  });
  const isLimitDisabled = computed(() => {
    var _a, _b;
    const max = Number(((_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value) || props.max);
    const min = Number(((_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value) || props.min);
    return !isNil(max) && toArray(model.value).length >= max && !isChecked.value || !isNil(min) && toArray(model.value).length <= min && isChecked.value;
  });
  const isDisabled = useDisabled(
    computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value)
  );
  const model = computed({
    get() {
      var _a;
      return isGroup.value ? (_a = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a.value : props.modelValue || selfModel.value;
    },
    set(val) {
      var _a, _b;
      if (isDisabled.value || isLimitExceeded.value)
        return;
      if (isGroup.value && isArray(val)) {
        isLimitExceeded.value = ((_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value);
        isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
        return;
      }
      let updatedValue = val;
      if (val && props.value) {
        updatedValue = props.value;
      }
      if (isBoolean(updatedValue)) {
        emit(UPDATE_MODEL_EVENT, updatedValue);
      } else if (isArray(props.modelValue)) {
        const modelValueRaw = props.modelValue.map(toRaw);
        const indexVal = modelValueRaw.findIndex(
          (e) => isEqual(e, updatedValue)
        );
        if (indexVal == -1) {
          modelValueRaw.push(updatedValue);
        } else {
          modelValueRaw.splice(indexVal, 1);
        }
        emit("update:modelValue", modelValueRaw);
      } else {
        if (updatedValue !== props.modelValue) {
          if (val) {
            emit(UPDATE_MODEL_EVENT, [props.modelValue, updatedValue]);
          } else {
            emit(UPDATE_MODEL_EVENT, updatedValue);
          }
        } else {
          emit(UPDATE_MODEL_EVENT, props.notValue || false);
        }
      }
      selfModel.value = !!val;
    }
  });
  onBeforeMount(() => {
    if (props.checked || props.checkedForce) {
      model.value = props.value || true;
    }
  });
  const getCheckboxValue = (value) => {
    return value === props.value || value === true;
  };
  const handleChange = (e) => {
    if (isLimitExceeded.value)
      return;
    const target = e.target;
    emit("change", getCheckboxValue(target.checked));
  };
  setStoreValue(props, { model });
  return {
    isChecked,
    isDisabled,
    hasOwnLabel,
    model,
    handleChange
  };
};

export { useCheckbox };
//# sourceMappingURL=use-checkbox.mjs.map
