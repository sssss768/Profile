import type { Placement } from 'vuesax-alpha/es/hooks/use-floating/vue';
import type { EmitFn } from 'vuesax-alpha/es/utils';
import type Popper from './popper.vue';
import type { ExtractPropTypes } from 'vue';
export declare const usePopperModelToggleProps: import("vuesax-alpha/es/hooks").UseModelTogglePropsRaw<"visible">, usePopperModelToggleEmits: "update:visible"[], usePopperModelToggle: ({ indicator, toggleReason, shouldHideWhenRouteChanges, shouldProceed, processBeforeClosing, onShow, onHide, }: import("vuesax-alpha/es/hooks").ModelToggleParams) => {
    hide: (event?: Event | undefined) => void;
    show: (event?: Event | undefined) => void;
    toggle: () => void;
    hasUpdateHandler: import("vue").ComputedRef<boolean>;
};
export declare const popperProps: {
    processBeforeOpen: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => () => boolean) | (() => () => boolean) | {
        (): () => boolean;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => () => boolean) | (() => () => boolean) | {
        (): () => boolean;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => true, boolean>;
    processBeforeClose: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => () => boolean) | (() => () => boolean) | {
        (): () => boolean;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => () => boolean) | (() => () => boolean) | {
        (): () => boolean;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => true, boolean>;
    showArrow: import("vuesax-alpha/es/utils").VsPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    loading: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    visible: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => (boolean | null) & {}) | (() => boolean | null) | ((new (...args: any[]) => (boolean | null) & {}) | (() => boolean | null))[], never, never, null, false>;
    "onUpdate:visible": {
        readonly type: import("vue").PropType<(val: boolean) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    disabled: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    trigger: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => import("vuesax-alpha/es/utils").Arrayable<import("./trigger").PopperTriggerType> & {}) | (() => import("vuesax-alpha/es/utils").Arrayable<import("./trigger").PopperTriggerType>) | ((new (...args: any[]) => import("vuesax-alpha/es/utils").Arrayable<import("./trigger").PopperTriggerType> & {}) | (() => import("vuesax-alpha/es/utils").Arrayable<import("./trigger").PopperTriggerType>))[], unknown, unknown, string, boolean>;
    virtualRef: {
        readonly type: import("vue").PropType<import("../../..").Measurable>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    virtualTriggering: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    onMouseenter: {
        readonly type: import("vue").PropType<(e: Event) => boolean | void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    onMouseleave: {
        readonly type: import("vue").PropType<(e: Event) => boolean | void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    onClick: {
        readonly type: import("vue").PropType<(e: Event) => boolean | void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    onKeydown: {
        readonly type: import("vue").PropType<(e: Event) => boolean | void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    onFocus: {
        readonly type: import("vue").PropType<(e: Event) => boolean | void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    onBlur: {
        readonly type: import("vue").PropType<(e: Event) => boolean | void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    onContextmenu: {
        readonly type: import("vue").PropType<(e: Event) => boolean | void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    triggerClass: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<(new (...args: any[]) => (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) & {}) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) & {}) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    triggerStyle: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<(new (...args: any[]) => import("vue").StyleValue & {}) | (() => import("vue").StyleValue) | ((new (...args: any[]) => import("vue").StyleValue & {}) | (() => import("vue").StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    animation: import("vuesax-alpha/es/utils").VsPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    appendTo: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<(new (...args: any[]) => (string | HTMLElement) & {}) | (() => string | HTMLElement) | ((new (...args: any[]) => (string | HTMLElement) & {}) | (() => string | HTMLElement))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    teleported: import("vuesax-alpha/es/utils").VsPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    strategy: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => import("vuesax-alpha/es/hooks").Strategy & {}) | (() => import("vuesax-alpha/es/hooks").Strategy) | ((new (...args: any[]) => import("vuesax-alpha/es/hooks").Strategy & {}) | (() => import("vuesax-alpha/es/hooks").Strategy))[], "fixed" | "absolute", unknown, string, boolean>;
    fit: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    placement: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => Placement & {}) | (() => Placement) | ((new (...args: any[]) => Placement & {}) | (() => Placement))[], "top" | "top-start" | "top-end" | "bottom" | "bottom-start" | "bottom-end" | "left" | "left-start" | "left-end" | "right" | "right-start" | "right-end", unknown, string, boolean>;
    zIndex: import("vuesax-alpha/es/utils").VsPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    interactivity: import("vuesax-alpha/es/utils").VsPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    flip: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => (boolean | {
        padding?: import("vuesax-alpha/es/hooks").Padding | undefined;
        rootBoundary?: import("vuesax-alpha/es/hooks").RootBoundary | undefined;
        elementContext?: import("../../../hooks/use-floating/core").ElementContext | undefined;
        altBoundary?: boolean | undefined;
        mainAxis?: boolean | undefined;
        crossAxis?: boolean | undefined;
        fallbackPlacements?: Placement[] | undefined;
        fallbackStrategy?: "bestFit" | "initialPlacement" | undefined;
        fallbackAxisSideDirection?: "none" | "end" | "start" | undefined;
        flipAlignment?: boolean | undefined;
        boundary?: import("vuesax-alpha/es/hooks").Boundary | undefined;
    }) & {}) | (() => boolean | {
        padding?: import("vuesax-alpha/es/hooks").Padding | undefined;
        rootBoundary?: import("vuesax-alpha/es/hooks").RootBoundary | undefined;
        elementContext?: import("../../../hooks/use-floating/core").ElementContext | undefined;
        altBoundary?: boolean | undefined;
        mainAxis?: boolean | undefined;
        crossAxis?: boolean | undefined;
        fallbackPlacements?: Placement[] | undefined;
        fallbackStrategy?: "bestFit" | "initialPlacement" | undefined;
        fallbackAxisSideDirection?: "none" | "end" | "start" | undefined;
        flipAlignment?: boolean | undefined;
        boundary?: import("vuesax-alpha/es/hooks").Boundary | undefined;
    }) | ((new (...args: any[]) => (boolean | {
        padding?: import("vuesax-alpha/es/hooks").Padding | undefined;
        rootBoundary?: import("vuesax-alpha/es/hooks").RootBoundary | undefined;
        elementContext?: import("../../../hooks/use-floating/core").ElementContext | undefined;
        altBoundary?: boolean | undefined;
        mainAxis?: boolean | undefined;
        crossAxis?: boolean | undefined;
        fallbackPlacements?: Placement[] | undefined;
        fallbackStrategy?: "bestFit" | "initialPlacement" | undefined;
        fallbackAxisSideDirection?: "none" | "end" | "start" | undefined;
        flipAlignment?: boolean | undefined;
        boundary?: import("vuesax-alpha/es/hooks").Boundary | undefined;
    }) & {}) | (() => boolean | {
        padding?: import("vuesax-alpha/es/hooks").Padding | undefined;
        rootBoundary?: import("vuesax-alpha/es/hooks").RootBoundary | undefined;
        elementContext?: import("../../../hooks/use-floating/core").ElementContext | undefined;
        altBoundary?: boolean | undefined;
        mainAxis?: boolean | undefined;
        crossAxis?: boolean | undefined;
        fallbackPlacements?: Placement[] | undefined;
        fallbackStrategy?: "bestFit" | "initialPlacement" | undefined;
        fallbackAxisSideDirection?: "none" | "end" | "start" | undefined;
        flipAlignment?: boolean | undefined;
        boundary?: import("vuesax-alpha/es/hooks").Boundary | undefined;
    }))[], unknown, unknown, () => {}, boolean>;
    shift: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => (boolean | {
        padding?: import("vuesax-alpha/es/hooks").Padding | undefined;
        rootBoundary?: import("vuesax-alpha/es/hooks").RootBoundary | undefined;
        elementContext?: import("../../../hooks/use-floating/core").ElementContext | undefined;
        altBoundary?: boolean | undefined;
        mainAxis?: boolean | undefined;
        crossAxis?: boolean | undefined;
        limiter?: {
            fn: (state: import("../../../hooks/use-floating/core").MiddlewareState) => import("vuesax-alpha/es/hooks").Coords;
            options?: any;
        } | undefined;
        boundary?: import("vuesax-alpha/es/hooks").Boundary | undefined;
    }) & {}) | (() => boolean | {
        padding?: import("vuesax-alpha/es/hooks").Padding | undefined;
        rootBoundary?: import("vuesax-alpha/es/hooks").RootBoundary | undefined;
        elementContext?: import("../../../hooks/use-floating/core").ElementContext | undefined;
        altBoundary?: boolean | undefined;
        mainAxis?: boolean | undefined;
        crossAxis?: boolean | undefined;
        limiter?: {
            fn: (state: import("../../../hooks/use-floating/core").MiddlewareState) => import("vuesax-alpha/es/hooks").Coords;
            options?: any;
        } | undefined;
        boundary?: import("vuesax-alpha/es/hooks").Boundary | undefined;
    }) | ((new (...args: any[]) => (boolean | {
        padding?: import("vuesax-alpha/es/hooks").Padding | undefined;
        rootBoundary?: import("vuesax-alpha/es/hooks").RootBoundary | undefined;
        elementContext?: import("../../../hooks/use-floating/core").ElementContext | undefined;
        altBoundary?: boolean | undefined;
        mainAxis?: boolean | undefined;
        crossAxis?: boolean | undefined;
        limiter?: {
            fn: (state: import("../../../hooks/use-floating/core").MiddlewareState) => import("vuesax-alpha/es/hooks").Coords;
            options?: any;
        } | undefined;
        boundary?: import("vuesax-alpha/es/hooks").Boundary | undefined;
    }) & {}) | (() => boolean | {
        padding?: import("vuesax-alpha/es/hooks").Padding | undefined;
        rootBoundary?: import("vuesax-alpha/es/hooks").RootBoundary | undefined;
        elementContext?: import("../../../hooks/use-floating/core").ElementContext | undefined;
        altBoundary?: boolean | undefined;
        mainAxis?: boolean | undefined;
        crossAxis?: boolean | undefined;
        limiter?: {
            fn: (state: import("../../../hooks/use-floating/core").MiddlewareState) => import("vuesax-alpha/es/hooks").Coords;
            options?: any;
        } | undefined;
        boundary?: import("vuesax-alpha/es/hooks").Boundary | undefined;
    }))[], unknown, unknown, () => {}, boolean>;
    windowResize: import("vuesax-alpha/es/utils").VsPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    windowScroll: import("vuesax-alpha/es/utils").VsPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    offset: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => import("vuesax-alpha/es/hooks").OffsetOptions & {}) | (() => import("vuesax-alpha/es/hooks").OffsetOptions) | ((new (...args: any[]) => import("vuesax-alpha/es/hooks").OffsetOptions & {}) | (() => import("vuesax-alpha/es/hooks").OffsetOptions))[], unknown, unknown, number, boolean>;
    content: {
        readonly type: import("vue").PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    rawContent: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    popperClass: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | any)[])[])[])[])[])[])[])[])[])[])[]) & {}) | (() => string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | any)[])[])[])[])[])[])[])[])[])[])[]) & {}) | (() => string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | (string | {
        [x: string]: boolean;
    } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown, string, boolean>;
    popperStyle: import("vuesax-alpha/es/utils").VsPropFinalized<(new (...args: any[]) => import("vue").StyleValue & {}) | (() => import("vue").StyleValue) | ((new (...args: any[]) => import("vue").StyleValue & {}) | (() => import("vue").StyleValue))[], unknown, unknown, string, boolean>;
    persistent: {
        readonly type: import("vue").PropType<import("vuesax-alpha/es/utils").VsPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __vsPropKey: true;
    };
    showAfter: import("vuesax-alpha/es/utils").VsPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    hideAfter: import("vuesax-alpha/es/utils").VsPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    autoClose: import("vuesax-alpha/es/utils").VsPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
};
export declare type PopperProps = ExtractPropTypes<typeof popperProps>;
export declare const popperEmits: string[];
export declare type PopperEmits = typeof popperEmits;
export declare type PopperEmitFn = EmitFn<PopperEmits>;
export declare type PopperInstance = InstanceType<typeof Popper>;
export declare type PopperExpose = {
    triggerRef: HTMLElement | undefined;
    contentRef: HTMLElement | undefined;
    isFocusInsideContent: () => boolean;
    updatePopper: (shouldUpdateZIndex?: boolean) => void;
    onOpen: (event?: Event | undefined) => void;
    onClose: (event?: Event | undefined) => void;
    hide: (event?: Event | undefined) => void;
    popperPlacement: Placement;
};
