/*! Vuesax Alpha v0.2.0-beta.80 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VuesaxAlpha = {}, global.Vue));
})(this, (function (exports, vue) { 'use strict';

  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;

  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();

  var Symbol$1 = root.Symbol;

  var objectProto$s = Object.prototype;
  var hasOwnProperty$p = objectProto$s.hasOwnProperty;
  var nativeObjectToString$3 = objectProto$s.toString;
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty$p.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString$3.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  var objectProto$r = Object.prototype;
  var nativeObjectToString$2 = objectProto$r.toString;
  function objectToString(value) {
    return nativeObjectToString$2.call(value);
  }

  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }

  var symbolTag$3 = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
  }

  var NAN$2 = 0 / 0;
  function baseToNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN$2;
    }
    return +value;
  }

  function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  var isArray$1 = Array.isArray;

  var INFINITY$5 = 1 / 0;
  var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0;
  var symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray$1(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY$5 ? "-0" : result;
  }

  function createMathOperation(operator, defaultValue) {
    return function(value, other) {
      var result;
      if (value === void 0 && other === void 0) {
        return defaultValue;
      }
      if (value !== void 0) {
        result = value;
      }
      if (other !== void 0) {
        if (result === void 0) {
          return other;
        }
        if (typeof value == "string" || typeof other == "string") {
          value = baseToString(value);
          other = baseToString(other);
        } else {
          value = baseToNumber(value);
          other = baseToNumber(other);
        }
        result = operator(value, other);
      }
      return result;
    };
  }

  var add = createMathOperation(function(augend, addend) {
    return augend + addend;
  }, 0);

  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) {
    }
    return index;
  }

  var reTrimStart$2 = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart$2, "") : string;
  }

  function isObject$1(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }

  var NAN$1 = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN$1;
    }
    if (isObject$1(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject$1(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN$1 : +value;
  }

  var INFINITY$4 = 1 / 0;
  var MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY$4 || value === -INFINITY$4) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }

  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }

  var FUNC_ERROR_TEXT$b = "Expected a function";
  function after(n, func) {
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$b);
    }
    n = toInteger(n);
    return function() {
      if (--n < 1) {
        return func.apply(this, arguments);
      }
    };
  }

  function identity$1(value) {
    return value;
  }

  var asyncTag = "[object AsyncFunction]";
  var funcTag$2 = "[object Function]";
  var genTag$1 = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction$1(value) {
    if (!isObject$1(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
  }

  var coreJsData = root["__core-js_shared__"];

  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  var funcProto$2 = Function.prototype;
  var funcToString$2 = funcProto$2.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }

  var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto$1 = Function.prototype;
  var objectProto$q = Object.prototype;
  var funcToString$1 = funcProto$1.toString;
  var hasOwnProperty$o = objectProto$q.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString$1.call(hasOwnProperty$o).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }

  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }

  var WeakMap = getNative(root, "WeakMap");

  var metaMap = WeakMap && new WeakMap();

  var baseSetData = !metaMap ? identity$1 : function(func, data) {
    metaMap.set(func, data);
    return func;
  };

  var objectCreate = Object.create;
  var baseCreate = function() {
    function object() {
    }
    return function(proto) {
      if (!isObject$1(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();

  function createCtor(Ctor) {
    return function() {
      var args = arguments;
      switch (args.length) {
        case 0:
          return new Ctor();
        case 1:
          return new Ctor(args[0]);
        case 2:
          return new Ctor(args[0], args[1]);
        case 3:
          return new Ctor(args[0], args[1], args[2]);
        case 4:
          return new Ctor(args[0], args[1], args[2], args[3]);
        case 5:
          return new Ctor(args[0], args[1], args[2], args[3], args[4]);
        case 6:
          return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
        case 7:
          return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
      }
      var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
      return isObject$1(result) ? result : thisBinding;
    };
  }

  var WRAP_BIND_FLAG$8 = 1;
  function createBind(func, bitmask, thisArg) {
    var isBind = bitmask & WRAP_BIND_FLAG$8, Ctor = createCtor(func);
    function wrapper() {
      var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
      return fn.apply(isBind ? thisArg : this, arguments);
    }
    return wrapper;
  }

  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  var nativeMax$g = Math.max;
  function composeArgs(args, partials, holders, isCurried) {
    var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax$g(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
    while (++leftIndex < leftLength) {
      result[leftIndex] = partials[leftIndex];
    }
    while (++argsIndex < holdersLength) {
      if (isUncurried || argsIndex < argsLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
    }
    while (rangeLength--) {
      result[leftIndex++] = args[argsIndex++];
    }
    return result;
  }

  var nativeMax$f = Math.max;
  function composeArgsRight(args, partials, holders, isCurried) {
    var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax$f(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
    while (++argsIndex < rangeLength) {
      result[argsIndex] = args[argsIndex];
    }
    var offset = argsIndex;
    while (++rightIndex < rightLength) {
      result[offset + rightIndex] = partials[rightIndex];
    }
    while (++holdersIndex < holdersLength) {
      if (isUncurried || argsIndex < argsLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
    }
    return result;
  }

  function countHolders(array, placeholder) {
    var length = array.length, result = 0;
    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  function baseLodash() {
  }

  var MAX_ARRAY_LENGTH$6 = 4294967295;
  function LazyWrapper(value) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__dir__ = 1;
    this.__filtered__ = false;
    this.__iteratees__ = [];
    this.__takeCount__ = MAX_ARRAY_LENGTH$6;
    this.__views__ = [];
  }
  LazyWrapper.prototype = baseCreate(baseLodash.prototype);
  LazyWrapper.prototype.constructor = LazyWrapper;

  function noop$1() {
  }

  var getData = !metaMap ? noop$1 : function(func) {
    return metaMap.get(func);
  };

  var realNames = {};

  var objectProto$p = Object.prototype;
  var hasOwnProperty$n = objectProto$p.hasOwnProperty;
  function getFuncName(func) {
    var result = func.name + "", array = realNames[result], length = hasOwnProperty$n.call(realNames, result) ? array.length : 0;
    while (length--) {
      var data = array[length], otherFunc = data.func;
      if (otherFunc == null || otherFunc == func) {
        return data.name;
      }
    }
    return result;
  }

  function LodashWrapper(value, chainAll) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__chain__ = !!chainAll;
    this.__index__ = 0;
    this.__values__ = void 0;
  }
  LodashWrapper.prototype = baseCreate(baseLodash.prototype);
  LodashWrapper.prototype.constructor = LodashWrapper;

  function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  function wrapperClone(wrapper) {
    if (wrapper instanceof LazyWrapper) {
      return wrapper.clone();
    }
    var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
    result.__actions__ = copyArray(wrapper.__actions__);
    result.__index__ = wrapper.__index__;
    result.__values__ = wrapper.__values__;
    return result;
  }

  var objectProto$o = Object.prototype;
  var hasOwnProperty$m = objectProto$o.hasOwnProperty;
  function lodash(value) {
    if (isObjectLike(value) && !isArray$1(value) && !(value instanceof LazyWrapper)) {
      if (value instanceof LodashWrapper) {
        return value;
      }
      if (hasOwnProperty$m.call(value, "__wrapped__")) {
        return wrapperClone(value);
      }
    }
    return new LodashWrapper(value);
  }
  lodash.prototype = baseLodash.prototype;
  lodash.prototype.constructor = lodash;

  function isLaziable(func) {
    var funcName = getFuncName(func), other = lodash[funcName];
    if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
      return false;
    }
    if (func === other) {
      return true;
    }
    var data = getData(other);
    return !!data && func === data[0];
  }

  var HOT_COUNT = 800;
  var HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }

  var setData = shortOut(baseSetData);

  var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
  var reSplitDetails = /,? & /;
  function getWrapDetails(source) {
    var match = source.match(reWrapDetails);
    return match ? match[1].split(reSplitDetails) : [];
  }

  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
  function insertWrapDetails(source, details) {
    var length = details.length;
    if (!length) {
      return source;
    }
    var lastIndex = length - 1;
    details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
    details = details.join(length > 2 ? ", " : " ");
    return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
  }

  function constant(value) {
    return function() {
      return value;
    };
  }

  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();

  var baseSetToString = !defineProperty ? identity$1 : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string),
      "writable": true
    });
  };

  var setToString = shortOut(baseSetToString);

  function arrayEach(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  function baseIsNaN(value) {
    return value !== value;
  }

  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  var WRAP_BIND_FLAG$7 = 1;
  var WRAP_BIND_KEY_FLAG$6 = 2;
  var WRAP_CURRY_FLAG$6 = 8;
  var WRAP_CURRY_RIGHT_FLAG$3 = 16;
  var WRAP_PARTIAL_FLAG$6 = 32;
  var WRAP_PARTIAL_RIGHT_FLAG$3 = 64;
  var WRAP_ARY_FLAG$4 = 128;
  var WRAP_REARG_FLAG$3 = 256;
  var WRAP_FLIP_FLAG$2 = 512;
  var wrapFlags = [
    ["ary", WRAP_ARY_FLAG$4],
    ["bind", WRAP_BIND_FLAG$7],
    ["bindKey", WRAP_BIND_KEY_FLAG$6],
    ["curry", WRAP_CURRY_FLAG$6],
    ["curryRight", WRAP_CURRY_RIGHT_FLAG$3],
    ["flip", WRAP_FLIP_FLAG$2],
    ["partial", WRAP_PARTIAL_FLAG$6],
    ["partialRight", WRAP_PARTIAL_RIGHT_FLAG$3],
    ["rearg", WRAP_REARG_FLAG$3]
  ];
  function updateWrapDetails(details, bitmask) {
    arrayEach(wrapFlags, function(pair) {
      var value = "_." + pair[0];
      if (bitmask & pair[1] && !arrayIncludes(details, value)) {
        details.push(value);
      }
    });
    return details.sort();
  }

  function setWrapToString(wrapper, reference, bitmask) {
    var source = reference + "";
    return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
  }

  var WRAP_BIND_FLAG$6 = 1;
  var WRAP_BIND_KEY_FLAG$5 = 2;
  var WRAP_CURRY_BOUND_FLAG$1 = 4;
  var WRAP_CURRY_FLAG$5 = 8;
  var WRAP_PARTIAL_FLAG$5 = 32;
  var WRAP_PARTIAL_RIGHT_FLAG$2 = 64;
  function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
    var isCurry = bitmask & WRAP_CURRY_FLAG$5, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
    bitmask |= isCurry ? WRAP_PARTIAL_FLAG$5 : WRAP_PARTIAL_RIGHT_FLAG$2;
    bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$2 : WRAP_PARTIAL_FLAG$5);
    if (!(bitmask & WRAP_CURRY_BOUND_FLAG$1)) {
      bitmask &= ~(WRAP_BIND_FLAG$6 | WRAP_BIND_KEY_FLAG$5);
    }
    var newData = [
      func,
      bitmask,
      thisArg,
      newPartials,
      newHolders,
      newPartialsRight,
      newHoldersRight,
      argPos,
      ary,
      arity
    ];
    var result = wrapFunc.apply(void 0, newData);
    if (isLaziable(func)) {
      setData(result, newData);
    }
    result.placeholder = placeholder;
    return setWrapToString(result, func, bitmask);
  }

  function getHolder(func) {
    var object = func;
    return object.placeholder;
  }

  var MAX_SAFE_INTEGER$5 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$5 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }

  var nativeMin$e = Math.min;
  function reorder(array, indexes) {
    var arrLength = array.length, length = nativeMin$e(indexes.length, arrLength), oldArray = copyArray(array);
    while (length--) {
      var index = indexes[length];
      array[length] = isIndex(index, arrLength) ? oldArray[index] : void 0;
    }
    return array;
  }

  var PLACEHOLDER$1 = "__lodash_placeholder__";
  function replaceHolders(array, placeholder) {
    var index = -1, length = array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER$1) {
        array[index] = PLACEHOLDER$1;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  var WRAP_BIND_FLAG$5 = 1;
  var WRAP_BIND_KEY_FLAG$4 = 2;
  var WRAP_CURRY_FLAG$4 = 8;
  var WRAP_CURRY_RIGHT_FLAG$2 = 16;
  var WRAP_ARY_FLAG$3 = 128;
  var WRAP_FLIP_FLAG$1 = 512;
  function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
    var isAry = bitmask & WRAP_ARY_FLAG$3, isBind = bitmask & WRAP_BIND_FLAG$5, isBindKey = bitmask & WRAP_BIND_KEY_FLAG$4, isCurried = bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2), isFlip = bitmask & WRAP_FLIP_FLAG$1, Ctor = isBindKey ? void 0 : createCtor(func);
    function wrapper() {
      var length = arguments.length, args = Array(length), index = length;
      while (index--) {
        args[index] = arguments[index];
      }
      if (isCurried) {
        var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
      }
      if (partials) {
        args = composeArgs(args, partials, holders, isCurried);
      }
      if (partialsRight) {
        args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
      }
      length -= holdersCount;
      if (isCurried && length < arity) {
        var newHolders = replaceHolders(args, placeholder);
        return createRecurry(
          func,
          bitmask,
          createHybrid,
          wrapper.placeholder,
          thisArg,
          args,
          newHolders,
          argPos,
          ary,
          arity - length
        );
      }
      var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
      length = args.length;
      if (argPos) {
        args = reorder(args, argPos);
      } else if (isFlip && length > 1) {
        args.reverse();
      }
      if (isAry && ary < length) {
        args.length = ary;
      }
      if (this && this !== root && this instanceof wrapper) {
        fn = Ctor || createCtor(fn);
      }
      return fn.apply(thisBinding, args);
    }
    return wrapper;
  }

  function createCurry(func, bitmask, arity) {
    var Ctor = createCtor(func);
    function wrapper() {
      var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
      while (index--) {
        args[index] = arguments[index];
      }
      var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
      length -= holders.length;
      if (length < arity) {
        return createRecurry(
          func,
          bitmask,
          createHybrid,
          wrapper.placeholder,
          void 0,
          args,
          holders,
          void 0,
          void 0,
          arity - length
        );
      }
      var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
      return apply(fn, this, args);
    }
    return wrapper;
  }

  var WRAP_BIND_FLAG$4 = 1;
  function createPartial(func, bitmask, thisArg, partials) {
    var isBind = bitmask & WRAP_BIND_FLAG$4, Ctor = createCtor(func);
    function wrapper() {
      var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
      while (++leftIndex < leftLength) {
        args[leftIndex] = partials[leftIndex];
      }
      while (argsLength--) {
        args[leftIndex++] = arguments[++argsIndex];
      }
      return apply(fn, isBind ? thisArg : this, args);
    }
    return wrapper;
  }

  var PLACEHOLDER = "__lodash_placeholder__";
  var WRAP_BIND_FLAG$3 = 1;
  var WRAP_BIND_KEY_FLAG$3 = 2;
  var WRAP_CURRY_BOUND_FLAG = 4;
  var WRAP_CURRY_FLAG$3 = 8;
  var WRAP_ARY_FLAG$2 = 128;
  var WRAP_REARG_FLAG$2 = 256;
  var nativeMin$d = Math.min;
  function mergeData(data, source) {
    var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG$3 | WRAP_BIND_KEY_FLAG$3 | WRAP_ARY_FLAG$2);
    var isCombo = srcBitmask == WRAP_ARY_FLAG$2 && bitmask == WRAP_CURRY_FLAG$3 || srcBitmask == WRAP_ARY_FLAG$2 && bitmask == WRAP_REARG_FLAG$2 && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG$3;
    if (!(isCommon || isCombo)) {
      return data;
    }
    if (srcBitmask & WRAP_BIND_FLAG$3) {
      data[2] = source[2];
      newBitmask |= bitmask & WRAP_BIND_FLAG$3 ? 0 : WRAP_CURRY_BOUND_FLAG;
    }
    var value = source[3];
    if (value) {
      var partials = data[3];
      data[3] = partials ? composeArgs(partials, value, source[4]) : value;
      data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
    }
    value = source[5];
    if (value) {
      partials = data[5];
      data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
      data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
    }
    value = source[7];
    if (value) {
      data[7] = value;
    }
    if (srcBitmask & WRAP_ARY_FLAG$2) {
      data[8] = data[8] == null ? source[8] : nativeMin$d(data[8], source[8]);
    }
    if (data[9] == null) {
      data[9] = source[9];
    }
    data[0] = source[0];
    data[1] = newBitmask;
    return data;
  }

  var FUNC_ERROR_TEXT$a = "Expected a function";
  var WRAP_BIND_FLAG$2 = 1;
  var WRAP_BIND_KEY_FLAG$2 = 2;
  var WRAP_CURRY_FLAG$2 = 8;
  var WRAP_CURRY_RIGHT_FLAG$1 = 16;
  var WRAP_PARTIAL_FLAG$4 = 32;
  var WRAP_PARTIAL_RIGHT_FLAG$1 = 64;
  var nativeMax$e = Math.max;
  function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
    var isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2;
    if (!isBindKey && typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$a);
    }
    var length = partials ? partials.length : 0;
    if (!length) {
      bitmask &= ~(WRAP_PARTIAL_FLAG$4 | WRAP_PARTIAL_RIGHT_FLAG$1);
      partials = holders = void 0;
    }
    ary = ary === void 0 ? ary : nativeMax$e(toInteger(ary), 0);
    arity = arity === void 0 ? arity : toInteger(arity);
    length -= holders ? holders.length : 0;
    if (bitmask & WRAP_PARTIAL_RIGHT_FLAG$1) {
      var partialsRight = partials, holdersRight = holders;
      partials = holders = void 0;
    }
    var data = isBindKey ? void 0 : getData(func);
    var newData = [
      func,
      bitmask,
      thisArg,
      partials,
      holders,
      partialsRight,
      holdersRight,
      argPos,
      ary,
      arity
    ];
    if (data) {
      mergeData(newData, data);
    }
    func = newData[0];
    bitmask = newData[1];
    thisArg = newData[2];
    partials = newData[3];
    holders = newData[4];
    arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax$e(newData[9] - length, 0);
    if (!arity && bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1)) {
      bitmask &= ~(WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1);
    }
    if (!bitmask || bitmask == WRAP_BIND_FLAG$2) {
      var result = createBind(func, bitmask, thisArg);
    } else if (bitmask == WRAP_CURRY_FLAG$2 || bitmask == WRAP_CURRY_RIGHT_FLAG$1) {
      result = createCurry(func, bitmask, arity);
    } else if ((bitmask == WRAP_PARTIAL_FLAG$4 || bitmask == (WRAP_BIND_FLAG$2 | WRAP_PARTIAL_FLAG$4)) && !holders.length) {
      result = createPartial(func, bitmask, thisArg, partials);
    } else {
      result = createHybrid.apply(void 0, newData);
    }
    var setter = data ? baseSetData : setData;
    return setWrapToString(setter(result, newData), func, bitmask);
  }

  var WRAP_ARY_FLAG$1 = 128;
  function ary(func, n, guard) {
    n = guard ? void 0 : n;
    n = func && n == null ? func.length : n;
    return createWrap(func, WRAP_ARY_FLAG$1, void 0, void 0, void 0, void 0, n);
  }

  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }

  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  var objectProto$n = Object.prototype;
  var hasOwnProperty$l = objectProto$n.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$l.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }

  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  var nativeMax$d = Math.max;
  function overRest(func, start, transform) {
    start = nativeMax$d(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax$d(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }

  function baseRest(func, start) {
    return setToString(overRest(func, start, identity$1), func + "");
  }

  var MAX_SAFE_INTEGER$4 = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$4;
  }

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction$1(value);
  }

  function isIterateeCall(value, index, object) {
    if (!isObject$1(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
      return eq(object[index], value);
    }
    return false;
  }

  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  var objectProto$m = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$m;
    return value === proto;
  }

  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  var argsTag$3 = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$3;
  }

  var objectProto$l = Object.prototype;
  var hasOwnProperty$k = objectProto$l.hasOwnProperty;
  var propertyIsEnumerable$1 = objectProto$l.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$k.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
  };

  function stubFalse() {
    return false;
  }

  var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
  var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
  var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse;

  var argsTag$2 = "[object Arguments]";
  var arrayTag$2 = "[object Array]";
  var boolTag$4 = "[object Boolean]";
  var dateTag$4 = "[object Date]";
  var errorTag$3 = "[object Error]";
  var funcTag$1 = "[object Function]";
  var mapTag$9 = "[object Map]";
  var numberTag$4 = "[object Number]";
  var objectTag$4 = "[object Object]";
  var regexpTag$4 = "[object RegExp]";
  var setTag$9 = "[object Set]";
  var stringTag$4 = "[object String]";
  var weakMapTag$3 = "[object WeakMap]";
  var arrayBufferTag$4 = "[object ArrayBuffer]";
  var dataViewTag$4 = "[object DataView]";
  var float32Tag$2 = "[object Float32Array]";
  var float64Tag$2 = "[object Float64Array]";
  var int8Tag$2 = "[object Int8Array]";
  var int16Tag$2 = "[object Int16Array]";
  var int32Tag$2 = "[object Int32Array]";
  var uint8Tag$2 = "[object Uint8Array]";
  var uint8ClampedTag$2 = "[object Uint8ClampedArray]";
  var uint16Tag$2 = "[object Uint16Array]";
  var uint32Tag$2 = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
  typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$4] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$4] = typedArrayTags[errorTag$3] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$9] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$4] = typedArrayTags[setTag$9] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$3] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
  var freeProcess = moduleExports$1 && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();

  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  var objectProto$k = Object.prototype;
  var hasOwnProperty$j = objectProto$k.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty$j.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }

  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  var nativeKeys = overArg(Object.keys, Object);

  var objectProto$j = Object.prototype;
  var hasOwnProperty$i = objectProto$j.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$i.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }

  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  var objectProto$i = Object.prototype;
  var hasOwnProperty$h = objectProto$i.hasOwnProperty;
  var assign = createAssigner(function(object, source) {
    if (isPrototype(source) || isArrayLike(source)) {
      copyObject(source, keys(source), object);
      return;
    }
    for (var key in source) {
      if (hasOwnProperty$h.call(source, key)) {
        assignValue(object, key, source[key]);
      }
    }
  });

  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  var objectProto$h = Object.prototype;
  var hasOwnProperty$g = objectProto$h.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject$1(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty$g.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  var assignIn = createAssigner(function(object, source) {
    copyObject(source, keysIn(source), object);
  });

  var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object, customizer);
  });

  var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
    copyObject(source, keys(source), object, customizer);
  });

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray$1(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  var nativeCreate = getNative(Object, "create");

  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
  var objectProto$g = Object.prototype;
  var hasOwnProperty$f = objectProto$g.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED$2 ? void 0 : result;
    }
    return hasOwnProperty$f.call(data, key) ? data[key] : void 0;
  }

  var objectProto$f = Object.prototype;
  var hasOwnProperty$e = objectProto$f.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty$e.call(data, key);
  }

  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
    return this;
  }

  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  var arrayProto$5 = Array.prototype;
  var splice$2 = arrayProto$5.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice$2.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }

  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  var Map$1 = getNative(root, "Map");

  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$1 || ListCache)(),
      "string": new Hash()
    };
  }

  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }

  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }

  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  var FUNC_ERROR_TEXT$9 = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$9);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;

  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }

  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });

  function toString(value) {
    return value == null ? "" : baseToString(value);
  }

  function castPath(value, object) {
    if (isArray$1(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }

  var INFINITY$3 = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
  }

  function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : void 0;
  }

  function get(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet(object, path);
    return result === void 0 ? defaultValue : result;
  }

  function baseAt(object, paths) {
    var index = -1, length = paths.length, result = Array(length), skip = object == null;
    while (++index < length) {
      result[index] = skip ? void 0 : get(object, paths[index]);
    }
    return result;
  }

  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray$1(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }

  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }

  function flatRest(func) {
    return setToString(overRest(func, void 0, flatten), func + "");
  }

  var at = flatRest(baseAt);

  var getPrototype = overArg(Object.getPrototypeOf, Object);

  var objectTag$3 = "[object Object]";
  var funcProto = Function.prototype;
  var objectProto$e = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$d = objectProto$e.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$d.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }

  var domExcTag = "[object DOMException]";
  var errorTag$2 = "[object Error]";
  function isError(value) {
    if (!isObjectLike(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == errorTag$2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
  }

  var attempt = baseRest(function(func, args) {
    try {
      return apply(func, void 0, args);
    } catch (e) {
      return isError(e) ? e : new Error(e);
    }
  });

  var FUNC_ERROR_TEXT$8 = "Expected a function";
  function before(n, func) {
    var result;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$8);
    }
    n = toInteger(n);
    return function() {
      if (--n > 0) {
        result = func.apply(this, arguments);
      }
      if (n <= 1) {
        func = void 0;
      }
      return result;
    };
  }

  var WRAP_BIND_FLAG$1 = 1;
  var WRAP_PARTIAL_FLAG$3 = 32;
  var bind = baseRest(function(func, thisArg, partials) {
    var bitmask = WRAP_BIND_FLAG$1;
    if (partials.length) {
      var holders = replaceHolders(partials, getHolder(bind));
      bitmask |= WRAP_PARTIAL_FLAG$3;
    }
    return createWrap(func, bitmask, thisArg, partials, holders);
  });
  bind.placeholder = {};

  var bindAll = flatRest(function(object, methodNames) {
    arrayEach(methodNames, function(key) {
      key = toKey(key);
      baseAssignValue(object, key, bind(object[key], object));
    });
    return object;
  });

  var WRAP_BIND_FLAG = 1;
  var WRAP_BIND_KEY_FLAG$1 = 2;
  var WRAP_PARTIAL_FLAG$2 = 32;
  var bindKey = baseRest(function(object, key, partials) {
    var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG$1;
    if (partials.length) {
      var holders = replaceHolders(partials, getHolder(bindKey));
      bitmask |= WRAP_PARTIAL_FLAG$2;
    }
    return createWrap(key, bitmask, object, partials, holders);
  });
  bindKey.placeholder = {};

  function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  function castSlice(array, start, end) {
    var length = array.length;
    end = end === void 0 ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }

  var rsAstralRange$3 = "\\ud800-\\udfff";
  var rsComboMarksRange$4 = "\\u0300-\\u036f";
  var reComboHalfMarksRange$4 = "\\ufe20-\\ufe2f";
  var rsComboSymbolsRange$4 = "\\u20d0-\\u20ff";
  var rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4;
  var rsVarRange$3 = "\\ufe0e\\ufe0f";
  var rsZWJ$3 = "\\u200d";
  var reHasUnicode = RegExp("[" + rsZWJ$3 + rsAstralRange$3 + rsComboRange$4 + rsVarRange$3 + "]");
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  function asciiToArray(string) {
    return string.split("");
  }

  var rsAstralRange$2 = "\\ud800-\\udfff";
  var rsComboMarksRange$3 = "\\u0300-\\u036f";
  var reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f";
  var rsComboSymbolsRange$3 = "\\u20d0-\\u20ff";
  var rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
  var rsVarRange$2 = "\\ufe0e\\ufe0f";
  var rsAstral$1 = "[" + rsAstralRange$2 + "]";
  var rsCombo$3 = "[" + rsComboRange$3 + "]";
  var rsFitz$2 = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier$2 = "(?:" + rsCombo$3 + "|" + rsFitz$2 + ")";
  var rsNonAstral$2 = "[^" + rsAstralRange$2 + "]";
  var rsRegional$2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair$2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsZWJ$2 = "\\u200d";
  var reOptMod$2 = rsModifier$2 + "?";
  var rsOptVar$2 = "[" + rsVarRange$2 + "]?";
  var rsOptJoin$2 = "(?:" + rsZWJ$2 + "(?:" + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join("|") + ")" + rsOptVar$2 + reOptMod$2 + ")*";
  var rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2;
  var rsSymbol$1 = "(?:" + [rsNonAstral$2 + rsCombo$3 + "?", rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join("|") + ")";
  var reUnicode$1 = RegExp(rsFitz$2 + "(?=" + rsFitz$2 + ")|" + rsSymbol$1 + rsSeq$2, "g");
  function unicodeToArray(string) {
    return string.match(reUnicode$1) || [];
  }

  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }

  function createCaseFirst(methodName) {
    return function(string) {
      string = toString(string);
      var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
      var chr = strSymbols ? strSymbols[0] : string.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
      return chr[methodName]() + trailing;
    };
  }

  var upperFirst = createCaseFirst("toUpperCase");

  function capitalize(string) {
    return upperFirst(toString(string).toLowerCase());
  }

  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  function basePropertyOf(object) {
    return function(key) {
      return object == null ? void 0 : object[key];
    };
  }

  var deburredLetters = {
    "\xC0": "A",
    "\xC1": "A",
    "\xC2": "A",
    "\xC3": "A",
    "\xC4": "A",
    "\xC5": "A",
    "\xE0": "a",
    "\xE1": "a",
    "\xE2": "a",
    "\xE3": "a",
    "\xE4": "a",
    "\xE5": "a",
    "\xC7": "C",
    "\xE7": "c",
    "\xD0": "D",
    "\xF0": "d",
    "\xC8": "E",
    "\xC9": "E",
    "\xCA": "E",
    "\xCB": "E",
    "\xE8": "e",
    "\xE9": "e",
    "\xEA": "e",
    "\xEB": "e",
    "\xCC": "I",
    "\xCD": "I",
    "\xCE": "I",
    "\xCF": "I",
    "\xEC": "i",
    "\xED": "i",
    "\xEE": "i",
    "\xEF": "i",
    "\xD1": "N",
    "\xF1": "n",
    "\xD2": "O",
    "\xD3": "O",
    "\xD4": "O",
    "\xD5": "O",
    "\xD6": "O",
    "\xD8": "O",
    "\xF2": "o",
    "\xF3": "o",
    "\xF4": "o",
    "\xF5": "o",
    "\xF6": "o",
    "\xF8": "o",
    "\xD9": "U",
    "\xDA": "U",
    "\xDB": "U",
    "\xDC": "U",
    "\xF9": "u",
    "\xFA": "u",
    "\xFB": "u",
    "\xFC": "u",
    "\xDD": "Y",
    "\xFD": "y",
    "\xFF": "y",
    "\xC6": "Ae",
    "\xE6": "ae",
    "\xDE": "Th",
    "\xFE": "th",
    "\xDF": "ss",
    "\u0100": "A",
    "\u0102": "A",
    "\u0104": "A",
    "\u0101": "a",
    "\u0103": "a",
    "\u0105": "a",
    "\u0106": "C",
    "\u0108": "C",
    "\u010A": "C",
    "\u010C": "C",
    "\u0107": "c",
    "\u0109": "c",
    "\u010B": "c",
    "\u010D": "c",
    "\u010E": "D",
    "\u0110": "D",
    "\u010F": "d",
    "\u0111": "d",
    "\u0112": "E",
    "\u0114": "E",
    "\u0116": "E",
    "\u0118": "E",
    "\u011A": "E",
    "\u0113": "e",
    "\u0115": "e",
    "\u0117": "e",
    "\u0119": "e",
    "\u011B": "e",
    "\u011C": "G",
    "\u011E": "G",
    "\u0120": "G",
    "\u0122": "G",
    "\u011D": "g",
    "\u011F": "g",
    "\u0121": "g",
    "\u0123": "g",
    "\u0124": "H",
    "\u0126": "H",
    "\u0125": "h",
    "\u0127": "h",
    "\u0128": "I",
    "\u012A": "I",
    "\u012C": "I",
    "\u012E": "I",
    "\u0130": "I",
    "\u0129": "i",
    "\u012B": "i",
    "\u012D": "i",
    "\u012F": "i",
    "\u0131": "i",
    "\u0134": "J",
    "\u0135": "j",
    "\u0136": "K",
    "\u0137": "k",
    "\u0138": "k",
    "\u0139": "L",
    "\u013B": "L",
    "\u013D": "L",
    "\u013F": "L",
    "\u0141": "L",
    "\u013A": "l",
    "\u013C": "l",
    "\u013E": "l",
    "\u0140": "l",
    "\u0142": "l",
    "\u0143": "N",
    "\u0145": "N",
    "\u0147": "N",
    "\u014A": "N",
    "\u0144": "n",
    "\u0146": "n",
    "\u0148": "n",
    "\u014B": "n",
    "\u014C": "O",
    "\u014E": "O",
    "\u0150": "O",
    "\u014D": "o",
    "\u014F": "o",
    "\u0151": "o",
    "\u0154": "R",
    "\u0156": "R",
    "\u0158": "R",
    "\u0155": "r",
    "\u0157": "r",
    "\u0159": "r",
    "\u015A": "S",
    "\u015C": "S",
    "\u015E": "S",
    "\u0160": "S",
    "\u015B": "s",
    "\u015D": "s",
    "\u015F": "s",
    "\u0161": "s",
    "\u0162": "T",
    "\u0164": "T",
    "\u0166": "T",
    "\u0163": "t",
    "\u0165": "t",
    "\u0167": "t",
    "\u0168": "U",
    "\u016A": "U",
    "\u016C": "U",
    "\u016E": "U",
    "\u0170": "U",
    "\u0172": "U",
    "\u0169": "u",
    "\u016B": "u",
    "\u016D": "u",
    "\u016F": "u",
    "\u0171": "u",
    "\u0173": "u",
    "\u0174": "W",
    "\u0175": "w",
    "\u0176": "Y",
    "\u0177": "y",
    "\u0178": "Y",
    "\u0179": "Z",
    "\u017B": "Z",
    "\u017D": "Z",
    "\u017A": "z",
    "\u017C": "z",
    "\u017E": "z",
    "\u0132": "IJ",
    "\u0133": "ij",
    "\u0152": "Oe",
    "\u0153": "oe",
    "\u0149": "'n",
    "\u017F": "s"
  };
  var deburrLetter = basePropertyOf(deburredLetters);

  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsComboMarksRange$2 = "\\u0300-\\u036f";
  var reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f";
  var rsComboSymbolsRange$2 = "\\u20d0-\\u20ff";
  var rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
  var rsCombo$2 = "[" + rsComboRange$2 + "]";
  var reComboMark = RegExp(rsCombo$2, "g");
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  }

  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  var rsAstralRange$1 = "\\ud800-\\udfff";
  var rsComboMarksRange$1 = "\\u0300-\\u036f";
  var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
  var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
  var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
  var rsDingbatRange = "\\u2700-\\u27bf";
  var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
  var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
  var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
  var rsPunctuationRange = "\\u2000-\\u206f";
  var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
  var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
  var rsVarRange$1 = "\\ufe0e\\ufe0f";
  var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos$1 = "['\u2019]";
  var rsBreak = "[" + rsBreakRange + "]";
  var rsCombo$1 = "[" + rsComboRange$1 + "]";
  var rsDigits = "\\d+";
  var rsDingbat = "[" + rsDingbatRange + "]";
  var rsLower = "[" + rsLowerRange + "]";
  var rsMisc = "[^" + rsAstralRange$1 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
  var rsFitz$1 = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")";
  var rsNonAstral$1 = "[^" + rsAstralRange$1 + "]";
  var rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsUpper = "[" + rsUpperRange + "]";
  var rsZWJ$1 = "\\u200d";
  var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
  var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
  var rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?";
  var rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?";
  var reOptMod$1 = rsModifier$1 + "?";
  var rsOptVar$1 = "[" + rsVarRange$1 + "]?";
  var rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*";
  var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
  var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
  var rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1;
  var rsEmoji = "(?:" + [rsDingbat, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsSeq$1;
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
    rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
    rsUpper + "+" + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? void 0 : pattern;
    if (pattern === void 0) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }

  var rsApos = "['\u2019]";
  var reApos = RegExp(rsApos, "g");
  function createCompounder(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  }

  var camelCase = createCompounder(function(result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
  });

  function castArray() {
    if (!arguments.length) {
      return [];
    }
    var value = arguments[0];
    return isArray$1(value) ? value : [value];
  }

  var nativeIsFinite$1 = root.isFinite;
  var nativeMin$c = Math.min;
  function createRound(methodName) {
    var func = Math[methodName];
    return function(number, precision) {
      number = toNumber(number);
      precision = precision == null ? 0 : nativeMin$c(toInteger(precision), 292);
      if (precision && nativeIsFinite$1(number)) {
        var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
        pair = (toString(value) + "e").split("e");
        return +(pair[0] + "e" + (+pair[1] - precision));
      }
      return func(number);
    };
  }

  var ceil = createRound("ceil");

  function chain(value) {
    var result = lodash(value);
    result.__chain__ = true;
    return result;
  }

  var nativeCeil$3 = Math.ceil;
  var nativeMax$c = Math.max;
  function chunk(array, size, guard) {
    if (guard ? isIterateeCall(array, size, guard) : size === void 0) {
      size = 1;
    } else {
      size = nativeMax$c(toInteger(size), 0);
    }
    var length = array == null ? 0 : array.length;
    if (!length || size < 1) {
      return [];
    }
    var index = 0, resIndex = 0, result = Array(nativeCeil$3(length / size));
    while (index < length) {
      result[resIndex++] = baseSlice(array, index, index += size);
    }
    return result;
  }

  function baseClamp(number, lower, upper) {
    if (number === number) {
      if (upper !== void 0) {
        number = number <= upper ? number : upper;
      }
      if (lower !== void 0) {
        number = number >= lower ? number : lower;
      }
    }
    return number;
  }

  function clamp$1(number, lower, upper) {
    if (upper === void 0) {
      upper = lower;
      lower = void 0;
    }
    if (upper !== void 0) {
      upper = toNumber(upper);
      upper = upper === upper ? upper : 0;
    }
    if (lower !== void 0) {
      lower = toNumber(lower);
      lower = lower === lower ? lower : 0;
    }
    return baseClamp(toNumber(number), lower, upper);
  }

  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }

  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }

  function stackGet(key) {
    return this.__data__.get(key);
  }

  function stackHas(key) {
    return this.__data__.has(key);
  }

  var LARGE_ARRAY_SIZE$2 = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }

  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root.Buffer : void 0;
  var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }

  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  function stubArray() {
    return [];
  }

  var objectProto$d = Object.prototype;
  var propertyIsEnumerable = objectProto$d.propertyIsEnumerable;
  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };

  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };

  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }

  var DataView = getNative(root, "DataView");

  var Promise$1 = getNative(root, "Promise");

  var Set$1 = getNative(root, "Set");

  var mapTag$8 = "[object Map]";
  var objectTag$2 = "[object Object]";
  var promiseTag = "[object Promise]";
  var setTag$8 = "[object Set]";
  var weakMapTag$2 = "[object WeakMap]";
  var dataViewTag$3 = "[object DataView]";
  var dataViewCtorString = toSource(DataView);
  var mapCtorString = toSource(Map$1);
  var promiseCtorString = toSource(Promise$1);
  var setCtorString = toSource(Set$1);
  var weakMapCtorString = toSource(WeakMap);
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$8 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$8 || WeakMap && getTag(new WeakMap()) != weakMapTag$2) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$3;
          case mapCtorString:
            return mapTag$8;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag$8;
          case weakMapCtorString:
            return weakMapTag$2;
        }
      }
      return result;
    };
  }
  var getTag$1 = getTag;

  var objectProto$c = Object.prototype;
  var hasOwnProperty$c = objectProto$c.hasOwnProperty;
  function initCloneArray(array) {
    var length = array.length, result = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty$c.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  var Uint8Array = root.Uint8Array;

  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  var reFlags$1 = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags$1.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0;
  var symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
  }

  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  var boolTag$3 = "[object Boolean]";
  var dateTag$3 = "[object Date]";
  var mapTag$7 = "[object Map]";
  var numberTag$3 = "[object Number]";
  var regexpTag$3 = "[object RegExp]";
  var setTag$7 = "[object Set]";
  var stringTag$3 = "[object String]";
  var symbolTag$2 = "[object Symbol]";
  var arrayBufferTag$3 = "[object ArrayBuffer]";
  var dataViewTag$2 = "[object DataView]";
  var float32Tag$1 = "[object Float32Array]";
  var float64Tag$1 = "[object Float64Array]";
  var int8Tag$1 = "[object Int8Array]";
  var int16Tag$1 = "[object Int16Array]";
  var int32Tag$1 = "[object Int32Array]";
  var uint8Tag$1 = "[object Uint8Array]";
  var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
  var uint16Tag$1 = "[object Uint16Array]";
  var uint32Tag$1 = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag$3:
        return cloneArrayBuffer(object);
      case boolTag$3:
      case dateTag$3:
        return new Ctor(+object);
      case dataViewTag$2:
        return cloneDataView(object, isDeep);
      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return cloneTypedArray(object, isDeep);
      case mapTag$7:
        return new Ctor();
      case numberTag$3:
      case stringTag$3:
        return new Ctor(object);
      case regexpTag$3:
        return cloneRegExp(object);
      case setTag$7:
        return new Ctor();
      case symbolTag$2:
        return cloneSymbol(object);
    }
  }

  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }

  var mapTag$6 = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike(value) && getTag$1(value) == mapTag$6;
  }

  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

  var setTag$6 = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike(value) && getTag$1(value) == setTag$6;
  }

  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

  var CLONE_DEEP_FLAG$7 = 1;
  var CLONE_FLAT_FLAG$1 = 2;
  var CLONE_SYMBOLS_FLAG$5 = 4;
  var argsTag$1 = "[object Arguments]";
  var arrayTag$1 = "[object Array]";
  var boolTag$2 = "[object Boolean]";
  var dateTag$2 = "[object Date]";
  var errorTag$1 = "[object Error]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var mapTag$5 = "[object Map]";
  var numberTag$2 = "[object Number]";
  var objectTag$1 = "[object Object]";
  var regexpTag$2 = "[object RegExp]";
  var setTag$5 = "[object Set]";
  var stringTag$2 = "[object String]";
  var symbolTag$1 = "[object Symbol]";
  var weakMapTag$1 = "[object WeakMap]";
  var arrayBufferTag$2 = "[object ArrayBuffer]";
  var dataViewTag$1 = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$5] = cloneableTags[numberTag$2] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$2] = cloneableTags[setTag$5] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag$1] = false;
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG$7, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$5;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject$1(value)) {
      return value;
    }
    var isArr = isArray$1(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key2) {
        result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
    return result;
  }

  var CLONE_SYMBOLS_FLAG$4 = 4;
  function clone(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG$4);
  }

  var CLONE_DEEP_FLAG$6 = 1;
  var CLONE_SYMBOLS_FLAG$3 = 4;
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG$6 | CLONE_SYMBOLS_FLAG$3);
  }

  var CLONE_DEEP_FLAG$5 = 1;
  var CLONE_SYMBOLS_FLAG$2 = 4;
  function cloneDeepWith(value, customizer) {
    customizer = typeof customizer == "function" ? customizer : void 0;
    return baseClone(value, CLONE_DEEP_FLAG$5 | CLONE_SYMBOLS_FLAG$2, customizer);
  }

  var CLONE_SYMBOLS_FLAG$1 = 4;
  function cloneWith(value, customizer) {
    customizer = typeof customizer == "function" ? customizer : void 0;
    return baseClone(value, CLONE_SYMBOLS_FLAG$1, customizer);
  }

  function wrapperCommit() {
    return new LodashWrapper(this.value(), this.__chain__);
  }

  function compact(array) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (value) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  function concat() {
    var length = arguments.length;
    if (!length) {
      return [];
    }
    var args = Array(length - 1), array = arguments[0], index = length;
    while (index--) {
      args[index - 1] = arguments[index];
    }
    return arrayPush(isArray$1(array) ? copyArray(array) : [array], baseFlatten(args, 1));
  }

  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }

  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;

  function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var COMPARE_PARTIAL_FLAG$5 = 1;
  var COMPARE_UNORDERED_FLAG$3 = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }

  function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  var COMPARE_PARTIAL_FLAG$4 = 1;
  var COMPARE_UNORDERED_FLAG$2 = 2;
  var boolTag$1 = "[object Boolean]";
  var dateTag$1 = "[object Date]";
  var errorTag = "[object Error]";
  var mapTag$4 = "[object Map]";
  var numberTag$1 = "[object Number]";
  var regexpTag$1 = "[object RegExp]";
  var setTag$4 = "[object Set]";
  var stringTag$1 = "[object String]";
  var symbolTag = "[object Symbol]";
  var arrayBufferTag$1 = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag$1:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;
      case boolTag$1:
      case dateTag$1:
      case numberTag$1:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag$1:
      case stringTag$1:
        return object == other + "";
      case mapTag$4:
        var convert = mapToArray;
      case setTag$4:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$2;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  var COMPARE_PARTIAL_FLAG$3 = 1;
  var objectProto$b = Object.prototype;
  var hasOwnProperty$b = objectProto$b.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$b.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }

  var COMPARE_PARTIAL_FLAG$2 = 1;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var objectTag = "[object Object]";
  var objectProto$a = Object.prototype;
  var hasOwnProperty$a = objectProto$a.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray$1(object), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty$a.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$a.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var COMPARE_PARTIAL_FLAG$1 = 1;
  var COMPARE_UNORDERED_FLAG$1 = 2;
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0], objValue = object[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === void 0 && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }

  function isStrictComparable(value) {
    return value === value && !isObject$1(value);
  }

  function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
      var key = result[length], value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }

  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
    };
  }

  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }

  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1, length = path.length, result = false;
    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments(object));
  }

  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }

  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }

  function baseProperty(key) {
    return function(object) {
      return object == null ? void 0 : object[key];
    };
  }

  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }

  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }

  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity$1;
    }
    if (typeof value == "object") {
      return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }

  var FUNC_ERROR_TEXT$7 = "Expected a function";
  function cond(pairs) {
    var length = pairs == null ? 0 : pairs.length, toIteratee = baseIteratee;
    pairs = !length ? [] : arrayMap(pairs, function(pair) {
      if (typeof pair[1] != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$7);
      }
      return [toIteratee(pair[0]), pair[1]];
    });
    return baseRest(function(args) {
      var index = -1;
      while (++index < length) {
        var pair = pairs[index];
        if (apply(pair[0], this, args)) {
          return apply(pair[1], this, args);
        }
      }
    });
  }

  function baseConformsTo(object, source, props) {
    var length = props.length;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (length--) {
      var key = props[length], predicate = source[key], value = object[key];
      if (value === void 0 && !(key in object) || !predicate(value)) {
        return false;
      }
    }
    return true;
  }

  function baseConforms(source) {
    var props = keys(source);
    return function(object) {
      return baseConformsTo(object, source, props);
    };
  }

  var CLONE_DEEP_FLAG$4 = 1;
  function conforms(source) {
    return baseConforms(baseClone(source, CLONE_DEEP_FLAG$4));
  }

  function conformsTo(object, source) {
    return source == null || baseConformsTo(object, source, keys(source));
  }

  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  var baseFor = createBaseFor();

  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }

  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  var baseEach = createBaseEach(baseForOwn);

  function baseAggregator(collection, setter, iteratee, accumulator) {
    baseEach(collection, function(value, key, collection2) {
      setter(accumulator, value, iteratee(value), collection2);
    });
    return accumulator;
  }

  function createAggregator(setter, initializer) {
    return function(collection, iteratee) {
      var func = isArray$1(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
      return func(collection, setter, baseIteratee(iteratee), accumulator);
    };
  }

  var objectProto$9 = Object.prototype;
  var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
  var countBy = createAggregator(function(result, value, key) {
    if (hasOwnProperty$9.call(result, key)) {
      ++result[key];
    } else {
      baseAssignValue(result, key, 1);
    }
  });

  function create(prototype, properties) {
    var result = baseCreate(prototype);
    return properties == null ? result : baseAssign(result, properties);
  }

  var WRAP_CURRY_FLAG$1 = 8;
  function curry(func, arity, guard) {
    arity = guard ? void 0 : arity;
    var result = createWrap(func, WRAP_CURRY_FLAG$1, void 0, void 0, void 0, void 0, void 0, arity);
    result.placeholder = curry.placeholder;
    return result;
  }
  curry.placeholder = {};

  var WRAP_CURRY_RIGHT_FLAG = 16;
  function curryRight(func, arity, guard) {
    arity = guard ? void 0 : arity;
    var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, void 0, void 0, void 0, void 0, void 0, arity);
    result.placeholder = curryRight.placeholder;
    return result;
  }
  curryRight.placeholder = {};

  var now = function() {
    return root.Date.now();
  };

  var FUNC_ERROR_TEXT$6 = "Expected a function";
  var nativeMax$b = Math.max;
  var nativeMin$b = Math.min;
  function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$6);
    }
    wait = toNumber(wait) || 0;
    if (isObject$1(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax$b(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin$b(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  function defaultTo(value, defaultValue) {
    return value == null || value !== value ? defaultValue : value;
  }

  var objectProto$8 = Object.prototype;
  var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
  var defaults = baseRest(function(object, sources) {
    object = Object(object);
    var index = -1;
    var length = sources.length;
    var guard = length > 2 ? sources[2] : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      var props = keysIn(source);
      var propsIndex = -1;
      var propsLength = props.length;
      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object[key];
        if (value === void 0 || eq(value, objectProto$8[key]) && !hasOwnProperty$8.call(object, key)) {
          object[key] = source[key];
        }
      }
    }
    return object;
  });

  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }

  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }

  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }

  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray$1(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject$1(objValue) || isFunction$1(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }

  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack || (stack = new Stack());
      if (isObject$1(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }

  function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
    if (isObject$1(objValue) && isObject$1(srcValue)) {
      stack.set(srcValue, objValue);
      baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
      stack["delete"](srcValue);
    }
    return objValue;
  }

  var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
    baseMerge(object, source, srcIndex, customizer);
  });

  var defaultsDeep = baseRest(function(args) {
    args.push(void 0, customDefaultsMerge);
    return apply(mergeWith, void 0, args);
  });

  var FUNC_ERROR_TEXT$5 = "Expected a function";
  function baseDelay(func, wait, args) {
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$5);
    }
    return setTimeout(function() {
      func.apply(void 0, args);
    }, wait);
  }

  var defer = baseRest(function(func, args) {
    return baseDelay(func, 1, args);
  });

  var delay = baseRest(function(func, wait, args) {
    return baseDelay(func, toNumber(wait) || 0, args);
  });

  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  var LARGE_ARRAY_SIZE$1 = 200;
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) {
      return result;
    }
    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }
    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE$1) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee == null ? value : iteratee(value);
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
    return result;
  }

  var difference = baseRest(function(array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
  });

  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : void 0;
  }

  var differenceBy = baseRest(function(array, values) {
    var iteratee = last(values);
    if (isArrayLikeObject(iteratee)) {
      iteratee = void 0;
    }
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee)) : [];
  });

  var differenceWith = baseRest(function(array, values) {
    var comparator = last(values);
    if (isArrayLikeObject(comparator)) {
      comparator = void 0;
    }
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), void 0, comparator) : [];
  });

  var divide = createMathOperation(function(dividend, divisor) {
    return dividend / divisor;
  }, 1);

  function drop(array, n, guard) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    n = guard || n === void 0 ? 1 : toInteger(n);
    return baseSlice(array, n < 0 ? 0 : n, length);
  }

  function dropRight(array, n, guard) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    n = guard || n === void 0 ? 1 : toInteger(n);
    n = length - n;
    return baseSlice(array, 0, n < 0 ? 0 : n);
  }

  function baseWhile(array, predicate, isDrop, fromRight) {
    var length = array.length, index = fromRight ? length : -1;
    while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
    }
    return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
  }

  function dropRightWhile(array, predicate) {
    return array && array.length ? baseWhile(array, baseIteratee(predicate), true, true) : [];
  }

  function dropWhile(array, predicate) {
    return array && array.length ? baseWhile(array, baseIteratee(predicate), true) : [];
  }

  function castFunction(value) {
    return typeof value == "function" ? value : identity$1;
  }

  function forEach(collection, iteratee) {
    var func = isArray$1(collection) ? arrayEach : baseEach;
    return func(collection, castFunction(iteratee));
  }

  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;
    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  var baseForRight = createBaseFor(true);

  function baseForOwnRight(object, iteratee) {
    return object && baseForRight(object, iteratee, keys);
  }

  var baseEachRight = createBaseEach(baseForOwnRight, true);

  function forEachRight(collection, iteratee) {
    var func = isArray$1(collection) ? arrayEachRight : baseEachRight;
    return func(collection, castFunction(iteratee));
  }

  function endsWith(string, target, position) {
    string = toString(string);
    target = baseToString(target);
    var length = string.length;
    position = position === void 0 ? length : baseClamp(toInteger(position), 0, length);
    var end = position;
    position -= target.length;
    return position >= 0 && string.slice(position, end) == target;
  }

  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  function setToPairs(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  var mapTag$3 = "[object Map]";
  var setTag$3 = "[object Set]";
  function createToPairs(keysFunc) {
    return function(object) {
      var tag = getTag$1(object);
      if (tag == mapTag$3) {
        return mapToArray(object);
      }
      if (tag == setTag$3) {
        return setToPairs(object);
      }
      return baseToPairs(object, keysFunc(object));
    };
  }

  var toPairs = createToPairs(keys);

  var toPairsIn = createToPairs(keysIn);

  var htmlEscapes = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  var reUnescapedHtml = /[&<>"']/g;
  var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
  function escape(string) {
    string = toString(string);
    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
  }

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reHasRegExpChar = RegExp(reRegExpChar.source);
  function escapeRegExp(string) {
    string = toString(string);
    return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
  }

  function arrayEvery(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  function baseEvery(collection, predicate) {
    var result = true;
    baseEach(collection, function(value, index, collection2) {
      result = !!predicate(value, index, collection2);
      return result;
    });
    return result;
  }

  function every(collection, predicate, guard) {
    var func = isArray$1(collection) ? arrayEvery : baseEvery;
    if (guard && isIterateeCall(collection, predicate, guard)) {
      predicate = void 0;
    }
    return func(collection, baseIteratee(predicate));
  }

  var MAX_ARRAY_LENGTH$5 = 4294967295;
  function toLength(value) {
    return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH$5) : 0;
  }

  function baseFill(array, value, start, end) {
    var length = array.length;
    start = toInteger(start);
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end === void 0 || end > length ? length : toInteger(end);
    if (end < 0) {
      end += length;
    }
    end = start > end ? 0 : toLength(end);
    while (start < end) {
      array[start++] = value;
    }
    return array;
  }

  function fill(array, value, start, end) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
      start = 0;
      end = length;
    }
    return baseFill(array, value, start, end);
  }

  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function(value, index, collection2) {
      if (predicate(value, index, collection2)) {
        result.push(value);
      }
    });
    return result;
  }

  function filter(collection, predicate) {
    var func = isArray$1(collection) ? arrayFilter : baseFilter;
    return func(collection, baseIteratee(predicate));
  }

  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = baseIteratee(predicate);
        collection = keys(collection);
        predicate = function(key) {
          return iteratee(iterable[key], key, iterable);
        };
      }
      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
    };
  }

  var nativeMax$a = Math.max;
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax$a(length + index, 0);
    }
    return baseFindIndex(array, baseIteratee(predicate), index);
  }

  var find = createFind(findIndex);

  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection2) {
      if (predicate(value, key, collection2)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  function findKey(object, predicate) {
    return baseFindKey(object, baseIteratee(predicate), baseForOwn);
  }

  var nativeMax$9 = Math.max;
  var nativeMin$a = Math.min;
  function findLastIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = length - 1;
    if (fromIndex !== void 0) {
      index = toInteger(fromIndex);
      index = fromIndex < 0 ? nativeMax$9(length + index, 0) : nativeMin$a(index, length - 1);
    }
    return baseFindIndex(array, baseIteratee(predicate), index, true);
  }

  var findLast = createFind(findLastIndex);

  function findLastKey(object, predicate) {
    return baseFindKey(object, baseIteratee(predicate), baseForOwnRight);
  }

  function head(array) {
    return array && array.length ? array[0] : void 0;
  }

  function baseMap(collection, iteratee) {
    var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection2) {
      result[++index] = iteratee(value, key, collection2);
    });
    return result;
  }

  function map(collection, iteratee) {
    var func = isArray$1(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee));
  }

  function flatMap(collection, iteratee) {
    return baseFlatten(map(collection, iteratee), 1);
  }

  var INFINITY$2 = 1 / 0;
  function flatMapDeep(collection, iteratee) {
    return baseFlatten(map(collection, iteratee), INFINITY$2);
  }

  function flatMapDepth(collection, iteratee, depth) {
    depth = depth === void 0 ? 1 : toInteger(depth);
    return baseFlatten(map(collection, iteratee), depth);
  }

  var INFINITY$1 = 1 / 0;
  function flattenDeep(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, INFINITY$1) : [];
  }

  function flattenDepth(array, depth) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    depth = depth === void 0 ? 1 : toInteger(depth);
    return baseFlatten(array, depth);
  }

  var WRAP_FLIP_FLAG = 512;
  function flip$2(func) {
    return createWrap(func, WRAP_FLIP_FLAG);
  }

  var floor = createRound("floor");

  var FUNC_ERROR_TEXT$4 = "Expected a function";
  var WRAP_CURRY_FLAG = 8;
  var WRAP_PARTIAL_FLAG$1 = 32;
  var WRAP_ARY_FLAG = 128;
  var WRAP_REARG_FLAG$1 = 256;
  function createFlow(fromRight) {
    return flatRest(function(funcs) {
      var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
      if (fromRight) {
        funcs.reverse();
      }
      while (index--) {
        var func = funcs[index];
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$4);
        }
        if (prereq && !wrapper && getFuncName(func) == "wrapper") {
          var wrapper = new LodashWrapper([], true);
        }
      }
      index = wrapper ? index : length;
      while (++index < length) {
        func = funcs[index];
        var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : void 0;
        if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG$1 | WRAP_REARG_FLAG$1) && !data[4].length && data[9] == 1) {
          wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
        } else {
          wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
        }
      }
      return function() {
        var args = arguments, value = args[0];
        if (wrapper && args.length == 1 && isArray$1(value)) {
          return wrapper.plant(value).value();
        }
        var index2 = 0, result = length ? funcs[index2].apply(this, args) : value;
        while (++index2 < length) {
          result = funcs[index2].call(this, result);
        }
        return result;
      };
    });
  }

  var flow = createFlow();

  var flowRight = createFlow(true);

  function forIn(object, iteratee) {
    return object == null ? object : baseFor(object, castFunction(iteratee), keysIn);
  }

  function forInRight(object, iteratee) {
    return object == null ? object : baseForRight(object, castFunction(iteratee), keysIn);
  }

  function forOwn(object, iteratee) {
    return object && baseForOwn(object, castFunction(iteratee));
  }

  function forOwnRight(object, iteratee) {
    return object && baseForOwnRight(object, castFunction(iteratee));
  }

  function fromPairs(pairs) {
    var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
    while (++index < length) {
      var pair = pairs[index];
      result[pair[0]] = pair[1];
    }
    return result;
  }

  function baseFunctions(object, props) {
    return arrayFilter(props, function(key) {
      return isFunction$1(object[key]);
    });
  }

  function functions(object) {
    return object == null ? [] : baseFunctions(object, keys(object));
  }

  function functionsIn(object) {
    return object == null ? [] : baseFunctions(object, keysIn(object));
  }

  var objectProto$7 = Object.prototype;
  var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
  var groupBy = createAggregator(function(result, value, key) {
    if (hasOwnProperty$7.call(result, key)) {
      result[key].push(value);
    } else {
      baseAssignValue(result, key, [value]);
    }
  });

  function baseGt(value, other) {
    return value > other;
  }

  function createRelationalOperation(operator) {
    return function(value, other) {
      if (!(typeof value == "string" && typeof other == "string")) {
        value = toNumber(value);
        other = toNumber(other);
      }
      return operator(value, other);
    };
  }

  var gt = createRelationalOperation(baseGt);

  var gte = createRelationalOperation(function(value, other) {
    return value >= other;
  });

  var objectProto$6 = Object.prototype;
  var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
  function baseHas(object, key) {
    return object != null && hasOwnProperty$6.call(object, key);
  }

  function has(object, path) {
    return object != null && hasPath(object, path, baseHas);
  }

  var nativeMax$8 = Math.max;
  var nativeMin$9 = Math.min;
  function baseInRange(number, start, end) {
    return number >= nativeMin$9(start, end) && number < nativeMax$8(start, end);
  }

  function inRange(number, start, end) {
    start = toFinite(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    number = toNumber(number);
    return baseInRange(number, start, end);
  }

  var stringTag = "[object String]";
  function isString$2(value) {
    return typeof value == "string" || !isArray$1(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
  }

  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }

  var nativeMax$7 = Math.max;
  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax$7(length + fromIndex, 0);
    }
    return isString$2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
  }

  var nativeMax$6 = Math.max;
  function indexOf(array, value, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax$6(length + index, 0);
    }
    return baseIndexOf(array, value, index);
  }

  function initial(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseSlice(array, 0, -1) : [];
  }

  var nativeMin$8 = Math.min;
  function baseIntersection(arrays, iteratee, comparator) {
    var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
    while (othIndex--) {
      var array = arrays[othIndex];
      if (othIndex && iteratee) {
        array = arrayMap(array, baseUnary(iteratee));
      }
      maxLength = nativeMin$8(array.length, maxLength);
      caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : void 0;
    }
    array = arrays[0];
    var index = -1, seen = caches[0];
    outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }

  function castArrayLikeObject(value) {
    return isArrayLikeObject(value) ? value : [];
  }

  var intersection = baseRest(function(arrays) {
    var mapped = arrayMap(arrays, castArrayLikeObject);
    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
  });

  var intersectionBy = baseRest(function(arrays) {
    var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
    if (iteratee === last(mapped)) {
      iteratee = void 0;
    } else {
      mapped.pop();
    }
    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, baseIteratee(iteratee)) : [];
  });

  var intersectionWith = baseRest(function(arrays) {
    var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
    comparator = typeof comparator == "function" ? comparator : void 0;
    if (comparator) {
      mapped.pop();
    }
    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, void 0, comparator) : [];
  });

  function baseInverter(object, setter, iteratee, accumulator) {
    baseForOwn(object, function(value, key, object2) {
      setter(accumulator, iteratee(value), key, object2);
    });
    return accumulator;
  }

  function createInverter(setter, toIteratee) {
    return function(object, iteratee) {
      return baseInverter(object, setter, toIteratee(iteratee), {});
    };
  }

  var objectProto$5 = Object.prototype;
  var nativeObjectToString$1 = objectProto$5.toString;
  var invert = createInverter(function(result, value, key) {
    if (value != null && typeof value.toString != "function") {
      value = nativeObjectToString$1.call(value);
    }
    result[value] = key;
  }, constant(identity$1));

  var objectProto$4 = Object.prototype;
  var hasOwnProperty$5 = objectProto$4.hasOwnProperty;
  var nativeObjectToString = objectProto$4.toString;
  var invertBy = createInverter(function(result, value, key) {
    if (value != null && typeof value.toString != "function") {
      value = nativeObjectToString.call(value);
    }
    if (hasOwnProperty$5.call(result, value)) {
      result[value].push(key);
    } else {
      result[value] = [key];
    }
  }, baseIteratee);

  function parent(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
  }

  function baseInvoke(object, path, args) {
    path = castPath(path, object);
    object = parent(object, path);
    var func = object == null ? object : object[toKey(last(path))];
    return func == null ? void 0 : apply(func, object, args);
  }

  var invoke = baseRest(baseInvoke);

  var invokeMap = baseRest(function(collection, path, args) {
    var index = -1, isFunc = typeof path == "function", result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value) {
      result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
    });
    return result;
  });

  var arrayBufferTag = "[object ArrayBuffer]";
  function baseIsArrayBuffer(value) {
    return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
  }

  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer;
  var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

  var boolTag = "[object Boolean]";
  function isBoolean$1(value) {
    return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
  }

  var dateTag = "[object Date]";
  function baseIsDate(value) {
    return isObjectLike(value) && baseGetTag(value) == dateTag;
  }

  var nodeIsDate = nodeUtil && nodeUtil.isDate;
  var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

  function isElement$3(value) {
    return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
  }

  var mapTag$2 = "[object Map]";
  var setTag$2 = "[object Set]";
  var objectProto$3 = Object.prototype;
  var hasOwnProperty$4 = objectProto$3.hasOwnProperty;
  function isEmpty$1(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike(value) && (isArray$1(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
      return !value.length;
    }
    var tag = getTag$1(value);
    if (tag == mapTag$2 || tag == setTag$2) {
      return !value.size;
    }
    if (isPrototype(value)) {
      return !baseKeys(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty$4.call(value, key)) {
        return false;
      }
    }
    return true;
  }

  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }

  function isEqualWith(value, other, customizer) {
    customizer = typeof customizer == "function" ? customizer : void 0;
    var result = customizer ? customizer(value, other) : void 0;
    return result === void 0 ? baseIsEqual(value, other, void 0, customizer) : !!result;
  }

  var nativeIsFinite = root.isFinite;
  function isFinite(value) {
    return typeof value == "number" && nativeIsFinite(value);
  }

  function isInteger(value) {
    return typeof value == "number" && value == toInteger(value);
  }

  function isMatch(object, source) {
    return object === source || baseIsMatch(object, source, getMatchData(source));
  }

  function isMatchWith(object, source, customizer) {
    customizer = typeof customizer == "function" ? customizer : void 0;
    return baseIsMatch(object, source, getMatchData(source), customizer);
  }

  var numberTag = "[object Number]";
  function isNumber$1(value) {
    return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
  }

  function isNaN(value) {
    return isNumber$1(value) && value != +value;
  }

  var isMaskable = coreJsData ? isFunction$1 : stubFalse;

  var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
  function isNative(value) {
    if (isMaskable(value)) {
      throw new Error(CORE_ERROR_TEXT);
    }
    return baseIsNative(value);
  }

  function isNil(value) {
    return value == null;
  }

  function isNull(value) {
    return value === null;
  }

  var regexpTag = "[object RegExp]";
  function baseIsRegExp(value) {
    return isObjectLike(value) && baseGetTag(value) == regexpTag;
  }

  var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
  var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

  var MAX_SAFE_INTEGER$3 = 9007199254740991;
  function isSafeInteger(value) {
    return isInteger(value) && value >= -MAX_SAFE_INTEGER$3 && value <= MAX_SAFE_INTEGER$3;
  }

  function isUndefined$1(value) {
    return value === void 0;
  }

  var weakMapTag = "[object WeakMap]";
  function isWeakMap(value) {
    return isObjectLike(value) && getTag$1(value) == weakMapTag;
  }

  var weakSetTag = "[object WeakSet]";
  function isWeakSet(value) {
    return isObjectLike(value) && baseGetTag(value) == weakSetTag;
  }

  var CLONE_DEEP_FLAG$3 = 1;
  function iteratee(func) {
    return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG$3));
  }

  var arrayProto$4 = Array.prototype;
  var nativeJoin = arrayProto$4.join;
  function join(array, separator) {
    return array == null ? "" : nativeJoin.call(array, separator);
  }

  var kebabCase = createCompounder(function(result, word, index) {
    return result + (index ? "-" : "") + word.toLowerCase();
  });

  var keyBy = createAggregator(function(result, value, key) {
    baseAssignValue(result, key, value);
  });

  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  var nativeMax$5 = Math.max;
  var nativeMin$7 = Math.min;
  function lastIndexOf(array, value, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = length;
    if (fromIndex !== void 0) {
      index = toInteger(fromIndex);
      index = index < 0 ? nativeMax$5(length + index, 0) : nativeMin$7(index, length - 1);
    }
    return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
  }

  var lowerCase = createCompounder(function(result, word, index) {
    return result + (index ? " " : "") + word.toLowerCase();
  });

  var lowerFirst = createCaseFirst("toLowerCase");

  function baseLt(value, other) {
    return value < other;
  }

  var lt = createRelationalOperation(baseLt);

  var lte = createRelationalOperation(function(value, other) {
    return value <= other;
  });

  function mapKeys(object, iteratee) {
    var result = {};
    iteratee = baseIteratee(iteratee);
    baseForOwn(object, function(value, key, object2) {
      baseAssignValue(result, iteratee(value, key, object2), value);
    });
    return result;
  }

  function mapValues(object, iteratee) {
    var result = {};
    iteratee = baseIteratee(iteratee);
    baseForOwn(object, function(value, key, object2) {
      baseAssignValue(result, key, iteratee(value, key, object2));
    });
    return result;
  }

  var CLONE_DEEP_FLAG$2 = 1;
  function matches(source) {
    return baseMatches(baseClone(source, CLONE_DEEP_FLAG$2));
  }

  var CLONE_DEEP_FLAG$1 = 1;
  function matchesProperty(path, srcValue) {
    return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG$1));
  }

  function baseExtremum(array, iteratee, comparator) {
    var index = -1, length = array.length;
    while (++index < length) {
      var value = array[index], current = iteratee(value);
      if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
        var computed = current, result = value;
      }
    }
    return result;
  }

  function max$1(array) {
    return array && array.length ? baseExtremum(array, identity$1, baseGt) : void 0;
  }

  function maxBy(array, iteratee) {
    return array && array.length ? baseExtremum(array, baseIteratee(iteratee), baseGt) : void 0;
  }

  function baseSum(array, iteratee) {
    var result, index = -1, length = array.length;
    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== void 0) {
        result = result === void 0 ? current : result + current;
      }
    }
    return result;
  }

  var NAN = 0 / 0;
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? baseSum(array, iteratee) / length : NAN;
  }

  function mean(array) {
    return baseMean(array, identity$1);
  }

  function meanBy(array, iteratee) {
    return baseMean(array, baseIteratee(iteratee));
  }

  var merge = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });

  var method = baseRest(function(path, args) {
    return function(object) {
      return baseInvoke(object, path, args);
    };
  });

  var methodOf = baseRest(function(object, args) {
    return function(path) {
      return baseInvoke(object, path, args);
    };
  });

  function min$1(array) {
    return array && array.length ? baseExtremum(array, identity$1, baseLt) : void 0;
  }

  function minBy(array, iteratee) {
    return array && array.length ? baseExtremum(array, baseIteratee(iteratee), baseLt) : void 0;
  }

  function mixin$1(object, source, options) {
    var props = keys(source), methodNames = baseFunctions(source, props);
    var chain = !(isObject$1(options) && "chain" in options) || !!options.chain, isFunc = isFunction$1(object);
    arrayEach(methodNames, function(methodName) {
      var func = source[methodName];
      object[methodName] = func;
      if (isFunc) {
        object.prototype[methodName] = function() {
          var chainAll = this.__chain__;
          if (chain || chainAll) {
            var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
            actions.push({ "func": func, "args": arguments, "thisArg": object });
            result.__chain__ = chainAll;
            return result;
          }
          return func.apply(object, arrayPush([this.value()], arguments));
        };
      }
    });
    return object;
  }

  var multiply = createMathOperation(function(multiplier, multiplicand) {
    return multiplier * multiplicand;
  }, 1);

  var FUNC_ERROR_TEXT$3 = "Expected a function";
  function negate(predicate) {
    if (typeof predicate != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$3);
    }
    return function() {
      var args = arguments;
      switch (args.length) {
        case 0:
          return !predicate.call(this);
        case 1:
          return !predicate.call(this, args[0]);
        case 2:
          return !predicate.call(this, args[0], args[1]);
        case 3:
          return !predicate.call(this, args[0], args[1], args[2]);
      }
      return !predicate.apply(this, args);
    };
  }

  function iteratorToArray(iterator) {
    var data, result = [];
    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  var mapTag$1 = "[object Map]";
  var setTag$1 = "[object Set]";
  var symIterator$1 = Symbol$1 ? Symbol$1.iterator : void 0;
  function toArray(value) {
    if (!value) {
      return [];
    }
    if (isArrayLike(value)) {
      return isString$2(value) ? stringToArray(value) : copyArray(value);
    }
    if (symIterator$1 && value[symIterator$1]) {
      return iteratorToArray(value[symIterator$1]());
    }
    var tag = getTag$1(value), func = tag == mapTag$1 ? mapToArray : tag == setTag$1 ? setToArray : values;
    return func(value);
  }

  function wrapperNext() {
    if (this.__values__ === void 0) {
      this.__values__ = toArray(this.value());
    }
    var done = this.__index__ >= this.__values__.length, value = done ? void 0 : this.__values__[this.__index__++];
    return { "done": done, "value": value };
  }

  function baseNth(array, n) {
    var length = array.length;
    if (!length) {
      return;
    }
    n += n < 0 ? length : 0;
    return isIndex(n, length) ? array[n] : void 0;
  }

  function nth(array, n) {
    return array && array.length ? baseNth(array, toInteger(n)) : void 0;
  }

  function nthArg(n) {
    n = toInteger(n);
    return baseRest(function(args) {
      return baseNth(args, n);
    });
  }

  function baseUnset(object, path) {
    path = castPath(path, object);
    object = parent(object, path);
    return object == null || delete object[toKey(last(path))];
  }

  function customOmitClone(value) {
    return isPlainObject(value) ? void 0 : value;
  }

  var CLONE_DEEP_FLAG = 1;
  var CLONE_FLAT_FLAG = 2;
  var CLONE_SYMBOLS_FLAG = 4;
  var omit = flatRest(function(object, paths) {
    var result = {};
    if (object == null) {
      return result;
    }
    var isDeep = false;
    paths = arrayMap(paths, function(path) {
      path = castPath(path, object);
      isDeep || (isDeep = path.length > 1);
      return path;
    });
    copyObject(object, getAllKeysIn(object), result);
    if (isDeep) {
      result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
    }
    var length = paths.length;
    while (length--) {
      baseUnset(result, paths[length]);
    }
    return result;
  });

  function baseSet(object, path, value, customizer) {
    if (!isObject$1(object)) {
      return object;
    }
    path = castPath(path, object);
    var index = -1, length = path.length, lastIndex = length - 1, nested = object;
    while (nested != null && ++index < length) {
      var key = toKey(path[index]), newValue = value;
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        return object;
      }
      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject$1(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }

  function basePickBy(object, paths, predicate) {
    var index = -1, length = paths.length, result = {};
    while (++index < length) {
      var path = paths[index], value = baseGet(object, path);
      if (predicate(value, path)) {
        baseSet(result, castPath(path, object), value);
      }
    }
    return result;
  }

  function pickBy(object, predicate) {
    if (object == null) {
      return {};
    }
    var props = arrayMap(getAllKeysIn(object), function(prop) {
      return [prop];
    });
    predicate = baseIteratee(predicate);
    return basePickBy(object, props, function(value, path) {
      return predicate(value, path[0]);
    });
  }

  function omitBy(object, predicate) {
    return pickBy(object, negate(baseIteratee(predicate)));
  }

  function once(func) {
    return before(2, func);
  }

  function baseSortBy(array, comparer) {
    var length = array.length;
    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
      var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }
      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }

  function compareMultiple(object, other, orders) {
    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
    while (++index < length) {
      var result = compareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * (order == "desc" ? -1 : 1);
      }
    }
    return object.index - other.index;
  }

  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = arrayMap(iteratees, function(iteratee) {
        if (isArray$1(iteratee)) {
          return function(value) {
            return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          };
        }
        return iteratee;
      });
    } else {
      iteratees = [identity$1];
    }
    var index = -1;
    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
    var result = baseMap(collection, function(value, key, collection2) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { "criteria": criteria, "index": ++index, "value": value };
    });
    return baseSortBy(result, function(object, other) {
      return compareMultiple(object, other, orders);
    });
  }

  function orderBy(collection, iteratees, orders, guard) {
    if (collection == null) {
      return [];
    }
    if (!isArray$1(iteratees)) {
      iteratees = iteratees == null ? [] : [iteratees];
    }
    orders = guard ? void 0 : orders;
    if (!isArray$1(orders)) {
      orders = orders == null ? [] : [orders];
    }
    return baseOrderBy(collection, iteratees, orders);
  }

  function createOver(arrayFunc) {
    return flatRest(function(iteratees) {
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      return baseRest(function(args) {
        var thisArg = this;
        return arrayFunc(iteratees, function(iteratee) {
          return apply(iteratee, thisArg, args);
        });
      });
    });
  }

  var over = createOver(arrayMap);

  var castRest = baseRest;

  var nativeMin$6 = Math.min;
  var overArgs = castRest(function(func, transforms) {
    transforms = transforms.length == 1 && isArray$1(transforms[0]) ? arrayMap(transforms[0], baseUnary(baseIteratee)) : arrayMap(baseFlatten(transforms, 1), baseUnary(baseIteratee));
    var funcsLength = transforms.length;
    return baseRest(function(args) {
      var index = -1, length = nativeMin$6(args.length, funcsLength);
      while (++index < length) {
        args[index] = transforms[index].call(this, args[index]);
      }
      return apply(func, this, args);
    });
  });

  var overEvery = createOver(arrayEvery);

  var overSome = createOver(arraySome);

  var MAX_SAFE_INTEGER$2 = 9007199254740991;
  var nativeFloor$3 = Math.floor;
  function baseRepeat(string, n) {
    var result = "";
    if (!string || n < 1 || n > MAX_SAFE_INTEGER$2) {
      return result;
    }
    do {
      if (n % 2) {
        result += string;
      }
      n = nativeFloor$3(n / 2);
      if (n) {
        string += string;
      }
    } while (n);
    return result;
  }

  var asciiSize = baseProperty("length");

  var rsAstralRange = "\\ud800-\\udfff";
  var rsComboMarksRange = "\\u0300-\\u036f";
  var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
  var rsComboSymbolsRange = "\\u20d0-\\u20ff";
  var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
  var rsVarRange = "\\ufe0e\\ufe0f";
  var rsAstral = "[" + rsAstralRange + "]";
  var rsCombo = "[" + rsComboRange + "]";
  var rsFitz = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
  var rsNonAstral = "[^" + rsAstralRange + "]";
  var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsZWJ = "\\u200d";
  var reOptMod = rsModifier + "?";
  var rsOptVar = "[" + rsVarRange + "]?";
  var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
  var rsSeq = rsOptVar + reOptMod + rsOptJoin;
  var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  function stringSize(string) {
    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
  }

  var nativeCeil$2 = Math.ceil;
  function createPadding(length, chars) {
    chars = chars === void 0 ? " " : baseToString(chars);
    var charsLength = chars.length;
    if (charsLength < 2) {
      return charsLength ? baseRepeat(chars, length) : chars;
    }
    var result = baseRepeat(chars, nativeCeil$2(length / stringSize(chars)));
    return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
  }

  var nativeCeil$1 = Math.ceil;
  var nativeFloor$2 = Math.floor;
  function pad(string, length, chars) {
    string = toString(string);
    length = toInteger(length);
    var strLength = length ? stringSize(string) : 0;
    if (!length || strLength >= length) {
      return string;
    }
    var mid = (length - strLength) / 2;
    return createPadding(nativeFloor$2(mid), chars) + string + createPadding(nativeCeil$1(mid), chars);
  }

  function padEnd(string, length, chars) {
    string = toString(string);
    length = toInteger(length);
    var strLength = length ? stringSize(string) : 0;
    return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
  }

  function padStart(string, length, chars) {
    string = toString(string);
    length = toInteger(length);
    var strLength = length ? stringSize(string) : 0;
    return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
  }

  var reTrimStart$1 = /^\s+/;
  var nativeParseInt = root.parseInt;
  function parseInt$1(string, radix, guard) {
    if (guard || radix == null) {
      radix = 0;
    } else if (radix) {
      radix = +radix;
    }
    return nativeParseInt(toString(string).replace(reTrimStart$1, ""), radix || 0);
  }

  var WRAP_PARTIAL_FLAG = 32;
  var partial = baseRest(function(func, partials) {
    var holders = replaceHolders(partials, getHolder(partial));
    return createWrap(func, WRAP_PARTIAL_FLAG, void 0, partials, holders);
  });
  partial.placeholder = {};

  var WRAP_PARTIAL_RIGHT_FLAG = 64;
  var partialRight = baseRest(function(func, partials) {
    var holders = replaceHolders(partials, getHolder(partialRight));
    return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, void 0, partials, holders);
  });
  partialRight.placeholder = {};

  var partition = createAggregator(function(result, value, key) {
    result[key ? 0 : 1].push(value);
  }, function() {
    return [[], []];
  });

  function basePick(object, paths) {
    return basePickBy(object, paths, function(value, path) {
      return hasIn(object, path);
    });
  }

  var pick = flatRest(function(object, paths) {
    return object == null ? {} : basePick(object, paths);
  });

  function wrapperPlant(value) {
    var result, parent = this;
    while (parent instanceof baseLodash) {
      var clone = wrapperClone(parent);
      clone.__index__ = 0;
      clone.__values__ = void 0;
      if (result) {
        previous.__wrapped__ = clone;
      } else {
        result = clone;
      }
      var previous = clone;
      parent = parent.__wrapped__;
    }
    previous.__wrapped__ = value;
    return result;
  }

  function propertyOf(object) {
    return function(path) {
      return object == null ? void 0 : baseGet(object, path);
    };
  }

  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  var arrayProto$3 = Array.prototype;
  var splice$1 = arrayProto$3.splice;
  function basePullAll(array, values, iteratee, comparator) {
    var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
    if (array === values) {
      values = copyArray(values);
    }
    if (iteratee) {
      seen = arrayMap(array, baseUnary(iteratee));
    }
    while (++index < length) {
      var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
      while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
        if (seen !== array) {
          splice$1.call(seen, fromIndex, 1);
        }
        splice$1.call(array, fromIndex, 1);
      }
    }
    return array;
  }

  function pullAll(array, values) {
    return array && array.length && values && values.length ? basePullAll(array, values) : array;
  }

  var pull = baseRest(pullAll);

  function pullAllBy(array, values, iteratee) {
    return array && array.length && values && values.length ? basePullAll(array, values, baseIteratee(iteratee)) : array;
  }

  function pullAllWith(array, values, comparator) {
    return array && array.length && values && values.length ? basePullAll(array, values, void 0, comparator) : array;
  }

  var arrayProto$2 = Array.prototype;
  var splice = arrayProto$2.splice;
  function basePullAt(array, indexes) {
    var length = array ? indexes.length : 0, lastIndex = length - 1;
    while (length--) {
      var index = indexes[length];
      if (length == lastIndex || index !== previous) {
        var previous = index;
        if (isIndex(index)) {
          splice.call(array, index, 1);
        } else {
          baseUnset(array, index);
        }
      }
    }
    return array;
  }

  var pullAt = flatRest(function(array, indexes) {
    var length = array == null ? 0 : array.length, result = baseAt(array, indexes);
    basePullAt(array, arrayMap(indexes, function(index) {
      return isIndex(index, length) ? +index : index;
    }).sort(compareAscending));
    return result;
  });

  var nativeFloor$1 = Math.floor;
  var nativeRandom$1 = Math.random;
  function baseRandom(lower, upper) {
    return lower + nativeFloor$1(nativeRandom$1() * (upper - lower + 1));
  }

  var freeParseFloat = parseFloat;
  var nativeMin$5 = Math.min;
  var nativeRandom = Math.random;
  function random(lower, upper, floating) {
    if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
      upper = floating = void 0;
    }
    if (floating === void 0) {
      if (typeof upper == "boolean") {
        floating = upper;
        upper = void 0;
      } else if (typeof lower == "boolean") {
        floating = lower;
        lower = void 0;
      }
    }
    if (lower === void 0 && upper === void 0) {
      lower = 0;
      upper = 1;
    } else {
      lower = toFinite(lower);
      if (upper === void 0) {
        upper = lower;
        lower = 0;
      } else {
        upper = toFinite(upper);
      }
    }
    if (lower > upper) {
      var temp = lower;
      lower = upper;
      upper = temp;
    }
    if (floating || lower % 1 || upper % 1) {
      var rand = nativeRandom();
      return nativeMin$5(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
    }
    return baseRandom(lower, upper);
  }

  var nativeCeil = Math.ceil;
  var nativeMax$4 = Math.max;
  function baseRange(start, end, step, fromRight) {
    var index = -1, length = nativeMax$4(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
    while (length--) {
      result[fromRight ? length : ++index] = start;
      start += step;
    }
    return result;
  }

  function createRange(fromRight) {
    return function(start, end, step) {
      if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
        end = step = void 0;
      }
      start = toFinite(start);
      if (end === void 0) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
      return baseRange(start, end, step, fromRight);
    };
  }

  var range = createRange();

  var rangeRight = createRange(true);

  var WRAP_REARG_FLAG = 256;
  var rearg = flatRest(function(func, indexes) {
    return createWrap(func, WRAP_REARG_FLAG, void 0, void 0, void 0, indexes);
  });

  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection2) {
      accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
    });
    return accumulator;
  }

  function reduce(collection, iteratee, accumulator) {
    var func = isArray$1(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
    return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEach);
  }

  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  function reduceRight(collection, iteratee, accumulator) {
    var func = isArray$1(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
    return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEachRight);
  }

  function reject(collection, predicate) {
    var func = isArray$1(collection) ? arrayFilter : baseFilter;
    return func(collection, negate(baseIteratee(predicate)));
  }

  function remove(array, predicate) {
    var result = [];
    if (!(array && array.length)) {
      return result;
    }
    var index = -1, indexes = [], length = array.length;
    predicate = baseIteratee(predicate);
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result.push(value);
        indexes.push(index);
      }
    }
    basePullAt(array, indexes);
    return result;
  }

  function repeat(string, n, guard) {
    if (guard ? isIterateeCall(string, n, guard) : n === void 0) {
      n = 1;
    } else {
      n = toInteger(n);
    }
    return baseRepeat(toString(string), n);
  }

  function replace() {
    var args = arguments, string = toString(args[0]);
    return args.length < 3 ? string : string.replace(args[1], args[2]);
  }

  var FUNC_ERROR_TEXT$2 = "Expected a function";
  function rest(func, start) {
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$2);
    }
    start = start === void 0 ? start : toInteger(start);
    return baseRest(func, start);
  }

  function result(object, path, defaultValue) {
    path = castPath(path, object);
    var index = -1, length = path.length;
    if (!length) {
      length = 1;
      object = void 0;
    }
    while (++index < length) {
      var value = object == null ? void 0 : object[toKey(path[index])];
      if (value === void 0) {
        index = length;
        value = defaultValue;
      }
      object = isFunction$1(value) ? value.call(object) : value;
    }
    return object;
  }

  var arrayProto$1 = Array.prototype;
  var nativeReverse = arrayProto$1.reverse;
  function reverse(array) {
    return array == null ? array : nativeReverse.call(array);
  }

  var round$1 = createRound("round");

  function arraySample(array) {
    var length = array.length;
    return length ? array[baseRandom(0, length - 1)] : void 0;
  }

  function baseSample(collection) {
    return arraySample(values(collection));
  }

  function sample(collection) {
    var func = isArray$1(collection) ? arraySample : baseSample;
    return func(collection);
  }

  function shuffleSelf(array, size) {
    var index = -1, length = array.length, lastIndex = length - 1;
    size = size === void 0 ? length : size;
    while (++index < size) {
      var rand = baseRandom(index, lastIndex), value = array[rand];
      array[rand] = array[index];
      array[index] = value;
    }
    array.length = size;
    return array;
  }

  function arraySampleSize(array, n) {
    return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
  }

  function baseSampleSize(collection, n) {
    var array = values(collection);
    return shuffleSelf(array, baseClamp(n, 0, array.length));
  }

  function sampleSize(collection, n, guard) {
    if (guard ? isIterateeCall(collection, n, guard) : n === void 0) {
      n = 1;
    } else {
      n = toInteger(n);
    }
    var func = isArray$1(collection) ? arraySampleSize : baseSampleSize;
    return func(collection, n);
  }

  function set(object, path, value) {
    return object == null ? object : baseSet(object, path, value);
  }

  function setWith(object, path, value, customizer) {
    customizer = typeof customizer == "function" ? customizer : void 0;
    return object == null ? object : baseSet(object, path, value, customizer);
  }

  function arrayShuffle(array) {
    return shuffleSelf(copyArray(array));
  }

  function baseShuffle(collection) {
    return shuffleSelf(values(collection));
  }

  function shuffle(collection) {
    var func = isArray$1(collection) ? arrayShuffle : baseShuffle;
    return func(collection);
  }

  var mapTag = "[object Map]";
  var setTag = "[object Set]";
  function size(collection) {
    if (collection == null) {
      return 0;
    }
    if (isArrayLike(collection)) {
      return isString$2(collection) ? stringSize(collection) : collection.length;
    }
    var tag = getTag$1(collection);
    if (tag == mapTag || tag == setTag) {
      return collection.size;
    }
    return baseKeys(collection).length;
  }

  function slice(array, start, end) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
      start = 0;
      end = length;
    } else {
      start = start == null ? 0 : toInteger(start);
      end = end === void 0 ? length : toInteger(end);
    }
    return baseSlice(array, start, end);
  }

  var snakeCase = createCompounder(function(result, word, index) {
    return result + (index ? "_" : "") + word.toLowerCase();
  });

  function baseSome(collection, predicate) {
    var result;
    baseEach(collection, function(value, index, collection2) {
      result = predicate(value, index, collection2);
      return !result;
    });
    return !!result;
  }

  function some(collection, predicate, guard) {
    var func = isArray$1(collection) ? arraySome : baseSome;
    if (guard && isIterateeCall(collection, predicate, guard)) {
      predicate = void 0;
    }
    return func(collection, baseIteratee(predicate));
  }

  var sortBy = baseRest(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length = iteratees.length;
    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });

  var MAX_ARRAY_LENGTH$4 = 4294967295;
  var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$4 - 1;
  var nativeFloor = Math.floor;
  var nativeMin$4 = Math.min;
  function baseSortedIndexBy(array, value, iteratee, retHighest) {
    var low = 0, high = array == null ? 0 : array.length;
    if (high === 0) {
      return 0;
    }
    value = iteratee(value);
    var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === void 0;
    while (low < high) {
      var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== void 0, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
      if (valIsNaN) {
        var setLow = retHighest || othIsReflexive;
      } else if (valIsUndefined) {
        setLow = othIsReflexive && (retHighest || othIsDefined);
      } else if (valIsNull) {
        setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
      } else if (valIsSymbol) {
        setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
      } else if (othIsNull || othIsSymbol) {
        setLow = false;
      } else {
        setLow = retHighest ? computed <= value : computed < value;
      }
      if (setLow) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return nativeMin$4(high, MAX_ARRAY_INDEX);
  }

  var MAX_ARRAY_LENGTH$3 = 4294967295;
  var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH$3 >>> 1;
  function baseSortedIndex(array, value, retHighest) {
    var low = 0, high = array == null ? low : array.length;
    if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
      while (low < high) {
        var mid = low + high >>> 1, computed = array[mid];
        if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return high;
    }
    return baseSortedIndexBy(array, value, identity$1, retHighest);
  }

  function sortedIndex(array, value) {
    return baseSortedIndex(array, value);
  }

  function sortedIndexBy(array, value, iteratee) {
    return baseSortedIndexBy(array, value, baseIteratee(iteratee));
  }

  function sortedIndexOf(array, value) {
    var length = array == null ? 0 : array.length;
    if (length) {
      var index = baseSortedIndex(array, value);
      if (index < length && eq(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  function sortedLastIndex(array, value) {
    return baseSortedIndex(array, value, true);
  }

  function sortedLastIndexBy(array, value, iteratee) {
    return baseSortedIndexBy(array, value, baseIteratee(iteratee), true);
  }

  function sortedLastIndexOf(array, value) {
    var length = array == null ? 0 : array.length;
    if (length) {
      var index = baseSortedIndex(array, value, true) - 1;
      if (eq(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  function baseSortedUniq(array, iteratee) {
    var index = -1, length = array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index], computed = iteratee ? iteratee(value) : value;
      if (!index || !eq(computed, seen)) {
        var seen = computed;
        result[resIndex++] = value === 0 ? 0 : value;
      }
    }
    return result;
  }

  function sortedUniq(array) {
    return array && array.length ? baseSortedUniq(array) : [];
  }

  function sortedUniqBy(array, iteratee) {
    return array && array.length ? baseSortedUniq(array, baseIteratee(iteratee)) : [];
  }

  var MAX_ARRAY_LENGTH$2 = 4294967295;
  function split(string, separator, limit) {
    if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
      separator = limit = void 0;
    }
    limit = limit === void 0 ? MAX_ARRAY_LENGTH$2 : limit >>> 0;
    if (!limit) {
      return [];
    }
    string = toString(string);
    if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
      separator = baseToString(separator);
      if (!separator && hasUnicode(string)) {
        return castSlice(stringToArray(string), 0, limit);
      }
    }
    return string.split(separator, limit);
  }

  var FUNC_ERROR_TEXT$1 = "Expected a function";
  var nativeMax$3 = Math.max;
  function spread(func, start) {
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    start = start == null ? 0 : nativeMax$3(toInteger(start), 0);
    return baseRest(function(args) {
      var array = args[start], otherArgs = castSlice(args, 0, start);
      if (array) {
        arrayPush(otherArgs, array);
      }
      return apply(func, this, otherArgs);
    });
  }

  var startCase = createCompounder(function(result, word, index) {
    return result + (index ? " " : "") + upperFirst(word);
  });

  function startsWith(string, target, position) {
    string = toString(string);
    position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
    target = baseToString(target);
    return string.slice(position, position + target.length) == target;
  }

  function stubObject() {
    return {};
  }

  function stubString() {
    return "";
  }

  function stubTrue() {
    return true;
  }

  var subtract = createMathOperation(function(minuend, subtrahend) {
    return minuend - subtrahend;
  }, 0);

  function sum(array) {
    return array && array.length ? baseSum(array, identity$1) : 0;
  }

  function sumBy(array, iteratee) {
    return array && array.length ? baseSum(array, baseIteratee(iteratee)) : 0;
  }

  function tail(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseSlice(array, 1, length) : [];
  }

  function take(array, n, guard) {
    if (!(array && array.length)) {
      return [];
    }
    n = guard || n === void 0 ? 1 : toInteger(n);
    return baseSlice(array, 0, n < 0 ? 0 : n);
  }

  function takeRight(array, n, guard) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    n = guard || n === void 0 ? 1 : toInteger(n);
    n = length - n;
    return baseSlice(array, n < 0 ? 0 : n, length);
  }

  function takeRightWhile(array, predicate) {
    return array && array.length ? baseWhile(array, baseIteratee(predicate), false, true) : [];
  }

  function takeWhile(array, predicate) {
    return array && array.length ? baseWhile(array, baseIteratee(predicate)) : [];
  }

  function tap(value, interceptor) {
    interceptor(value);
    return value;
  }

  var objectProto$2 = Object.prototype;
  var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
  function customDefaultsAssignIn(objValue, srcValue, key, object) {
    if (objValue === void 0 || eq(objValue, objectProto$2[key]) && !hasOwnProperty$3.call(object, key)) {
      return srcValue;
    }
    return objValue;
  }

  var stringEscapes = {
    "\\": "\\",
    "'": "'",
    "\n": "n",
    "\r": "r",
    "\u2028": "u2028",
    "\u2029": "u2029"
  };
  function escapeStringChar(chr) {
    return "\\" + stringEscapes[chr];
  }

  var reInterpolate = /<%=([\s\S]+?)%>/g;

  var reEscape = /<%-([\s\S]+?)%>/g;

  var reEvaluate = /<%([\s\S]+?)%>/g;

  var templateSettings = {
    "escape": reEscape,
    "evaluate": reEvaluate,
    "interpolate": reInterpolate,
    "variable": "",
    "imports": {
      "_": { "escape": escape }
    }
  };

  var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
  var reEmptyStringLeading = /\b__p \+= '';/g;
  var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
  var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
  var reNoMatch = /($^)/;
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
  var objectProto$1 = Object.prototype;
  var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
  function template(string, options, guard) {
    var settings = templateSettings.imports._.templateSettings || templateSettings;
    if (guard && isIterateeCall(string, options, guard)) {
      options = void 0;
    }
    string = toString(string);
    options = assignInWith({}, options, settings, customDefaultsAssignIn);
    var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
    var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
    var reDelimiters = RegExp(
      (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
      "g"
    );
    var sourceURL = hasOwnProperty$2.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
    string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
      interpolateValue || (interpolateValue = esTemplateValue);
      source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
      if (escapeValue) {
        isEscaping = true;
        source += "' +\n__e(" + escapeValue + ") +\n'";
      }
      if (evaluateValue) {
        isEvaluating = true;
        source += "';\n" + evaluateValue + ";\n__p += '";
      }
      if (interpolateValue) {
        source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";
    var variable = hasOwnProperty$2.call(options, "variable") && options.variable;
    if (!variable) {
      source = "with (obj) {\n" + source + "\n}\n";
    } else if (reForbiddenIdentifierChars.test(variable)) {
      throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
    }
    source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
    source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
    var result = attempt(function() {
      return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
    });
    result.source = source;
    if (isError(result)) {
      throw result;
    }
    return result;
  }

  var FUNC_ERROR_TEXT = "Expected a function";
  function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject$1(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      "leading": leading,
      "maxWait": wait,
      "trailing": trailing
    });
  }

  function thru(value, interceptor) {
    return interceptor(value);
  }

  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  var MAX_ARRAY_LENGTH$1 = 4294967295;
  var nativeMin$3 = Math.min;
  function times(n, iteratee) {
    n = toInteger(n);
    if (n < 1 || n > MAX_SAFE_INTEGER$1) {
      return [];
    }
    var index = MAX_ARRAY_LENGTH$1, length = nativeMin$3(n, MAX_ARRAY_LENGTH$1);
    iteratee = castFunction(iteratee);
    n -= MAX_ARRAY_LENGTH$1;
    var result = baseTimes(length, iteratee);
    while (++index < n) {
      iteratee(index);
    }
    return result;
  }

  function wrapperToIterator() {
    return this;
  }

  function baseWrapperValue(value, actions) {
    var result = value;
    if (result instanceof LazyWrapper) {
      result = result.value();
    }
    return arrayReduce(actions, function(result2, action) {
      return action.func.apply(action.thisArg, arrayPush([result2], action.args));
    }, result);
  }

  function wrapperValue() {
    return baseWrapperValue(this.__wrapped__, this.__actions__);
  }

  function toLower(value) {
    return toString(value).toLowerCase();
  }

  function toPath(value) {
    if (isArray$1(value)) {
      return arrayMap(value, toKey);
    }
    return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
  }

  var MAX_SAFE_INTEGER = 9007199254740991;
  function toSafeInteger(value) {
    return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
  }

  function toUpper(value) {
    return toString(value).toUpperCase();
  }

  function transform(object, iteratee, accumulator) {
    var isArr = isArray$1(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
    iteratee = baseIteratee(iteratee);
    if (accumulator == null) {
      var Ctor = object && object.constructor;
      if (isArrLike) {
        accumulator = isArr ? new Ctor() : [];
      } else if (isObject$1(object)) {
        accumulator = isFunction$1(Ctor) ? baseCreate(getPrototype(object)) : {};
      } else {
        accumulator = {};
      }
    }
    (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
      return iteratee(accumulator, value, index, object2);
    });
    return accumulator;
  }

  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;
    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
    }
    return index;
  }

  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1, length = strSymbols.length;
    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
    }
    return index;
  }

  function trim(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === void 0)) {
      return baseTrim(string);
    }
    if (!string || !(chars = baseToString(chars))) {
      return string;
    }
    var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
    return castSlice(strSymbols, start, end).join("");
  }

  function trimEnd(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === void 0)) {
      return string.slice(0, trimmedEndIndex(string) + 1);
    }
    if (!string || !(chars = baseToString(chars))) {
      return string;
    }
    var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
    return castSlice(strSymbols, 0, end).join("");
  }

  var reTrimStart = /^\s+/;
  function trimStart(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === void 0)) {
      return string.replace(reTrimStart, "");
    }
    if (!string || !(chars = baseToString(chars))) {
      return string;
    }
    var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
    return castSlice(strSymbols, start).join("");
  }

  var DEFAULT_TRUNC_LENGTH = 30;
  var DEFAULT_TRUNC_OMISSION = "...";
  var reFlags = /\w*$/;
  function truncate(string, options) {
    var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
    if (isObject$1(options)) {
      var separator = "separator" in options ? options.separator : separator;
      length = "length" in options ? toInteger(options.length) : length;
      omission = "omission" in options ? baseToString(options.omission) : omission;
    }
    string = toString(string);
    var strLength = string.length;
    if (hasUnicode(string)) {
      var strSymbols = stringToArray(string);
      strLength = strSymbols.length;
    }
    if (length >= strLength) {
      return string;
    }
    var end = length - stringSize(omission);
    if (end < 1) {
      return omission;
    }
    var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
    if (separator === void 0) {
      return result + omission;
    }
    if (strSymbols) {
      end += result.length - end;
    }
    if (isRegExp(separator)) {
      if (string.slice(end).search(separator)) {
        var match, substring = result;
        if (!separator.global) {
          separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g");
        }
        separator.lastIndex = 0;
        while (match = separator.exec(substring)) {
          var newEnd = match.index;
        }
        result = result.slice(0, newEnd === void 0 ? end : newEnd);
      }
    } else if (string.indexOf(baseToString(separator), end) != end) {
      var index = result.lastIndexOf(separator);
      if (index > -1) {
        result = result.slice(0, index);
      }
    }
    return result + omission;
  }

  function unary(func) {
    return ary(func, 1);
  }

  var htmlUnescapes = {
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&#39;": "'"
  };
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
  var reHasEscapedHtml = RegExp(reEscapedHtml.source);
  function unescape(string) {
    string = toString(string);
    return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
  }

  var INFINITY = 1 / 0;
  var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY) ? noop$1 : function(values) {
    return new Set$1(values);
  };

  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }

  var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  });

  var unionBy = baseRest(function(arrays) {
    var iteratee = last(arrays);
    if (isArrayLikeObject(iteratee)) {
      iteratee = void 0;
    }
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee));
  });

  var unionWith = baseRest(function(arrays) {
    var comparator = last(arrays);
    comparator = typeof comparator == "function" ? comparator : void 0;
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), void 0, comparator);
  });

  function uniq(array) {
    return array && array.length ? baseUniq(array) : [];
  }

  function uniqBy(array, iteratee) {
    return array && array.length ? baseUniq(array, baseIteratee(iteratee)) : [];
  }

  function uniqWith(array, comparator) {
    comparator = typeof comparator == "function" ? comparator : void 0;
    return array && array.length ? baseUniq(array, void 0, comparator) : [];
  }

  var idCounter = 0;
  function uniqueId(prefix) {
    var id = ++idCounter;
    return toString(prefix) + id;
  }

  function unset(object, path) {
    return object == null ? true : baseUnset(object, path);
  }

  var nativeMax$2 = Math.max;
  function unzip(array) {
    if (!(array && array.length)) {
      return [];
    }
    var length = 0;
    array = arrayFilter(array, function(group) {
      if (isArrayLikeObject(group)) {
        length = nativeMax$2(group.length, length);
        return true;
      }
    });
    return baseTimes(length, function(index) {
      return arrayMap(array, baseProperty(index));
    });
  }

  function unzipWith(array, iteratee) {
    if (!(array && array.length)) {
      return [];
    }
    var result = unzip(array);
    if (iteratee == null) {
      return result;
    }
    return arrayMap(result, function(group) {
      return apply(iteratee, void 0, group);
    });
  }

  function baseUpdate(object, path, updater, customizer) {
    return baseSet(object, path, updater(baseGet(object, path)), customizer);
  }

  function update(object, path, updater) {
    return object == null ? object : baseUpdate(object, path, castFunction(updater));
  }

  function updateWith(object, path, updater, customizer) {
    customizer = typeof customizer == "function" ? customizer : void 0;
    return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
  }

  var upperCase = createCompounder(function(result, word, index) {
    return result + (index ? " " : "") + word.toUpperCase();
  });

  function valuesIn(object) {
    return object == null ? [] : baseValues(object, keysIn(object));
  }

  var without = baseRest(function(array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, values) : [];
  });

  function wrap(value, wrapper) {
    return partial(castFunction(wrapper), value);
  }

  var wrapperAt = flatRest(function(paths) {
    var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
      return baseAt(object, paths);
    };
    if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
      return this.thru(interceptor);
    }
    value = value.slice(start, +start + (length ? 1 : 0));
    value.__actions__.push({
      "func": thru,
      "args": [interceptor],
      "thisArg": void 0
    });
    return new LodashWrapper(value, this.__chain__).thru(function(array) {
      if (length && !array.length) {
        array.push(void 0);
      }
      return array;
    });
  });

  function wrapperChain() {
    return chain(this);
  }

  function wrapperReverse() {
    var value = this.__wrapped__;
    if (value instanceof LazyWrapper) {
      var wrapped = value;
      if (this.__actions__.length) {
        wrapped = new LazyWrapper(this);
      }
      wrapped = wrapped.reverse();
      wrapped.__actions__.push({
        "func": thru,
        "args": [reverse],
        "thisArg": void 0
      });
      return new LodashWrapper(wrapped, this.__chain__);
    }
    return this.thru(reverse);
  }

  function baseXor(arrays, iteratee, comparator) {
    var length = arrays.length;
    if (length < 2) {
      return length ? baseUniq(arrays[0]) : [];
    }
    var index = -1, result = Array(length);
    while (++index < length) {
      var array = arrays[index], othIndex = -1;
      while (++othIndex < length) {
        if (othIndex != index) {
          result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
        }
      }
    }
    return baseUniq(baseFlatten(result, 1), iteratee, comparator);
  }

  var xor = baseRest(function(arrays) {
    return baseXor(arrayFilter(arrays, isArrayLikeObject));
  });

  var xorBy = baseRest(function(arrays) {
    var iteratee = last(arrays);
    if (isArrayLikeObject(iteratee)) {
      iteratee = void 0;
    }
    return baseXor(arrayFilter(arrays, isArrayLikeObject), baseIteratee(iteratee));
  });

  var xorWith = baseRest(function(arrays) {
    var comparator = last(arrays);
    comparator = typeof comparator == "function" ? comparator : void 0;
    return baseXor(arrayFilter(arrays, isArrayLikeObject), void 0, comparator);
  });

  var zip = baseRest(unzip);

  function baseZipObject(props, values, assignFunc) {
    var index = -1, length = props.length, valsLength = values.length, result = {};
    while (++index < length) {
      var value = index < valsLength ? values[index] : void 0;
      assignFunc(result, props[index], value);
    }
    return result;
  }

  function zipObject(props, values) {
    return baseZipObject(props || [], values || [], assignValue);
  }

  function zipObjectDeep(props, values) {
    return baseZipObject(props || [], values || [], baseSet);
  }

  var zipWith = baseRest(function(arrays) {
    var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : void 0;
    iteratee = typeof iteratee == "function" ? (arrays.pop(), iteratee) : void 0;
    return unzipWith(arrays, iteratee);
  });

  var array = {
    chunk,
    compact,
    concat,
    difference,
    differenceBy,
    differenceWith,
    drop,
    dropRight,
    dropRightWhile,
    dropWhile,
    fill,
    findIndex,
    findLastIndex,
    first: head,
    flatten,
    flattenDeep,
    flattenDepth,
    fromPairs,
    head,
    indexOf,
    initial,
    intersection,
    intersectionBy,
    intersectionWith,
    join,
    last,
    lastIndexOf,
    nth,
    pull,
    pullAll,
    pullAllBy,
    pullAllWith,
    pullAt,
    remove,
    reverse,
    slice,
    sortedIndex,
    sortedIndexBy,
    sortedIndexOf,
    sortedLastIndex,
    sortedLastIndexBy,
    sortedLastIndexOf,
    sortedUniq,
    sortedUniqBy,
    tail,
    take,
    takeRight,
    takeRightWhile,
    takeWhile,
    union,
    unionBy,
    unionWith,
    uniq,
    uniqBy,
    uniqWith,
    unzip,
    unzipWith,
    without,
    xor,
    xorBy,
    xorWith,
    zip,
    zipObject,
    zipObjectDeep,
    zipWith
  };

  var collection = {
    countBy,
    each: forEach,
    eachRight: forEachRight,
    every,
    filter,
    find,
    findLast,
    flatMap,
    flatMapDeep,
    flatMapDepth,
    forEach,
    forEachRight,
    groupBy,
    includes,
    invokeMap,
    keyBy,
    map,
    orderBy,
    partition,
    reduce,
    reduceRight,
    reject,
    sample,
    sampleSize,
    shuffle,
    size,
    some,
    sortBy
  };

  var date = {
    now
  };

  var func = {
    after,
    ary,
    before,
    bind,
    bindKey,
    curry,
    curryRight,
    debounce,
    defer,
    delay,
    flip: flip$2,
    memoize,
    negate,
    once,
    overArgs,
    partial,
    partialRight,
    rearg,
    rest,
    spread,
    throttle,
    unary,
    wrap
  };

  var lang = {
    castArray,
    clone,
    cloneDeep,
    cloneDeepWith,
    cloneWith,
    conformsTo,
    eq,
    gt,
    gte,
    isArguments,
    isArray: isArray$1,
    isArrayBuffer,
    isArrayLike,
    isArrayLikeObject,
    isBoolean: isBoolean$1,
    isBuffer,
    isDate,
    isElement: isElement$3,
    isEmpty: isEmpty$1,
    isEqual,
    isEqualWith,
    isError,
    isFinite,
    isFunction: isFunction$1,
    isInteger,
    isLength,
    isMap,
    isMatch,
    isMatchWith,
    isNaN,
    isNative,
    isNil,
    isNull,
    isNumber: isNumber$1,
    isObject: isObject$1,
    isObjectLike,
    isPlainObject,
    isRegExp,
    isSafeInteger,
    isSet,
    isString: isString$2,
    isSymbol,
    isTypedArray,
    isUndefined: isUndefined$1,
    isWeakMap,
    isWeakSet,
    lt,
    lte,
    toArray,
    toFinite,
    toInteger,
    toLength,
    toNumber,
    toPlainObject,
    toSafeInteger,
    toString
  };

  var math = {
    add,
    ceil,
    divide,
    floor,
    max: max$1,
    maxBy,
    mean,
    meanBy,
    min: min$1,
    minBy,
    multiply,
    round: round$1,
    subtract,
    sum,
    sumBy
  };

  var number = {
    clamp: clamp$1,
    inRange,
    random
  };

  var object = {
    assign,
    assignIn,
    assignInWith,
    assignWith,
    at,
    create,
    defaults,
    defaultsDeep,
    entries: toPairs,
    entriesIn: toPairsIn,
    extend: assignIn,
    extendWith: assignInWith,
    findKey,
    findLastKey,
    forIn,
    forInRight,
    forOwn,
    forOwnRight,
    functions,
    functionsIn,
    get,
    has,
    hasIn,
    invert,
    invertBy,
    invoke,
    keys,
    keysIn,
    mapKeys,
    mapValues,
    merge,
    mergeWith,
    omit,
    omitBy,
    pick,
    pickBy,
    result,
    set,
    setWith,
    toPairs,
    toPairsIn,
    transform,
    unset,
    update,
    updateWith,
    values,
    valuesIn
  };

  var seq = {
    at: wrapperAt,
    chain,
    commit: wrapperCommit,
    lodash,
    next: wrapperNext,
    plant: wrapperPlant,
    reverse: wrapperReverse,
    tap,
    thru,
    toIterator: wrapperToIterator,
    toJSON: wrapperValue,
    value: wrapperValue,
    valueOf: wrapperValue,
    wrapperChain
  };

  var string = {
    camelCase,
    capitalize,
    deburr,
    endsWith,
    escape,
    escapeRegExp,
    kebabCase,
    lowerCase,
    lowerFirst,
    pad,
    padEnd,
    padStart,
    parseInt: parseInt$1,
    repeat,
    replace,
    snakeCase,
    split,
    startCase,
    startsWith,
    template,
    templateSettings,
    toLower,
    toUpper,
    trim,
    trimEnd,
    trimStart,
    truncate,
    unescape,
    upperCase,
    upperFirst,
    words
  };

  var util = {
    attempt,
    bindAll,
    cond,
    conforms,
    constant,
    defaultTo,
    flow,
    flowRight,
    identity: identity$1,
    iteratee,
    matches,
    matchesProperty,
    method,
    methodOf,
    mixin: mixin$1,
    noop: noop$1,
    nthArg,
    over,
    overEvery,
    overSome,
    property,
    propertyOf,
    range,
    rangeRight,
    stubArray,
    stubFalse,
    stubObject,
    stubString,
    stubTrue,
    times,
    toPath,
    uniqueId
  };

  function lazyClone() {
    var result = new LazyWrapper(this.__wrapped__);
    result.__actions__ = copyArray(this.__actions__);
    result.__dir__ = this.__dir__;
    result.__filtered__ = this.__filtered__;
    result.__iteratees__ = copyArray(this.__iteratees__);
    result.__takeCount__ = this.__takeCount__;
    result.__views__ = copyArray(this.__views__);
    return result;
  }

  function lazyReverse() {
    if (this.__filtered__) {
      var result = new LazyWrapper(this);
      result.__dir__ = -1;
      result.__filtered__ = true;
    } else {
      result = this.clone();
      result.__dir__ *= -1;
    }
    return result;
  }

  var nativeMax$1 = Math.max;
  var nativeMin$2 = Math.min;
  function getView(start, end, transforms) {
    var index = -1, length = transforms.length;
    while (++index < length) {
      var data = transforms[index], size = data.size;
      switch (data.type) {
        case "drop":
          start += size;
          break;
        case "dropRight":
          end -= size;
          break;
        case "take":
          end = nativeMin$2(end, start + size);
          break;
        case "takeRight":
          start = nativeMax$1(start, end - size);
          break;
      }
    }
    return { "start": start, "end": end };
  }

  var LAZY_FILTER_FLAG$1 = 1;
  var LAZY_MAP_FLAG = 2;
  var nativeMin$1 = Math.min;
  function lazyValue() {
    var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray$1(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin$1(length, this.__takeCount__);
    if (!isArr || !isRight && arrLength == length && takeCount == length) {
      return baseWrapperValue(array, this.__actions__);
    }
    var result = [];
    outer:
      while (length-- && resIndex < takeCount) {
        index += dir;
        var iterIndex = -1, value = array[index];
        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG$1) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
    return result;
  }

  var VERSION = "4.17.21";
  var WRAP_BIND_KEY_FLAG = 2;
  var LAZY_FILTER_FLAG = 1;
  var LAZY_WHILE_FLAG = 3;
  var MAX_ARRAY_LENGTH = 4294967295;
  var arrayProto = Array.prototype;
  var objectProto = Object.prototype;
  var hasOwnProperty$1 = objectProto.hasOwnProperty;
  var symIterator = Symbol$1 ? Symbol$1.iterator : void 0;
  var nativeMax = Math.max;
  var nativeMin = Math.min;
  var mixin = function(func2) {
    return function(object2, source, options) {
      if (options == null) {
        var isObj = isObject$1(source), props = isObj && keys(source), methodNames = props && props.length && baseFunctions(source, props);
        if (!(methodNames ? methodNames.length : isObj)) {
          options = source;
          source = object2;
          object2 = this;
        }
      }
      return func2(object2, source, options);
    };
  }(mixin$1);
  lodash.after = func.after;
  lodash.ary = func.ary;
  lodash.assign = object.assign;
  lodash.assignIn = object.assignIn;
  lodash.assignInWith = object.assignInWith;
  lodash.assignWith = object.assignWith;
  lodash.at = object.at;
  lodash.before = func.before;
  lodash.bind = func.bind;
  lodash.bindAll = util.bindAll;
  lodash.bindKey = func.bindKey;
  lodash.castArray = lang.castArray;
  lodash.chain = seq.chain;
  lodash.chunk = array.chunk;
  lodash.compact = array.compact;
  lodash.concat = array.concat;
  lodash.cond = util.cond;
  lodash.conforms = util.conforms;
  lodash.constant = util.constant;
  lodash.countBy = collection.countBy;
  lodash.create = object.create;
  lodash.curry = func.curry;
  lodash.curryRight = func.curryRight;
  lodash.debounce = func.debounce;
  lodash.defaults = object.defaults;
  lodash.defaultsDeep = object.defaultsDeep;
  lodash.defer = func.defer;
  lodash.delay = func.delay;
  lodash.difference = array.difference;
  lodash.differenceBy = array.differenceBy;
  lodash.differenceWith = array.differenceWith;
  lodash.drop = array.drop;
  lodash.dropRight = array.dropRight;
  lodash.dropRightWhile = array.dropRightWhile;
  lodash.dropWhile = array.dropWhile;
  lodash.fill = array.fill;
  lodash.filter = collection.filter;
  lodash.flatMap = collection.flatMap;
  lodash.flatMapDeep = collection.flatMapDeep;
  lodash.flatMapDepth = collection.flatMapDepth;
  lodash.flatten = array.flatten;
  lodash.flattenDeep = array.flattenDeep;
  lodash.flattenDepth = array.flattenDepth;
  lodash.flip = func.flip;
  lodash.flow = util.flow;
  lodash.flowRight = util.flowRight;
  lodash.fromPairs = array.fromPairs;
  lodash.functions = object.functions;
  lodash.functionsIn = object.functionsIn;
  lodash.groupBy = collection.groupBy;
  lodash.initial = array.initial;
  lodash.intersection = array.intersection;
  lodash.intersectionBy = array.intersectionBy;
  lodash.intersectionWith = array.intersectionWith;
  lodash.invert = object.invert;
  lodash.invertBy = object.invertBy;
  lodash.invokeMap = collection.invokeMap;
  lodash.iteratee = util.iteratee;
  lodash.keyBy = collection.keyBy;
  lodash.keys = keys;
  lodash.keysIn = object.keysIn;
  lodash.map = collection.map;
  lodash.mapKeys = object.mapKeys;
  lodash.mapValues = object.mapValues;
  lodash.matches = util.matches;
  lodash.matchesProperty = util.matchesProperty;
  lodash.memoize = func.memoize;
  lodash.merge = object.merge;
  lodash.mergeWith = object.mergeWith;
  lodash.method = util.method;
  lodash.methodOf = util.methodOf;
  lodash.mixin = mixin;
  lodash.negate = negate;
  lodash.nthArg = util.nthArg;
  lodash.omit = object.omit;
  lodash.omitBy = object.omitBy;
  lodash.once = func.once;
  lodash.orderBy = collection.orderBy;
  lodash.over = util.over;
  lodash.overArgs = func.overArgs;
  lodash.overEvery = util.overEvery;
  lodash.overSome = util.overSome;
  lodash.partial = func.partial;
  lodash.partialRight = func.partialRight;
  lodash.partition = collection.partition;
  lodash.pick = object.pick;
  lodash.pickBy = object.pickBy;
  lodash.property = util.property;
  lodash.propertyOf = util.propertyOf;
  lodash.pull = array.pull;
  lodash.pullAll = array.pullAll;
  lodash.pullAllBy = array.pullAllBy;
  lodash.pullAllWith = array.pullAllWith;
  lodash.pullAt = array.pullAt;
  lodash.range = util.range;
  lodash.rangeRight = util.rangeRight;
  lodash.rearg = func.rearg;
  lodash.reject = collection.reject;
  lodash.remove = array.remove;
  lodash.rest = func.rest;
  lodash.reverse = array.reverse;
  lodash.sampleSize = collection.sampleSize;
  lodash.set = object.set;
  lodash.setWith = object.setWith;
  lodash.shuffle = collection.shuffle;
  lodash.slice = array.slice;
  lodash.sortBy = collection.sortBy;
  lodash.sortedUniq = array.sortedUniq;
  lodash.sortedUniqBy = array.sortedUniqBy;
  lodash.split = string.split;
  lodash.spread = func.spread;
  lodash.tail = array.tail;
  lodash.take = array.take;
  lodash.takeRight = array.takeRight;
  lodash.takeRightWhile = array.takeRightWhile;
  lodash.takeWhile = array.takeWhile;
  lodash.tap = seq.tap;
  lodash.throttle = func.throttle;
  lodash.thru = thru;
  lodash.toArray = lang.toArray;
  lodash.toPairs = object.toPairs;
  lodash.toPairsIn = object.toPairsIn;
  lodash.toPath = util.toPath;
  lodash.toPlainObject = lang.toPlainObject;
  lodash.transform = object.transform;
  lodash.unary = func.unary;
  lodash.union = array.union;
  lodash.unionBy = array.unionBy;
  lodash.unionWith = array.unionWith;
  lodash.uniq = array.uniq;
  lodash.uniqBy = array.uniqBy;
  lodash.uniqWith = array.uniqWith;
  lodash.unset = object.unset;
  lodash.unzip = array.unzip;
  lodash.unzipWith = array.unzipWith;
  lodash.update = object.update;
  lodash.updateWith = object.updateWith;
  lodash.values = object.values;
  lodash.valuesIn = object.valuesIn;
  lodash.without = array.without;
  lodash.words = string.words;
  lodash.wrap = func.wrap;
  lodash.xor = array.xor;
  lodash.xorBy = array.xorBy;
  lodash.xorWith = array.xorWith;
  lodash.zip = array.zip;
  lodash.zipObject = array.zipObject;
  lodash.zipObjectDeep = array.zipObjectDeep;
  lodash.zipWith = array.zipWith;
  lodash.entries = object.toPairs;
  lodash.entriesIn = object.toPairsIn;
  lodash.extend = object.assignIn;
  lodash.extendWith = object.assignInWith;
  mixin(lodash, lodash);
  lodash.add = math.add;
  lodash.attempt = util.attempt;
  lodash.camelCase = string.camelCase;
  lodash.capitalize = string.capitalize;
  lodash.ceil = math.ceil;
  lodash.clamp = number.clamp;
  lodash.clone = lang.clone;
  lodash.cloneDeep = lang.cloneDeep;
  lodash.cloneDeepWith = lang.cloneDeepWith;
  lodash.cloneWith = lang.cloneWith;
  lodash.conformsTo = lang.conformsTo;
  lodash.deburr = string.deburr;
  lodash.defaultTo = util.defaultTo;
  lodash.divide = math.divide;
  lodash.endsWith = string.endsWith;
  lodash.eq = lang.eq;
  lodash.escape = string.escape;
  lodash.escapeRegExp = string.escapeRegExp;
  lodash.every = collection.every;
  lodash.find = collection.find;
  lodash.findIndex = array.findIndex;
  lodash.findKey = object.findKey;
  lodash.findLast = collection.findLast;
  lodash.findLastIndex = array.findLastIndex;
  lodash.findLastKey = object.findLastKey;
  lodash.floor = math.floor;
  lodash.forEach = collection.forEach;
  lodash.forEachRight = collection.forEachRight;
  lodash.forIn = object.forIn;
  lodash.forInRight = object.forInRight;
  lodash.forOwn = object.forOwn;
  lodash.forOwnRight = object.forOwnRight;
  lodash.get = object.get;
  lodash.gt = lang.gt;
  lodash.gte = lang.gte;
  lodash.has = object.has;
  lodash.hasIn = object.hasIn;
  lodash.head = array.head;
  lodash.identity = identity$1;
  lodash.includes = collection.includes;
  lodash.indexOf = array.indexOf;
  lodash.inRange = number.inRange;
  lodash.invoke = object.invoke;
  lodash.isArguments = lang.isArguments;
  lodash.isArray = isArray$1;
  lodash.isArrayBuffer = lang.isArrayBuffer;
  lodash.isArrayLike = lang.isArrayLike;
  lodash.isArrayLikeObject = lang.isArrayLikeObject;
  lodash.isBoolean = lang.isBoolean;
  lodash.isBuffer = lang.isBuffer;
  lodash.isDate = lang.isDate;
  lodash.isElement = lang.isElement;
  lodash.isEmpty = lang.isEmpty;
  lodash.isEqual = lang.isEqual;
  lodash.isEqualWith = lang.isEqualWith;
  lodash.isError = lang.isError;
  lodash.isFinite = lang.isFinite;
  lodash.isFunction = lang.isFunction;
  lodash.isInteger = lang.isInteger;
  lodash.isLength = lang.isLength;
  lodash.isMap = lang.isMap;
  lodash.isMatch = lang.isMatch;
  lodash.isMatchWith = lang.isMatchWith;
  lodash.isNaN = lang.isNaN;
  lodash.isNative = lang.isNative;
  lodash.isNil = lang.isNil;
  lodash.isNull = lang.isNull;
  lodash.isNumber = lang.isNumber;
  lodash.isObject = isObject$1;
  lodash.isObjectLike = lang.isObjectLike;
  lodash.isPlainObject = lang.isPlainObject;
  lodash.isRegExp = lang.isRegExp;
  lodash.isSafeInteger = lang.isSafeInteger;
  lodash.isSet = lang.isSet;
  lodash.isString = lang.isString;
  lodash.isSymbol = lang.isSymbol;
  lodash.isTypedArray = lang.isTypedArray;
  lodash.isUndefined = lang.isUndefined;
  lodash.isWeakMap = lang.isWeakMap;
  lodash.isWeakSet = lang.isWeakSet;
  lodash.join = array.join;
  lodash.kebabCase = string.kebabCase;
  lodash.last = last;
  lodash.lastIndexOf = array.lastIndexOf;
  lodash.lowerCase = string.lowerCase;
  lodash.lowerFirst = string.lowerFirst;
  lodash.lt = lang.lt;
  lodash.lte = lang.lte;
  lodash.max = math.max;
  lodash.maxBy = math.maxBy;
  lodash.mean = math.mean;
  lodash.meanBy = math.meanBy;
  lodash.min = math.min;
  lodash.minBy = math.minBy;
  lodash.stubArray = util.stubArray;
  lodash.stubFalse = util.stubFalse;
  lodash.stubObject = util.stubObject;
  lodash.stubString = util.stubString;
  lodash.stubTrue = util.stubTrue;
  lodash.multiply = math.multiply;
  lodash.nth = array.nth;
  lodash.noop = util.noop;
  lodash.now = date.now;
  lodash.pad = string.pad;
  lodash.padEnd = string.padEnd;
  lodash.padStart = string.padStart;
  lodash.parseInt = string.parseInt;
  lodash.random = number.random;
  lodash.reduce = collection.reduce;
  lodash.reduceRight = collection.reduceRight;
  lodash.repeat = string.repeat;
  lodash.replace = string.replace;
  lodash.result = object.result;
  lodash.round = math.round;
  lodash.sample = collection.sample;
  lodash.size = collection.size;
  lodash.snakeCase = string.snakeCase;
  lodash.some = collection.some;
  lodash.sortedIndex = array.sortedIndex;
  lodash.sortedIndexBy = array.sortedIndexBy;
  lodash.sortedIndexOf = array.sortedIndexOf;
  lodash.sortedLastIndex = array.sortedLastIndex;
  lodash.sortedLastIndexBy = array.sortedLastIndexBy;
  lodash.sortedLastIndexOf = array.sortedLastIndexOf;
  lodash.startCase = string.startCase;
  lodash.startsWith = string.startsWith;
  lodash.subtract = math.subtract;
  lodash.sum = math.sum;
  lodash.sumBy = math.sumBy;
  lodash.template = string.template;
  lodash.times = util.times;
  lodash.toFinite = lang.toFinite;
  lodash.toInteger = toInteger;
  lodash.toLength = lang.toLength;
  lodash.toLower = string.toLower;
  lodash.toNumber = lang.toNumber;
  lodash.toSafeInteger = lang.toSafeInteger;
  lodash.toString = lang.toString;
  lodash.toUpper = string.toUpper;
  lodash.trim = string.trim;
  lodash.trimEnd = string.trimEnd;
  lodash.trimStart = string.trimStart;
  lodash.truncate = string.truncate;
  lodash.unescape = string.unescape;
  lodash.uniqueId = util.uniqueId;
  lodash.upperCase = string.upperCase;
  lodash.upperFirst = string.upperFirst;
  lodash.each = collection.forEach;
  lodash.eachRight = collection.forEachRight;
  lodash.first = array.head;
  mixin(lodash, function() {
    var source = {};
    baseForOwn(lodash, function(func2, methodName) {
      if (!hasOwnProperty$1.call(lodash.prototype, methodName)) {
        source[methodName] = func2;
      }
    });
    return source;
  }(), { "chain": false });
  lodash.VERSION = VERSION;
  (lodash.templateSettings = string.templateSettings).imports._ = lodash;
  arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
    lodash[methodName].placeholder = lodash;
  });
  arrayEach(["drop", "take"], function(methodName, index) {
    LazyWrapper.prototype[methodName] = function(n) {
      n = n === void 0 ? 1 : nativeMax(toInteger(n), 0);
      var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
      if (result.__filtered__) {
        result.__takeCount__ = nativeMin(n, result.__takeCount__);
      } else {
        result.__views__.push({
          "size": nativeMin(n, MAX_ARRAY_LENGTH),
          "type": methodName + (result.__dir__ < 0 ? "Right" : "")
        });
      }
      return result;
    };
    LazyWrapper.prototype[methodName + "Right"] = function(n) {
      return this.reverse()[methodName](n).reverse();
    };
  });
  arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
    var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
    LazyWrapper.prototype[methodName] = function(iteratee) {
      var result = this.clone();
      result.__iteratees__.push({
        "iteratee": baseIteratee(iteratee),
        "type": type
      });
      result.__filtered__ = result.__filtered__ || isFilter;
      return result;
    };
  });
  arrayEach(["head", "last"], function(methodName, index) {
    var takeName = "take" + (index ? "Right" : "");
    LazyWrapper.prototype[methodName] = function() {
      return this[takeName](1).value()[0];
    };
  });
  arrayEach(["initial", "tail"], function(methodName, index) {
    var dropName = "drop" + (index ? "" : "Right");
    LazyWrapper.prototype[methodName] = function() {
      return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
    };
  });
  LazyWrapper.prototype.compact = function() {
    return this.filter(identity$1);
  };
  LazyWrapper.prototype.find = function(predicate) {
    return this.filter(predicate).head();
  };
  LazyWrapper.prototype.findLast = function(predicate) {
    return this.reverse().find(predicate);
  };
  LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
    if (typeof path == "function") {
      return new LazyWrapper(this);
    }
    return this.map(function(value) {
      return baseInvoke(value, path, args);
    });
  });
  LazyWrapper.prototype.reject = function(predicate) {
    return this.filter(negate(baseIteratee(predicate)));
  };
  LazyWrapper.prototype.slice = function(start, end) {
    start = toInteger(start);
    var result = this;
    if (result.__filtered__ && (start > 0 || end < 0)) {
      return new LazyWrapper(result);
    }
    if (start < 0) {
      result = result.takeRight(-start);
    } else if (start) {
      result = result.drop(start);
    }
    if (end !== void 0) {
      end = toInteger(end);
      result = end < 0 ? result.dropRight(-end) : result.take(end - start);
    }
    return result;
  };
  LazyWrapper.prototype.takeRightWhile = function(predicate) {
    return this.reverse().takeWhile(predicate).reverse();
  };
  LazyWrapper.prototype.toArray = function() {
    return this.take(MAX_ARRAY_LENGTH);
  };
  baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
    var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
    if (!lodashFunc) {
      return;
    }
    lodash.prototype[methodName] = function() {
      var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray$1(value);
      var interceptor = function(value2) {
        var result2 = lodashFunc.apply(lodash, arrayPush([value2], args));
        return isTaker && chainAll ? result2[0] : result2;
      };
      if (useLazy && checkIteratee && typeof iteratee == "function" && iteratee.length != 1) {
        isLazy = useLazy = false;
      }
      var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
      if (!retUnwrapped && useLazy) {
        value = onlyLazy ? value : new LazyWrapper(this);
        var result = func2.apply(value, args);
        result.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": void 0 });
        return new LodashWrapper(result, chainAll);
      }
      if (isUnwrapped && onlyLazy) {
        return func2.apply(this, args);
      }
      result = this.thru(interceptor);
      return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
    };
  });
  arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
    var func2 = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
    lodash.prototype[methodName] = function() {
      var args = arguments;
      if (retUnwrapped && !this.__chain__) {
        var value = this.value();
        return func2.apply(isArray$1(value) ? value : [], args);
      }
      return this[chainName](function(value2) {
        return func2.apply(isArray$1(value2) ? value2 : [], args);
      });
    };
  });
  baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
    var lodashFunc = lodash[methodName];
    if (lodashFunc) {
      var key = lodashFunc.name + "";
      if (!hasOwnProperty$1.call(realNames, key)) {
        realNames[key] = [];
      }
      realNames[key].push({ "name": methodName, "func": lodashFunc });
    }
  });
  realNames[createHybrid(void 0, WRAP_BIND_KEY_FLAG).name] = [{
    "name": "wrapper",
    "func": void 0
  }];
  LazyWrapper.prototype.clone = lazyClone;
  LazyWrapper.prototype.reverse = lazyReverse;
  LazyWrapper.prototype.value = lazyValue;
  lodash.prototype.at = seq.at;
  lodash.prototype.chain = seq.wrapperChain;
  lodash.prototype.commit = seq.commit;
  lodash.prototype.next = seq.next;
  lodash.prototype.plant = seq.plant;
  lodash.prototype.reverse = seq.reverse;
  lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = seq.value;
  lodash.prototype.first = lodash.prototype.head;
  if (symIterator) {
    lodash.prototype[symIterator] = seq.toIterator;
  }
  /**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
  const isVisible = (element) => {
    const computed = getComputedStyle(element);
    return computed.position === "fixed" ? false : element.offsetParent !== null;
  };
  const obtainAllFocusableElements$1 = (element) => {
    return Array.from(
      element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)
    ).filter((item) => isFocusable(item) && isVisible(item));
  };
  const isFocusable = (element) => {
    if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
      return true;
    }
    if (element.disabled) {
      return false;
    }
    switch (element.nodeName) {
      case "A": {
        return !!element.href && element.rel !== "ignore";
      }
      case "INPUT": {
        return !(element.type === "hidden" || element.type === "file");
      }
      case "BUTTON":
      case "SELECT":
      case "TEXTAREA": {
        return true;
      }
      default: {
        return false;
      }
    }
  };

  const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
    const handleEvent = (event) => {
      const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
      if (checkForDefaultPrevented === false || !shouldPrevent) {
        return oursHandler == null ? void 0 : oursHandler(event);
      }
    };
    return handleEvent;
  };

  var _a;
  const isClient = typeof window !== "undefined";
  const isString$1 = (val) => typeof val === "string";
  const noop = () => {
  };
  const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);

  function resolveUnref(r) {
    return typeof r === "function" ? r() : vue.unref(r);
  }
  function identity(arg) {
    return arg;
  }

  function tryOnScopeDispose(fn) {
    if (vue.getCurrentScope()) {
      vue.onScopeDispose(fn);
      return true;
    }
    return false;
  }

  var __defProp$7 = Object.defineProperty;
  var __defProps$5 = Object.defineProperties;
  var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
  var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
  var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$7 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$9.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    if (__getOwnPropSymbols$9)
      for (var prop of __getOwnPropSymbols$9(b)) {
        if (__propIsEnum$9.call(b, prop))
          __defNormalProp$7(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
  function toRefs(objectRef) {
    if (!vue.isRef(objectRef))
      return vue.toRefs(objectRef);
    const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};
    for (const key in objectRef.value) {
      result[key] = vue.customRef(() => ({
        get() {
          return objectRef.value[key];
        },
        set(v) {
          if (Array.isArray(objectRef.value)) {
            const copy = [...objectRef.value];
            copy[key] = v;
            objectRef.value = copy;
          } else {
            const newObject = __spreadProps$5(__spreadValues$7({}, objectRef.value), { [key]: v });
            Object.setPrototypeOf(newObject, objectRef.value);
            objectRef.value = newObject;
          }
        }
      }));
    }
    return result;
  }

  function tryOnMounted(fn, sync = true) {
    if (vue.getCurrentInstance())
      vue.onMounted(fn);
    else if (sync)
      fn();
    else
      vue.nextTick(fn);
  }

  function useTimeoutFn(cb, interval, options = {}) {
    const {
      immediate = true
    } = options;
    const isPending = vue.ref(false);
    let timer = null;
    function clear() {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    }
    function stop() {
      isPending.value = false;
      clear();
    }
    function start(...args) {
      clear();
      isPending.value = true;
      timer = setTimeout(() => {
        isPending.value = false;
        timer = null;
        cb(...args);
      }, resolveUnref(interval));
    }
    if (immediate) {
      isPending.value = true;
      if (isClient)
        start();
    }
    tryOnScopeDispose(stop);
    return {
      isPending: vue.readonly(isPending),
      start,
      stop
    };
  }

  function unrefElement(elRef) {
    var _a;
    const plain = resolveUnref(elRef);
    return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
  }

  const defaultWindow = isClient ? window : void 0;

  function useEventListener(...args) {
    let target;
    let events;
    let listeners;
    let options;
    if (isString$1(args[0]) || Array.isArray(args[0])) {
      [events, listeners, options] = args;
      target = defaultWindow;
    } else {
      [target, events, listeners, options] = args;
    }
    if (!target)
      return noop;
    if (!Array.isArray(events))
      events = [events];
    if (!Array.isArray(listeners))
      listeners = [listeners];
    const cleanups = [];
    const cleanup = () => {
      cleanups.forEach((fn) => fn());
      cleanups.length = 0;
    };
    const register = (el, event, listener, options2) => {
      el.addEventListener(event, listener, options2);
      return () => el.removeEventListener(event, listener, options2);
    };
    const stopWatch = vue.watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      cleanups.push(...events.flatMap((event) => {
        return listeners.map((listener) => register(el, event, listener, options2));
      }));
    }, { immediate: true, flush: "post" });
    const stop = () => {
      stopWatch();
      cleanup();
    };
    tryOnScopeDispose(stop);
    return stop;
  }

  let _iOSWorkaround = false;
  function onClickOutside(target, handler, options = {}) {
    const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
    if (!window)
      return;
    if (isIOS && !_iOSWorkaround) {
      _iOSWorkaround = true;
      Array.from(window.document.body.children).forEach((el) => el.addEventListener("click", noop));
    }
    let shouldListen = true;
    const shouldIgnore = (event) => {
      return ignore.some((target2) => {
        if (typeof target2 === "string") {
          return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
        } else {
          const el = unrefElement(target2);
          return el && (event.target === el || event.composedPath().includes(el));
        }
      });
    };
    const listener = (event) => {
      const el = unrefElement(target);
      if (!el || el === event.target || event.composedPath().includes(el))
        return;
      if (event.detail === 0)
        shouldListen = !shouldIgnore(event);
      if (!shouldListen) {
        shouldListen = true;
        return;
      }
      handler(event);
    };
    const cleanup = [
      useEventListener(window, "click", listener, { passive: true, capture }),
      useEventListener(window, "pointerdown", (e) => {
        const el = unrefElement(target);
        if (el)
          shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
      }, { passive: true }),
      detectIframe && useEventListener(window, "blur", (event) => {
        var _a;
        const el = unrefElement(target);
        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window.document.activeElement)))
          handler(event);
      })
    ].filter(Boolean);
    const stop = () => cleanup.forEach((fn) => fn());
    return stop;
  }

  function useSupported(callback, sync = false) {
    const isSupported = vue.ref();
    const update = () => isSupported.value = Boolean(callback());
    update();
    tryOnMounted(update, sync);
    return isSupported;
  }

  const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  const globalKey = "__vueuse_ssr_handlers__";
  _global[globalKey] = _global[globalKey] || {};
  _global[globalKey];

  var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
  var __hasOwnProp$g = Object.prototype.hasOwnProperty;
  var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
  var __objRest$2 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$g)
      for (var prop of __getOwnPropSymbols$g(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  function useResizeObserver(target, callback, options = {}) {
    const _a = options, { window = defaultWindow } = _a, observerOptions = __objRest$2(_a, ["window"]);
    let observer;
    const isSupported = useSupported(() => window && "ResizeObserver" in window);
    const cleanup = () => {
      if (observer) {
        observer.disconnect();
        observer = void 0;
      }
    };
    const stopWatch = vue.watch(() => unrefElement(target), (el) => {
      cleanup();
      if (isSupported.value && window && el) {
        observer = new ResizeObserver(callback);
        observer.observe(el, observerOptions);
      }
    }, { immediate: true, flush: "post" });
    const stop = () => {
      cleanup();
      stopWatch();
    };
    tryOnScopeDispose(stop);
    return {
      isSupported,
      stop
    };
  }

  var SwipeDirection;
  (function(SwipeDirection2) {
    SwipeDirection2["UP"] = "UP";
    SwipeDirection2["RIGHT"] = "RIGHT";
    SwipeDirection2["DOWN"] = "DOWN";
    SwipeDirection2["LEFT"] = "LEFT";
    SwipeDirection2["NONE"] = "NONE";
  })(SwipeDirection || (SwipeDirection = {}));

  var __defProp = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  const _TransitionPresets = {
    easeInSine: [0.12, 0, 0.39, 0],
    easeOutSine: [0.61, 1, 0.88, 1],
    easeInOutSine: [0.37, 0, 0.63, 1],
    easeInQuad: [0.11, 0, 0.5, 0],
    easeOutQuad: [0.5, 1, 0.89, 1],
    easeInOutQuad: [0.45, 0, 0.55, 1],
    easeInCubic: [0.32, 0, 0.67, 0],
    easeOutCubic: [0.33, 1, 0.68, 1],
    easeInOutCubic: [0.65, 0, 0.35, 1],
    easeInQuart: [0.5, 0, 0.75, 0],
    easeOutQuart: [0.25, 1, 0.5, 1],
    easeInOutQuart: [0.76, 0, 0.24, 1],
    easeInQuint: [0.64, 0, 0.78, 0],
    easeOutQuint: [0.22, 1, 0.36, 1],
    easeInOutQuint: [0.83, 0, 0.17, 1],
    easeInExpo: [0.7, 0, 0.84, 0],
    easeOutExpo: [0.16, 1, 0.3, 1],
    easeInOutExpo: [0.87, 0, 0.13, 1],
    easeInCirc: [0.55, 0, 1, 0.45],
    easeOutCirc: [0, 0.55, 0.45, 1],
    easeInOutCirc: [0.85, 0, 0.15, 1],
    easeInBack: [0.36, 0, 0.66, -0.56],
    easeOutBack: [0.34, 1.56, 0.64, 1],
    easeInOutBack: [0.68, -0.6, 0.32, 1.6]
  };
  __spreadValues({
    linear: identity
  }, _TransitionPresets);

  const getOffsetTop = (el) => {
    let offset = 0;
    let parent = el;
    while (parent) {
      offset += parent.offsetTop;
      parent = parent.offsetParent;
    }
    return offset;
  };
  const getOffsetTopDistance = (el, containerEl) => {
    return Math.abs(getOffsetTop(el) - getOffsetTop(containerEl));
  };

  const NOOP = () => {
  };
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty.call(val, key);
  const isArray = Array.isArray;
  const isFunction = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isObject = (val) => val !== null && typeof val === "object";
  const cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  });
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );

  const isBoolean = (val) => typeof val === "boolean";
  const isNumber = (val) => typeof val === "number" && isFinite(val);
  const isUndefined = (val) => val === void 0;
  const isEmpty = (val) => !val && val !== 0 || isArray(val) && val.length === 0 || isObject(val) && !Object.keys(val).length;
  const isElement$2 = (e) => {
    if (typeof Element === "undefined")
      return false;
    return e instanceof Element;
  };
  const isStringNumber = (val) => {
    if (!isString(val)) {
      return false;
    }
    return !Number.isNaN(Number(val));
  };

  const escapeStringRegexp = (string = "") => string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");

  const keysOf = (arr) => Object.keys(arr);
  const entriesOf = (arr) => Object.entries(arr);

  class VuesaxAlphaError extends Error {
    constructor(m) {
      super(m);
      this.name = "VuesaxAlphaError";
    }
  }
  function throwError(scope, m) {
    throw new VuesaxAlphaError(`[${scope}] ${m}`);
  }
  function debugWarn(scope, message) {
  }

  const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
  const hasClass = (el, cls) => {
    if (!el || !cls)
      return false;
    if (cls.includes(" "))
      throw new Error("className should not contain space.");
    return el.classList.contains(cls);
  };
  const addClass = (el, cls) => {
    if (!el || !cls.trim())
      return;
    el.classList.add(...classNameToArray(cls));
  };
  const removeClass = (el, cls) => {
    if (!el || !cls.trim())
      return;
    el.classList.remove(...classNameToArray(cls));
  };
  const getStyle = (element, styleName) => {
    var _a;
    if (!isClient || !element || !styleName)
      return "";
    let key = camelize(styleName);
    if (key === "float")
      key = "cssFloat";
    try {
      const style = element.style[key];
      if (style)
        return style;
      const computed = (_a = document.defaultView) == null ? void 0 : _a.getComputedStyle(element, "");
      return computed ? computed[key] : "";
    } catch (e) {
      return element.style[key];
    }
  };
  const setStyle = (element, styleName, value) => {
    if (!element || !styleName)
      return;
    if (isObject(styleName)) {
      entriesOf(styleName).forEach(
        ([prop, value2]) => setStyle(element, prop, value2)
      );
    } else {
      const key = camelize(styleName);
      element.style[key] = value;
    }
  };
  const removeStyle = (element, style) => {
    if (!element || !style)
      return;
    if (isObject(style)) {
      keysOf(style).forEach((prop) => removeStyle(element, prop));
    } else {
      setStyle(element, style, "");
    }
  };
  function addUnit(value, defaultUnit = "px") {
    if (!value)
      return "";
    if (isNumber(value) || isStringNumber(value)) {
      return `${value}${defaultUnit}`;
    } else if (isString(value)) {
      return value;
    }
  }

  const isScroll = (el, isVertical) => {
    if (!isClient)
      return false;
    const key = {
      undefined: "overflow",
      true: "overflow-y",
      false: "overflow-x"
    }[String(isVertical)];
    const overflow = getStyle(el, key);
    return ["scroll", "auto", "overlay"].some((s) => overflow.includes(s));
  };
  const getScrollContainer = (el, isVertical) => {
    if (!isClient)
      return;
    let parent = el;
    while (parent) {
      if ([window, document, document.documentElement].includes(parent))
        return window;
      if (isScroll(parent, isVertical))
        return parent;
      parent = parent.parentNode;
    }
    return parent;
  };
  let scrollBarWidth;
  const getScrollBarWidth = (namespace) => {
    var _a;
    if (!isClient)
      return 0;
    if (scrollBarWidth !== void 0)
      return scrollBarWidth;
    const outer = document.createElement("div");
    outer.className = `${namespace}-scrollbar__wrap`;
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.position = "absolute";
    outer.style.top = "-9999px";
    document.body.appendChild(outer);
    const widthNoScroll = outer.offsetWidth;
    outer.style.overflow = "scroll";
    const inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);
    const widthWithScroll = inner.offsetWidth;
    (_a = outer.parentNode) == null ? void 0 : _a.removeChild(outer);
    scrollBarWidth = widthNoScroll - widthWithScroll;
    return scrollBarWidth;
  };
  function scrollIntoView(container, selected) {
    if (!isClient)
      return;
    if (!selected) {
      container.scrollTop = 0;
      return;
    }
    const offsetParents = [];
    let pointer = selected.offsetParent;
    while (pointer !== null && container !== pointer && container.contains(pointer)) {
      offsetParents.push(pointer);
      pointer = pointer.offsetParent;
    }
    const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
    const bottom = top + selected.offsetHeight;
    const viewRectTop = container.scrollTop;
    const viewRectBottom = viewRectTop + container.clientHeight;
    if (top < viewRectTop) {
      container.scrollTop = top;
    } else if (bottom > viewRectBottom) {
      container.scrollTop = bottom - container.clientHeight;
    }
  }

  let target = !isClient ? void 0 : document.body;
  const createGlobalNode = (id) => {
    const el = document.createElement("div");
    if (id !== void 0) {
      el.setAttribute("id", id);
    }
    target.appendChild(el);
    return el;
  };
  const removeGlobalNode = (el) => {
    el.remove();
  };

  const vsPropKey = "__vsPropKey";
  const definePropType = (val) => val;
  const isVsProp = (val) => isObject(val) && !!val[vsPropKey];
  const buildProp = (prop, key) => {
    if (!isObject(prop) || isVsProp(prop))
      return prop;
    const { values, required, default: defaultValue, type, validator } = prop;
    const _validator = values || validator ? (val) => {
      let valid = false;
      let allowedValues = [];
      if (values) {
        allowedValues = Array.from(values);
        if (hasOwn(prop, "default")) {
          allowedValues.push(defaultValue);
        }
        valid || (valid = allowedValues.includes(val));
      }
      if (validator)
        valid || (valid = validator(val));
      if (!valid && allowedValues.length > 0) {
        const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
        vue.warn(
          `Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(
          val
        )}.`
        );
      }
      return valid;
    } : void 0;
    const vsProp = {
      type,
      required: !!required,
      validator: _validator,
      [vsPropKey]: true
    };
    if (hasOwn(prop, "default"))
      vsProp.default = defaultValue;
    return vsProp;
  };
  const buildProps = (props) => fromPairs(
    Object.entries(props).map(([key, option]) => [
      key,
      buildProp(option, key)
    ])
  );

  const iconPropType = definePropType([
    String,
    Object,
    Function
  ]);

  const withInstall = (main, extra) => {
    main.install = (app) => {
      for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
        app.component(comp.name, comp);
      }
    };
    if (extra) {
      for (const [key, comp] of Object.entries(extra)) {
        main[key] = comp;
      }
    }
    return main;
  };
  const withInstallFunction = (fn, name) => {
    fn.install = (app) => {
      fn._context = app._context;
      app.config.globalProperties[name] = fn;
    };
    return fn;
  };
  const withNoopInstall = (component) => {
    component.install = NOOP;
    return component;
  };

  const EVENT_CODE = {
    tab: "Tab",
    enter: "Enter",
    space: "Space",
    left: "ArrowLeft",
    up: "ArrowUp",
    right: "ArrowRight",
    down: "ArrowDown",
    esc: "Escape",
    delete: "Delete",
    backspace: "Backspace",
    numpadEnter: "NumpadEnter",
    pageUp: "PageUp",
    pageDown: "PageDown",
    home: "Home",
    end: "End"
  };

  const rgbRE = /^(rgb|rgba)/;
  const rgbNumberRE = /^(0|255|25[0-4]|2[0-4]\d|1\d\d|0?\d?\d),(0|255|25[0-4]|2[0-4]\d|1\d\d|0?\d?\d),(0|255|25[0-4]|2[0-4]\d|1\d\d|0?\d?\d)$/;
  const leadingHashRE = /^(#)/;
  const hexShorthandRE = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  const hexFullRE = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
  const componentColors = [
    "primary",
    "success",
    "danger",
    "warn",
    "dark",
    "text"
  ];
  const vuesaxColors = [
    ...componentColors,
    "light",
    "secondary",
    "facebook",
    "twitter",
    "youtube",
    "pinterest",
    "linkedin",
    "snapchat",
    "whatsapp",
    "tumblr",
    "reddit",
    "spotify",
    "amazon",
    "medium",
    "vimeo",
    "skype",
    "dribbble",
    "slack",
    "yahoo",
    "twitch",
    "discord",
    "telegram",
    "google-plus",
    "messenger"
  ];

  const defaultZIndex = 2e3;

  const UPDATE_MODEL_EVENT = "update:modelValue";
  const CHANGE_EVENT = "change";
  const INPUT_EVENT = "input";

  const INSTALLED_KEY = Symbol("INSTALLED_KEY");

  const LOADING_RECT = {
    height: 40,
    width: 40
  };
  const SCALE_PARENT = 0.8;

  const placements = [
    "top",
    "top-start",
    "top-end",
    "bottom",
    "bottom-start",
    "bottom-end",
    "left",
    "left-start",
    "left-end",
    "right",
    "right-start",
    "right-end"
  ];

  const componentSizes = ["", "default", "small", "large"];
  const componentSizeMap = {
    large: 40,
    default: 32,
    small: 24
  };

  const isVsColor = (color) => vuesaxColors.includes(color);
  const isHexColor = (color) => leadingHashRE.test(color) && [4, 7, 5, 9].includes(color.length);
  const isRgbColor = (color) => rgbRE.test(color);
  const isRGBNumbers = (color) => rgbNumberRE.test(color);
  const hexToRgb = (color) => {
    color = color.replace(
      hexShorthandRE,
      (_, r, g, b) => r + r + g + g + b + b
    );
    const res = hexFullRE.exec(color);
    return res ? {
      r: Number.parseInt(res[1], 16),
      g: Number.parseInt(res[2], 16),
      b: Number.parseInt(res[3], 16)
    } : null;
  };
  const setColor = (colorName, color, el, addClass, namespace = "vs") => {
    let newColor;
    if (color == "dark" && el) {
      if (addClass) {
        el.classList.add(`${namespace}-component-dark`);
      }
    }
    if (isRgbColor(color)) {
      const arrayColor = color.replace(/[rgba()]/g, "").split(",");
      newColor = `${arrayColor[0]},${arrayColor[1]},${arrayColor[2]}`;
      setCssVar(colorName, newColor, el);
      if (addClass) {
        el.classList.add(`${namespace}-change-color`);
      }
    } else if (isHexColor(color)) {
      const rgb = hexToRgb(color);
      newColor = `${rgb.r},${rgb.g},${rgb.b}`;
      setCssVar(colorName, newColor, el);
      if (addClass) {
        el.classList.add(`${namespace}-change-color`);
      }
    } else if (isVsColor(color)) {
      const style = window.getComputedStyle(document.body);
      newColor = style.getPropertyValue(`--${namespace}-${color}`);
      setCssVar(colorName, newColor, el);
      if (addClass) {
        el.classList.add(`${namespace}-change-color`);
      }
    } else if (isRGBNumbers(color)) {
      setCssVar(colorName, color, el);
      if (addClass) {
        el.classList.add(`${namespace}-change-color`);
      }
    }
  };
  const acceptColor = (color) => {
    const isValid = isVsColor(color) || isHexColor(color) || isRgbColor(color);
    if (isValid)
      return true;
    return false;
  };
  const getVsColor = (colorRef, namespace = "vs") => {
    const color = vue.unref(colorRef);
    if (!color)
      return "";
    const isRGB = rgbRE.test(color);
    const isRGBNumbers2 = rgbNumberRE.test(color);
    const isHEX = leadingHashRE.test(color);
    let newColor = "";
    if (isRGB) {
      const arrayColor = color.replace(/[rgba()]/g, "").split(",");
      newColor = `${arrayColor[0]}, ${arrayColor[1]}, ${arrayColor[2]}`;
    } else if (isHEX) {
      const rgb = hexToRgb(color);
      newColor = `${rgb == null ? void 0 : rgb.r}, ${rgb == null ? void 0 : rgb.g}, ${rgb == null ? void 0 : rgb.b}`;
    } else if (isVsColor(color)) {
      newColor = `var(--${namespace}-${color})`;
    } else if (isRGBNumbers2) {
      newColor = color;
    }
    return newColor;
  };
  const setCssVar = (propertyName, value, el, namespace = "vs") => {
    if (!el && (document == null ? void 0 : document.documentElement)) {
      document.documentElement.style.setProperty(
        `--${namespace}-${propertyName}`,
        value
      );
    } else {
      if ((el == null ? void 0 : el.nodeName) !== "#comment") {
        el == null ? void 0 : el.style.setProperty(`--${namespace}-${propertyName}`, value);
      }
    }
  };

  const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
  const isValidComponentColor = (color) => acceptColor(color);

  var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
    PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
    PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
    PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
    PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
    PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
    PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
    PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
    PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
    PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
    PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
    PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
    PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
    PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
    return PatchFlags2;
  })(PatchFlags || {});
  const flattedChildren = (children) => {
    const vNodes = isArray(children) ? children : [children];
    const result = [];
    vNodes.forEach((child) => {
      var _a;
      if (isArray(child)) {
        result.push(...flattedChildren(child));
      } else if (vue.isVNode(child) && isArray(child.children)) {
        result.push(...flattedChildren(child.children));
      } else {
        result.push(child);
        if (vue.isVNode(child) && ((_a = child.component) == null ? void 0 : _a.subTree)) {
          result.push(...flattedChildren(child.component.subTree));
        }
      }
    });
    return result;
  };

  const isKorean = (text) => /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi.test(text);

  const ripple = (evs, color, solid) => {
    const el = evs.currentTarget;
    const offset = el.getBoundingClientRect();
    const x = evs.clientX - offset.left;
    const y = evs.clientY - offset.top;
    let time = 0.6;
    if (el.clientWidth > 150) {
      time = 1.2;
    }
    const effectContent = document.createElement("div");
    effectContent.className = "vs-ripple";
    if (!color) {
      setColor("color", "#fff", effectContent);
    }
    const effect = document.createElement("div");
    effect.className = "vs-ripple--default";
    if (solid) {
      effect.classList.add("vs-ripple--solid");
    }
    effect.style.transition = `all ${time}s ease`;
    effect.style.left = `${x}px`;
    effect.style.top = `${y}px`;
    effectContent.appendChild(effect);
    el.appendChild(effectContent);
    effect.style.width = `${el.clientWidth * 2.5}px`;
    effect.style.height = `${el.clientWidth * 2.5}px`;
    effect.style.opacity = `1`;
    let noTime = false;
    setTimeout(() => {
      noTime = true;
    }, 300);
    function removeEffect(evs2) {
      effect.style.transition = `all 0.${time * 600}s ease`;
      setTimeout(
        () => {
          effect.style.opacity = "0";
          setTimeout(() => {
            el.removeChild(effectContent);
          }, time * 300);
        },
        noTime ? 0 : time * 400
      );
      evs2.target.removeEventListener("mouseup", removeEffect);
      evs2.target.removeEventListener("mouseleave", removeEffect);
    }
    evs.target.addEventListener("mouseup", removeEffect);
    evs.target.addEventListener("mouseleave", removeEffect);
  };
  const rippleReverse = (evs) => {
    const el = evs.currentTarget;
    const offset = el.getBoundingClientRect();
    const x = evs.clientX - offset.left;
    const y = evs.clientY - offset.top;
    let time = 0.6;
    if (el.clientWidth > 150) {
      time = 1.2;
    }
    const effectContent = document.createElement("div");
    effectContent.className = "vs-ripple";
    const effect = document.createElement("div");
    effect.className = "vs-ripple--invert";
    effect.style.left = `${x}px`;
    effect.style.top = `${y}px`;
    effect.style.width = `${el.clientWidth * 2.5}px`;
    effect.style.height = `${el.clientWidth * 2.5}px`;
    effect.style.opacity = "0";
    effectContent.appendChild(effect);
    el.appendChild(effectContent);
    setTimeout(() => {
      effect.style.width = "0px";
      effect.style.height = "0px";
      effect.style.opacity = "0.5";
    }, 1);
    let noTime = false;
    setTimeout(() => {
      noTime = true;
    }, 300);
    function removeEffect(evs2) {
      effect.style.transition = `all 0.${time * 600}s ease`;
      setTimeout(
        () => {
          effect.style.opacity = "0";
          setTimeout(() => {
            el.removeChild(effectContent);
          }, time * 300);
        },
        noTime ? 0 : time * 400
      );
      evs2.target.removeEventListener("mouseup", removeEffect);
      evs2.target.removeEventListener("mouseleave", removeEffect);
    }
    evs.target.addEventListener("mouseup", removeEffect);
    evs.target.addEventListener("mouseleave", removeEffect);
  };
  const rippleCut = (evs) => {
    const el = evs.currentTarget;
    const offset = el.getBoundingClientRect();
    const x = evs.clientX - offset.left;
    const y = evs.clientY - offset.top;
    let time = 0.6;
    if (el.clientWidth > 150) {
      time = 1.2;
    }
    const effectContent = document.createElement("div");
    effectContent.className = "vs-ripple";
    const effect = document.createElement("div");
    const effect2 = document.createElement("div");
    effect.className = "vs-ripple--cut-1";
    effect2.className = "vs-ripple--cut-2";
    effect.style.left = effect2.style.left = `${x}px`;
    effect.style.top = effect2.style.top = `${y}px`;
    effect.style.width = effect2.style.width = `${el.clientWidth * 2.5}px`;
    effect.style.height = effect2.style.height = `${el.clientWidth * 2.5}px`;
    effect.style.opacity = effect2.style.opacity = `1`;
    effectContent.appendChild(effect);
    effectContent.appendChild(effect2);
    el.appendChild(effectContent);
    setTimeout(() => {
      effect.style.left = `-${el.clientWidth * 1.3}px`;
      effect.style.opacity = "1";
      effect2.style.left = `${el.clientWidth * 1.3}px`;
      effect2.style.opacity = "1";
    }, 1);
    let noTime = false;
    setTimeout(() => {
      noTime = true;
    }, 300);
    function removeEffect(evs2) {
      effect.style.transition = `all 0.${time * 600}s ease`;
      setTimeout(
        () => {
          effect.style.opacity = "0";
          setTimeout(() => {
            el.removeChild(effectContent);
          }, time * 300);
        },
        noTime ? 0 : time * 400
      );
      evs2.target.removeEventListener("mouseup", removeEffect);
      evs2.target.removeEventListener("mouseleave", removeEffect);
    }
    evs.target.addEventListener("mouseup", removeEffect);
    evs.target.addEventListener("mouseleave", removeEffect);
  };

  const mutable = (val) => val;

  const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
  const LISTENER_PREFIX = /^on[A-Z]/;
  const useAttrs = (params = {}) => {
    const { excludeListeners = false, excludeKeys } = params;
    const allExcludeKeys = vue.computed(() => {
      return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
    });
    const instance = vue.getCurrentInstance();
    if (!instance) {
      return vue.computed(() => ({}));
    }
    return vue.computed(
      () => {
        var _a;
        return fromPairs(
          Object.entries((_a = instance.proxy) == null ? void 0 : _a.$attrs).filter(
            ([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))
          )
        );
      }
    );
  };

  const defaultNamespace = "vs";
  const statePrefix = "is-";
  const _bem = (namespace, block, blockSuffix, element, modifier) => {
    let cls = `${namespace}-${block}`;
    if (blockSuffix) {
      cls += `-${blockSuffix}`;
    }
    if (element) {
      cls += `__${element}`;
    }
    if (modifier) {
      cls += `--${modifier}`;
    }
    return cls;
  };
  const namespaceContextKey = Symbol("namespaceContextKey");
  const useGetDerivedNamespace = (namespaceOverrides) => {
    const derivedNamespace = namespaceOverrides || vue.inject(namespaceContextKey, vue.ref(defaultNamespace));
    const namespace = vue.computed(() => {
      return vue.unref(derivedNamespace) || defaultNamespace;
    });
    return namespace;
  };
  const useNamespace = (block, namespaceOverrides) => {
    const namespace = useGetDerivedNamespace(namespaceOverrides);
    const b = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
    const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
    const m = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
    const be = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
    const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
    const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
    const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
    const is = (name, ...args) => {
      const state = args.length >= 1 ? args[0] : true;
      return name && state ? `${statePrefix}${name}` : "";
    };
    const cssVar = (object) => {
      const styles = {};
      for (const key in object) {
        if (object[key]) {
          styles[`--${namespace.value}-${key}`] = object[key];
        }
      }
      return styles;
    };
    const cssVarBlock = (object) => {
      const styles = {};
      for (const key in object) {
        if (object[key]) {
          styles[`--${namespace.value}-${block}-${key}`] = object[key];
        }
      }
      return styles;
    };
    const cssVarName = (name) => `--${namespace.value}-${name}`;
    const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
    return {
      namespace,
      b,
      e,
      m,
      be,
      em,
      bm,
      bem,
      is,
      cssVar,
      cssVarName,
      cssVarBlock,
      cssVarBlockName
    };
  };

  const useVuesaxBaseComponent = (color) => {
    const ns = useNamespace("component");
    const className = vue.computed(() => {
      return vuesaxColors.includes(vue.unref(color)) ? ns.m(vue.unref(color)) : "";
    });
    const isColor = vue.computed(() => !!vue.unref(color) && ns.m(ns.is("color")) || "");
    return [vue.unref(className), vue.unref(isColor)];
  };

  const useProp = (name) => {
    const vm = vue.getCurrentInstance();
    return vue.computed(() => {
      var _a, _b;
      return (_b = vue.unref(((_a = vm.proxy) == null ? void 0 : _a.$props)[name])) != null ? _b : void 0;
    });
  };

  const useSizeProp = buildProp({
    type: String,
    values: componentSizes,
    required: false
  });
  const useSize = (fallback, ignore = {}) => {
    const emptyRef = vue.ref(void 0);
    const size = ignore.prop ? emptyRef : useProp("size");
    return vue.computed(() => size.value || vue.unref(fallback) || "");
  };
  const useDisabled = (fallback) => {
    const disabled = useProp("disabled");
    return vue.computed(() => disabled.value || vue.unref(fallback) || false);
  };
  const useColorProp = buildProp({
    type: String,
    values: vuesaxColors,
    validator: isValidComponentColor
  });
  const useColor = (fallback) => {
    const color = useProp("color");
    return vue.computed(() => color.value || vue.unref(fallback));
  };

  function useCursor(input) {
    const selectionRef = vue.ref();
    function recordCursor() {
      if (input.value == void 0)
        return;
      const { selectionStart, selectionEnd, value } = input.value;
      if (selectionStart == null || selectionEnd == null)
        return;
      const beforeTxt = value.slice(0, Math.max(0, selectionStart));
      const afterTxt = value.slice(Math.max(0, selectionEnd));
      selectionRef.value = {
        selectionStart,
        selectionEnd,
        value,
        beforeTxt,
        afterTxt
      };
    }
    function setCursor() {
      if (input.value == void 0 || selectionRef.value == void 0)
        return;
      const { value } = input.value;
      const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
      if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
        return;
      let startPos = value.length;
      if (value.endsWith(afterTxt)) {
        startPos = value.length - afterTxt.length;
      } else if (value.startsWith(beforeTxt)) {
        startPos = beforeTxt.length;
      } else {
        const beforeLastChar = beforeTxt[selectionStart - 1];
        const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
        if (newIndex !== -1) {
          startPos = newIndex + 1;
        }
      }
      input.value.setSelectionRange(startPos, startPos);
    }
    return [recordCursor, setCursor];
  }

  function useTimeout() {
    let timeoutHandle;
    const registerTimeout = (fn, delay) => {
      cancelTimeout();
      timeoutHandle = setTimeout(fn, delay);
    };
    const cancelTimeout = () => clearTimeout(timeoutHandle);
    tryOnScopeDispose(() => cancelTimeout());
    return {
      registerTimeout,
      cancelTimeout
    };
  }

  const useDelayedToggleProps = buildProps({
    showAfter: {
      type: Number,
      validator: (value) => isNumber(value) && value >= 0,
      default: 0
    },
    hideAfter: {
      type: Number,
      validator: (value) => isNumber(value) && value >= 0,
      default: 200
    },
    autoClose: {
      type: Number,
      default: 0
    }
  });
  const useDelayedToggle = ({
    showAfter,
    hideAfter,
    autoClose,
    open,
    close
  }) => {
    const { registerTimeout } = useTimeout();
    const {
      registerTimeout: registerTimeoutForAutoClose,
      cancelTimeout: cancelTimeoutForAutoClose
    } = useTimeout();
    const onOpen = (event) => {
      registerTimeout(() => {
        open(event);
        const _autoClose = vue.unref(autoClose);
        if (isNumber(_autoClose) && _autoClose > 0) {
          registerTimeoutForAutoClose(() => {
            close(event);
          }, _autoClose);
        }
      }, vue.unref(showAfter));
    };
    const onClose = (event) => {
      cancelTimeoutForAutoClose();
      registerTimeout(() => {
        close(event);
      }, vue.unref(hideAfter));
    };
    return {
      onOpen,
      onClose
    };
  };

  const useDeprecated = ({ scope, type = "API", from, version, replacement, ref }, condition) => {
    vue.watch(
      () => vue.unref(condition),
      (val) => {
      },
      {
        immediate: true
      }
    );
  };

  const useDraggable = (targetRef, dragRef, draggable) => {
    let transform = {
      offsetX: 0,
      offsetY: 0
    };
    const onMousedown = (e) => {
      const downX = e.clientX;
      const downY = e.clientY;
      const { offsetX, offsetY } = transform;
      const targetRect = targetRef.value.getBoundingClientRect();
      const targetLeft = targetRect.left;
      const targetTop = targetRect.top;
      const targetWidth = targetRect.width;
      const targetHeight = targetRect.height;
      const clientWidth = document.documentElement.clientWidth;
      const clientHeight = document.documentElement.clientHeight;
      const minLeft = -targetLeft + offsetX;
      const minTop = -targetTop + offsetY;
      const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
      const maxTop = clientHeight - targetTop - targetHeight + offsetY;
      const onMousemove = (e2) => {
        const moveX = Math.min(
          Math.max(offsetX + e2.clientX - downX, minLeft),
          maxLeft
        );
        const moveY = Math.min(
          Math.max(offsetY + e2.clientY - downY, minTop),
          maxTop
        );
        transform = {
          offsetX: moveX,
          offsetY: moveY
        };
        targetRef.value.style.transform = `translate(${addUnit(
        moveX
      )}, ${addUnit(moveY)})`;
      };
      const onMouseup = () => {
        document.removeEventListener("mousemove", onMousemove);
        document.removeEventListener("mouseup", onMouseup);
      };
      document.addEventListener("mousemove", onMousemove);
      document.addEventListener("mouseup", onMouseup);
    };
    const onDraggable = () => {
      if (dragRef.value && targetRef.value) {
        dragRef.value.addEventListener("mousedown", onMousedown);
      }
    };
    const offDraggable = () => {
      if (dragRef.value && targetRef.value) {
        dragRef.value.removeEventListener("mousedown", onMousedown);
      }
    };
    vue.onMounted(() => {
      vue.watchEffect(() => {
        if (draggable.value) {
          onDraggable();
        } else {
          offDraggable();
        }
      });
    });
    vue.onBeforeUnmount(() => {
      offDraggable();
    });
  };

  let registeredEscapeHandlers = [];
  const cachedHandler = (e) => {
    const event = e;
    if (event.key === EVENT_CODE.esc) {
      registeredEscapeHandlers.forEach(
        (registeredHandler) => registeredHandler(event)
      );
    }
  };
  const useEscapeKeydown = (handler) => {
    vue.onMounted(() => {
      if (registeredEscapeHandlers.length === 0) {
        document.addEventListener("keydown", cachedHandler);
      }
      if (isClient)
        registeredEscapeHandlers.push(handler);
    });
    vue.onBeforeUnmount(() => {
      registeredEscapeHandlers = registeredEscapeHandlers.filter(
        (registeredHandler) => registeredHandler !== handler
      );
      if (registeredEscapeHandlers.length === 0) {
        if (isClient)
          document.removeEventListener("keydown", cachedHandler);
      }
    });
  };

  const sides = ["top", "right", "bottom", "left"];
  const alignments = ["start", "end"];
  sides.reduce(
    (acc, side) => acc.concat(side, `${side}-${alignments[0]}`, `${side}-${alignments[1]}`),
    []
  );
  const min = Math.min;
  const max = Math.max;
  const round = Math.round;
  const createCoords = (v) => ({ x: v, y: v });
  const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  const oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp(start, value, end) {
    return max(start, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  function getSideAxis(placement) {
    return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl = false) {
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [
      getOppositeAlignmentPlacement(placement),
      oppositePlacement,
      getOppositeAlignmentPlacement(oppositePlacement)
    ];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(
      /start|end/g,
      (alignment) => oppositeAlignmentMap[alignment]
    );
  }
  function getSideList(side, isStart, rtl) {
    const lr = ["left", "right"];
    const rl = ["right", "left"];
    const tb = ["top", "bottom"];
    const bt = ["bottom", "top"];
    switch (side) {
      case "top":
      case "bottom":
        if (rtl)
          return isStart ? rl : lr;
        return isStart ? lr : rl;
      case "left":
      case "right":
        return isStart ? tb : bt;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => `${side}-${alignment}`);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(
      /left|right|bottom|top/g,
      (side) => oppositeSideMap[side]
    );
  }
  function expandPaddingObject(padding) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...padding };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : { top: padding, right: padding, bottom: padding, left: padding };
  }
  function rectToClientRect(rect) {
    return {
      ...rect,
      top: rect.y,
      left: rect.x,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    };
  }

  const arrow$2 = (options) => ({
    name: "arrow",
    options,
    async fn(state) {
      var _a, _b;
      const { x, y, placement, rects, platform, elements, middlewareData } = state;
      const { element, padding = 0 } = evaluate(options, state) || {};
      const htmlElement = unrefElement(element);
      if (htmlElement == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = { x, y };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = await platform.getDimensions(htmlElement);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await ((_a = platform.getOffsetParent) == null ? void 0 : _a.call(platform, htmlElement));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !await ((_b = platform.isElement) == null ? void 0 : _b.call(platform, arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset = clamp(min$1, center, max);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset,
          centerOffset: center - offset - alignmentOffset,
          ...shouldAddOffset && { alignmentOffset }
        },
        reset: shouldAddOffset
      };
    }
  });

  async function detectOverflow(state, options = {}) {
    var _a, _b, _c, _d, _e, _f;
    const { x, y, platform, rects, elements, strategy } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(
      await platform.getClippingRect({
        element: ((_b = await ((_a = platform.isElement) == null ? void 0 : _a.call(platform, element))) != null ? _b : true) ? element : element.contextElement || await ((_c = platform.getDocumentElement) == null ? void 0 : _c.call(platform, elements.floating)),
        boundary,
        rootBoundary,
        strategy
      })
    );
    const rect = elementContext === "floating" ? { ...rects.floating, x, y } : rects.reference;
    const offsetParent = await ((_d = platform.getOffsetParent) == null ? void 0 : _d.call(platform, elements.floating));
    const offsetScale = await ((_e = platform.isElement) == null ? void 0 : _e.call(platform, offsetParent)) ? await ((_f = platform.getScale) == null ? void 0 : _f.call(platform, offsetParent)) || { x: 1, y: 1 } : { x: 1, y: 1 };
    const elementClientRect = rectToClientRect(
      platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect,
        offsetParent,
        strategy
      }) : rect
    );
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }

  const flip$1 = (options = {}) => ({
    name: "flip",
    options,
    async fn(state) {
      var _a, _b, _c, _d, _e, _f;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_a = middlewareData.arrow) == null ? void 0 : _a.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await ((_b = platform.isRTL) == null ? void 0 : _b.call(platform, elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(
          ...getOppositeAxisPlacements(
            initialPlacement,
            flipAlignment,
            fallbackAxisSideDirection,
            rtl
          )
        );
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_c = middlewareData.flip) == null ? void 0 : _c.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, { placement, overflows }];
      if (!overflows.every((side2) => side2 <= 0)) {
        const nextIndex = (((_d = middlewareData.flip) == null ? void 0 : _d.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_e = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _e.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              const placement2 = (_f = overflowsData.map(
                (d) => [
                  d.placement,
                  d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)
                ]
              ).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _f[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  });

  async function convertValueToCoords(state, options) {
    var _a;
    const { placement, platform, elements } = state;
    const rtl = await ((_a = platform.isRTL) == null ? void 0 : _a.call(platform, elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === "number" ? { mainAxis: rawValue, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...rawValue };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? { x: crossAxis * crossAxisMulti, y: mainAxis * mainAxisMulti } : { x: mainAxis * mainAxisMulti, y: crossAxis * crossAxisMulti };
  }
  const offset = (options = 0) => ({
    name: "offset",
    options,
    async fn(state) {
      var _a, _b;
      const { x, y, placement, middlewareData } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_a = middlewareData.offset) == null ? void 0 : _a.placement) && ((_b = middlewareData.arrow) == null ? void 0 : _b.alignmentOffset)) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  });

  const shift$1 = (options = {}) => ({
    name: "shift",
    options,
    async fn(state) {
      const { x, y, placement } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = { fn: ({ x: x2, y: y2 }) => ({ x: x2, y: y2 }) },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = { x, y };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  });
  const limitShift$1 = (options = {}) => ({
    options,
    fn(state) {
      var _a, _b;
      const { x, y, placement, rects, middlewareData } = state;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = { x, y };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset, state);
      const computedOffset = typeof rawOffset === "number" ? { mainAxis: rawOffset, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...rawOffset };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_a = middlewareData.offset) == null ? void 0 : _a[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_b = middlewareData.offset) == null ? void 0 : _b[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  });

  function computeCoordsFromPlacement({ reference, floating }, placement, rtl) {
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = { x: commonX, y: reference.y - floating.height };
        break;
      case "bottom":
        coords = { x: commonX, y: reference.y + reference.height };
        break;
      case "right":
        coords = { x: reference.x + reference.width, y: commonY };
        break;
      case "left":
        coords = { x: reference.x - floating.width, y: commonY };
        break;
      default:
        coords = { x: reference.x, y: reference.y };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }

  const computePosition$1 = async (reference, floating, config) => {
    var _a;
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await ((_a = platform.isRTL) == null ? void 0 : _a.call(platform, floating));
    let rects = await platform.getElementRects({ reference, floating, strategy });
    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i = 0; i < validMiddleware.length; i++) {
      const { name, fn } = validMiddleware[i];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = await fn({
        x,
        y,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform,
        elements: { reference, floating }
      });
      x = nextX != null ? nextX : x;
      y = nextY != null ? nextY : y;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i = -1;
      }
    }
    return {
      x,
      y,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };

  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node) {
    var _a;
    return ((_a = node == null ? void 0 : node.ownerDocument) == null ? void 0 : _a.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _a;
    return (_a = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _a.documentElement;
  }
  function isNode(value) {
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement$1(value) {
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement(value) {
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  function isOverflowElement(element) {
    const { overflow, overflowX, overflowY, display } = getComputedStyle$1(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
  }
  function isTableElement(element) {
    return ["table", "td", "th"].includes(getNodeName(element));
  }
  function isContainingBlock(element) {
    const webkit = isWebKit();
    const css = getComputedStyle$1(element);
    return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some(
      (value) => (css.willChange || "").includes(value)
    ) || ["paint", "layout", "strict", "content"].some(
      (value) => (css.contain || "").includes(value)
    );
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports)
      return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  function isLastTraversableNode(node) {
    return ["html", "body", "#document"].includes(getNodeName(node));
  }
  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement$1(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.pageXOffset,
      scrollTop: element.pageYOffset
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === "html") {
      return node;
    }
    const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list = [], traverseIframes = true) {
    var _a;
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_a = node.ownerDocument) == null ? void 0 : _a.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      return list.concat(
        win,
        win.visualViewport || [],
        isOverflowElement(scrollableAncestor) ? scrollableAncestor : [],
        win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []
      );
    }
    return list.concat(
      scrollableAncestor,
      getOverflowAncestors(scrollableAncestor, [], traverseIframes)
    );
  }

  function unwrapElement$1(element) {
    return !isElement$2(element) ? element.contextElement : element;
  }

  function getCssDimensions(element) {
    const css = getComputedStyle(element);
    let width = Number.parseFloat(css.width) || 0;
    let height = Number.parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }

  function getScale(element) {
    const domElement = unwrapElement$1(element);
    if (!isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const { width, height, $ } = getCssDimensions(domElement);
    let x = ($ ? round(rect.width) : rect.width) / width;
    let y = ($ ? round(rect.height) : rect.height) / height;
    if (!x || !Number.isFinite(x)) {
      x = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x,
      y
    };
  }

  function isElement(value) {
    return value instanceof Element || value instanceof getWindow(value).Element;
  }

  const noOffsets = createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed = false, floatingOffsetParent) {
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
      return false;
    }
    return isFixed;
  }

  function getBoundingClientRect(element, includeScale = false, isFixedStrategy = false, offsetParent) {
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement$1(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(
      domElement,
      isFixedStrategy,
      offsetParent
    ) ? getVisualOffsets(domElement) : createCoords(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentIFrame = win.frameElement;
      while (currentIFrame && offsetParent && offsetWin !== win) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle$1(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + Number.parseFloat(css.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + Number.parseFloat(css.paddingTop)) * iframeScale.y;
        x *= iframeScale.x;
        y *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x += left;
        y += top;
        currentIFrame = getWindow(currentIFrame).frameElement;
      }
    }
    return rectToClientRect({ width, height, x, y });
  }

  function convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    if (offsetParent === documentElement) {
      return rect;
    }
    let scroll = { scrollLeft: 0, scrollTop: 0 };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
    };
  }

  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }

  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
  }

  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max(
      html.scrollWidth,
      html.clientWidth,
      body.scrollWidth,
      body.clientWidth
    );
    const height = max(
      html.scrollHeight,
      html.clientHeight,
      body.scrollHeight,
      body.clientHeight
    );
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if (getComputedStyle$1(body).direction === "rtl") {
      x += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
      width,
      height,
      x,
      y
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        ...clippingAncestor,
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element, cache) {
    const cachedResult = cache == null ? void 0 : cache.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, [], false).filter(
      (el) => isElement(el) && getNodeName(el) !== "body"
    );
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle$1(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle$1(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(
        currentContainingBlockComputedStyle.position
      ) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache == null ? void 0 : cache.set(element, result);
    return result;
  }
  function getClippingRect({
    element,
    boundary,
    rootBoundary,
    strategy
  }) {
    const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : concat([], boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce(
      (accRect, clippingAncestor) => {
        const rect = getClientRectFromClippingAncestor(
          element,
          clippingAncestor,
          strategy
        );
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      },
      getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy)
    );
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }

  function getDimensions(element) {
    const { width, height } = getCssDimensions(element);
    return { width, height };
  }

  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = { scrollLeft: 0, scrollTop: 0 };
    const offsets = createCoords(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(
          offsetParent,
          true,
          isFixed,
          offsetParent
        );
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    return element.offsetParent;
  }
  function getOffsetParent(element, polyfill) {
    const window = getWindow(element);
    if (!isHTMLElement(element)) {
      return window;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
      return window;
    }
    return offsetParent || getContainingBlock(element) || window;
  }

  const getElementRects = async function({ reference, floating, strategy }) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(
        reference,
        await getOffsetParentFn(floating),
        strategy
      ),
      floating: { x: 0, y: 0, ...await getDimensionsFn(floating) }
    };
  };

  function isRTL(element) {
    return getComputedStyle(element).direction === "rtl";
  }

  const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };

  const shift = shift$1;
  const flip = flip$1;
  const arrow$1 = arrow$2;
  const limitShift = limitShift$1;

  const computePosition = (reference, floating, options) => {
    const cache = /* @__PURE__ */ new Map();
    const mergedOptions = { platform, ...options };
    const platformWithCache = { ...mergedOptions.platform, _c: cache };
    return computePosition$1(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };

  function isComponentPublicInstance(target) {
    return target != null && Object.prototype.hasOwnProperty.call(target, "$el");
  }
  function unwrapElement(target) {
    if (isComponentPublicInstance(target)) {
      const element = target.$el;
      return isNode(element) && getNodeName(element) === "#comment" ? null : element;
    }
    return target;
  }

  function arrow(options) {
    return {
      name: "arrow",
      options,
      fn(args) {
        const element = unwrapElement(vue.unref(options.element));
        if (element == null) {
          return {};
        }
        return arrow$1({ element, padding: options.padding }).fn(args);
      }
    };
  }

  function getDPR(element) {
    if (typeof window === "undefined") {
      return 1;
    }
    const win = element.ownerDocument.defaultView || window;
    return win.devicePixelRatio || 1;
  }

  function roundByDPR(element, value) {
    const dpr = getDPR(element);
    return Math.round(value * dpr) / dpr;
  }

  function useFloating(reference, floating, options = {}) {
    const whileElementsMountedOption = options.whileElementsMounted;
    const openOption = vue.computed(() => {
      var _a;
      return (_a = vue.unref(options.open)) != null ? _a : true;
    });
    const fitOption = vue.computed(() => {
      var _a;
      return (_a = vue.unref(options.fit)) != null ? _a : false;
    });
    const middlewareOption = vue.computed(() => vue.unref(options.middleware));
    const placementOption = vue.computed(() => {
      var _a;
      return (_a = vue.unref(options.placement)) != null ? _a : "bottom";
    });
    const strategyOption = vue.computed(() => {
      var _a;
      return (_a = vue.unref(options.strategy)) != null ? _a : "absolute";
    });
    const transformOption = vue.computed(() => {
      var _a;
      return (_a = vue.unref(options.transform)) != null ? _a : true;
    });
    const referenceElement = vue.computed(() => unwrapElement(reference.value));
    const floatingElement = vue.computed(() => unwrapElement(floating.value));
    const x = vue.ref(0);
    const y = vue.ref(0);
    const strategy = vue.ref(strategyOption.value);
    const placement = vue.ref(placementOption.value);
    const middlewareData = vue.shallowRef({});
    const isPositioned = vue.ref(false);
    const floatingStyles = vue.computed(() => {
      const initialStyles = {
        position: strategy.value,
        left: "0",
        top: "0"
      };
      if (!floatingElement.value) {
        return initialStyles;
      }
      const xVal = roundByDPR(floatingElement.value, x.value);
      const yVal = roundByDPR(floatingElement.value, y.value);
      if (transformOption.value) {
        return {
          ...initialStyles,
          transform: `translate(${xVal}px, ${yVal}px)`,
          ...getDPR(floatingElement.value) >= 1.5 && {
            willChange: "transform"
          }
        };
      }
      return {
        position: strategy.value,
        left: `${xVal}px`,
        top: `${yVal}px`
      };
    });
    let whileElementsMountedCleanup;
    function update() {
      if (referenceElement.value == null || floatingElement.value == null) {
        return;
      }
      if (fitOption.value) {
        floatingElement.value.style.width = `${referenceElement.value.getBoundingClientRect().width}px`;
      }
      computePosition(referenceElement.value, floatingElement.value, {
        middleware: middlewareOption.value,
        placement: placementOption.value,
        strategy: strategyOption.value
      }).then((position) => {
        x.value = position.x;
        y.value = position.y;
        strategy.value = position.strategy;
        placement.value = position.placement;
        middlewareData.value = position.middlewareData;
        isPositioned.value = true;
      });
    }
    function cleanup() {
      if (typeof whileElementsMountedCleanup === "function") {
        whileElementsMountedCleanup();
        whileElementsMountedCleanup = void 0;
      }
    }
    function attach() {
      cleanup();
      if (whileElementsMountedOption === void 0) {
        update();
        return;
      }
      if (referenceElement.value != null && floatingElement.value != null) {
        whileElementsMountedCleanup = whileElementsMountedOption(
          referenceElement.value,
          floatingElement.value,
          update
        );
        return;
      }
    }
    function reset() {
      if (!openOption.value) {
        isPositioned.value = false;
      }
    }
    vue.onMounted(() => {
      useEventListener("resize", attach, true);
      useEventListener("scroll", attach, true);
      vue.watch([middlewareOption, placementOption, strategyOption], update, {
        flush: "sync"
      });
      vue.watch([referenceElement, floatingElement], attach, { flush: "sync" });
      vue.watch(openOption, reset, { flush: "sync" });
    });
    if (vue.getCurrentScope()) {
      vue.onScopeDispose(cleanup);
    }
    return {
      x: vue.shallowReadonly(x),
      y: vue.shallowReadonly(y),
      strategy: vue.shallowReadonly(strategy),
      placement: vue.shallowReadonly(placement),
      middlewareData: vue.shallowReadonly(middlewareData),
      isPositioned: vue.shallowReadonly(isPositioned),
      floatingStyles,
      update
    };
  }

  const useFocus = (el) => {
    return {
      focus: () => {
        var _a, _b;
        (_b = (_a = el.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
      }
    };
  };

  const FORWARD_REF_INJECTION_KEY = Symbol("ForwardRef");
  const useForwardRef = (forwardRef) => {
    const setForwardRef = (el) => {
      forwardRef.value = el;
    };
    vue.provide(FORWARD_REF_INJECTION_KEY, {
      setForwardRef
    });
  };
  const useForwardRefDirective = (setForwardRef) => {
    return {
      mounted(el) {
        setForwardRef(el);
      },
      updated(el) {
        setForwardRef(el);
      },
      unmounted() {
        setForwardRef(null);
      }
    };
  };

  const avatarGroupContextKey = Symbol(
    "AvatarGroupContextKey"
  );

  const checkboxGroupContextKey = Symbol("CheckboxGroupContextKey");

  const configProviderContextKey = Symbol();

  const focusAfterTrapped = "focus-trap.focus-after-trapped";
  const focusAfterReleased = "focus-trap.focus-after-released";
  const focusoutPrevented = "focus-trap.focusout-prevented";
  const focusAfterTrappedOpts = {
    cancelable: true,
    bubbles: false
  };
  const focusoutPreventedOpts = {
    cancelable: true,
    bubbles: false
  };
  const onTrapFocusEvent = "focusAfterTrapped";
  const onReleaseFocusEvent = "focusAfterReleased";
  const focusTrapInjectionKey = Symbol("FocusTrap");

  const paginationContextKey = Symbol("PaginationKey");

  const popperContextKey = Symbol("popper");
  const popperContentContextKey = Symbol("popper-content");

  const rowContextKey = Symbol("RowContextKey");

  const scrollbarContextKey = Symbol(
    "ScrollbarContextKey"
  );

  const sidebarContextKey = Symbol("sidebar");

  const tableContextKey = Symbol("table-context");

  var English = {
    name: "en",
    vs: {
      colorpicker: {
        confirm: "OK",
        clear: "Clear",
        defaultLabel: "color picker",
        description: "current color is {color}. press enter to select a new color."
      },
      datepicker: {
        now: "Now",
        today: "Today",
        cancel: "Cancel",
        clear: "Clear",
        confirm: "OK",
        dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
        monthTablePrompt: "Use the arrow keys and enter to select the month",
        yearTablePrompt: "Use the arrow keys and enter to select the year",
        selectedDate: "Selected date",
        selectDate: "Select date",
        selectTime: "Select time",
        startDate: "Start Date",
        startTime: "Start Time",
        endDate: "End Date",
        endTime: "End Time",
        prevYear: "Previous Year",
        nextYear: "Next Year",
        prevMonth: "Previous Month",
        nextMonth: "Next Month",
        year: "",
        month1: "January",
        month2: "February",
        month3: "March",
        month4: "April",
        month5: "May",
        month6: "June",
        month7: "July",
        month8: "August",
        month9: "September",
        month10: "October",
        month11: "November",
        month12: "December",
        week: "week",
        weeks: {
          sun: "Sun",
          mon: "Mon",
          tue: "Tue",
          wed: "Wed",
          thu: "Thu",
          fri: "Fri",
          sat: "Sat"
        },
        weeksFull: {
          sun: "Sunday",
          mon: "Monday",
          tue: "Tuesday",
          wed: "Wednesday",
          thu: "Thursday",
          fri: "Friday",
          sat: "Saturday"
        },
        months: {
          jan: "Jan",
          feb: "Feb",
          mar: "Mar",
          apr: "Apr",
          may: "May",
          jun: "Jun",
          jul: "Jul",
          aug: "Aug",
          sep: "Sep",
          oct: "Oct",
          nov: "Nov",
          dec: "Dec"
        }
      },
      inputNumber: {
        decrease: "decrease number",
        increase: "increase number"
      },
      select: {
        loading: "Loading",
        noMatch: "No matching data",
        noData: "No data",
        placeholder: "Select"
      },
      dropdown: {
        toggleDropdown: "Toggle Dropdown"
      },
      cascader: {
        noMatch: "No matching data",
        loading: "Loading",
        placeholder: "Select",
        noData: "No data"
      },
      pagination: {
        goto: "Go to",
        pagesize: "/page",
        total: "Total {total}",
        pageClassifier: "",
        deprecationWarning: "Deprecated usages detected, please refer to the pagination documentation for more details"
      },
      dialog: {
        close: "Close this dialog"
      },
      drawer: {
        close: "Close this dialog"
      },
      messagebox: {
        title: "Message",
        confirm: "OK",
        cancel: "Cancel",
        error: "Illegal input",
        close: "Close this dialog"
      },
      upload: {
        deleteTip: "press delete to remove",
        delete: "Delete",
        preview: "Preview",
        continue: "Continue"
      },
      slider: {
        defaultLabel: "slider between {min} and {max}",
        defaultRangeStartLabel: "pick start value",
        defaultRangeEndLabel: "pick end value"
      },
      table: {
        noMatch: "No matching data",
        emptyText: "No Data",
        confirmFilter: "Confirm",
        resetFilter: "Reset",
        clearFilter: "All",
        sumText: "Sum"
      },
      tree: {
        emptyText: "No Data"
      },
      transfer: {
        noMatch: "No matching data",
        noData: "No data",
        titles: ["List 1", "List 2"],
        filterPlaceholder: "Enter keyword",
        noCheckedFormat: "{total} items",
        hasCheckedFormat: "{checked}/{total} checked"
      },
      image: {
        error: "FAILED"
      },
      pageHeader: {
        title: "Back"
      },
      popconfirm: {
        confirmButtonText: "Yes",
        cancelButtonText: "No"
      }
    }
  };

  const buildTranslator = (locale) => (path, option) => translate(path, option, vue.unref(locale));
  const translate = (path, option, locale) => get(locale, path, path).replace(
    /\{(\w+)\}/g,
    (_, key) => {
      var _a;
      return `${(_a = option == null ? void 0 : option[key]) != null ? _a : `{${key}}`}`;
    }
  );
  const buildLocaleContext = (locale) => {
    const lang = vue.computed(() => vue.unref(locale).name);
    const localeRef = vue.isRef(locale) ? locale : vue.ref(locale);
    return {
      lang,
      locale: localeRef,
      t: buildTranslator(locale)
    };
  };
  const localeContextKey = Symbol("localeContextKey");
  const useLocale = (localeOverrides) => {
    const locale = localeOverrides || vue.inject(localeContextKey, vue.ref());
    return buildLocaleContext(vue.computed(() => locale.value || English));
  };

  const zIndex = vue.ref(0);
  const defaultInitialZIndex = 2e3;
  const zIndexContextKey = Symbol("zIndexContextKey");
  const useZIndex = (zIndexOverrides) => {
    const zIndexInjection = zIndexOverrides || vue.inject(zIndexContextKey, void 0);
    const initialZIndex = vue.computed(() => {
      const zIndexFromInjection = vue.unref(zIndexInjection);
      return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
    });
    const currentZIndex = vue.computed(() => initialZIndex.value + zIndex.value);
    const nextZIndex = () => {
      zIndex.value++;
      return currentZIndex.value;
    };
    return {
      initialZIndex,
      currentZIndex,
      nextZIndex
    };
  };

  const globalConfig = vue.ref();
  function useGlobalConfig(key, defaultValue = void 0) {
    const config = vue.getCurrentInstance() ? vue.inject(configProviderContextKey, globalConfig) : globalConfig;
    if (key) {
      return vue.computed(() => {
        var _a, _b;
        return (_b = (_a = config.value) == null ? void 0 : _a[key]) != null ? _b : defaultValue;
      });
    } else {
      return config;
    }
  }
  const useGlobalComponentSettings = (block) => {
    const config = useGlobalConfig();
    const ns = useNamespace(
      block,
      vue.computed(() => {
        var _a;
        return ((_a = config.value) == null ? void 0 : _a.namespace) || defaultNamespace;
      })
    );
    const locale = useLocale(vue.computed(() => {
      var _a;
      return (_a = config.value) == null ? void 0 : _a.locale;
    }));
    const zIndex = useZIndex(
      vue.computed(() => {
        var _a;
        return ((_a = config.value) == null ? void 0 : _a.zIndex) || defaultInitialZIndex;
      })
    );
    return {
      ns,
      locale,
      zIndex
    };
  };
  const provideGlobalConfig = (config, app, global = false) => {
    var _a;
    const inSetup = !!vue.getCurrentInstance();
    const oldConfig = inSetup ? useGlobalConfig() : void 0;
    const provideFn = (_a = app == null ? void 0 : app.provide) != null ? _a : inSetup ? vue.provide : void 0;
    if (!provideFn) {
      return;
    }
    const context = vue.computed(() => {
      const cfg = vue.unref(config);
      if (!(oldConfig == null ? void 0 : oldConfig.value))
        return cfg;
      return mergeConfig(oldConfig.value, cfg);
    });
    provideFn(configProviderContextKey, context);
    provideFn(
      localeContextKey,
      vue.computed(() => context.value.locale)
    );
    provideFn(
      namespaceContextKey,
      vue.computed(() => context.value.namespace)
    );
    provideFn(
      zIndexContextKey,
      vue.computed(() => context.value.zIndex)
    );
    if (global || !globalConfig.value) {
      globalConfig.value = context.value;
    }
    return context;
  };
  const mergeConfig = (a, b) => {
    var _a;
    const keys = [.../* @__PURE__ */ new Set([...keysOf(a), ...keysOf(b)])];
    const obj = {};
    for (const key of keys) {
      obj[key] = (_a = b[key]) != null ? _a : a[key];
    }
    return obj;
  };

  const useGroupInject = (key) => {
    const instance = vue.getCurrentInstance();
    if (!instance) {
      throw new Error(
        "useInject hook must be called inside setup function or <script setup>"
      );
    }
    const parent = vue.inject(key, void 0);
    const index = vue.computed(() => (parent == null ? void 0 : parent.children.indexOf(instance)) || 0);
    parent == null ? void 0 : parent.insert(instance);
    vue.onUnmounted(() => {
      parent == null ? void 0 : parent.remove(instance);
    });
    return parent ? { ...parent, index } : void 0;
  };

  const useGroupProvide = (key, data) => {
    const children = vue.reactive([]);
    const insert = (child) => {
      children.push(child);
    };
    const remove = (child) => {
      const index = children.indexOf(child);
      children.splice(index, 1);
    };
    vue.provide(key, {
      ...data,
      children,
      insert,
      remove
    });
    return {
      children,
      insert,
      remove
    };
  };

  const defaultIdInjection = {
    prefix: Math.floor(Math.random() * 1e4),
    current: 0
  };
  const ID_INJECTION_KEY = Symbol("IdInjection");
  const useIdInjection = () => {
    return vue.getCurrentInstance() ? vue.inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
  };
  const useId = (deterministicId) => {
    const idInjection = useIdInjection();
    const namespace = useGlobalConfig("namespace", defaultNamespace);
    const idRef = vue.computed(
      () => vue.unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`
    );
    return idRef;
  };

  const useDelayedRender = ({
    indicator,
    intermediateIndicator,
    shouldSetIntermediate = () => true,
    beforeShow,
    afterShow,
    afterHide,
    beforeHide
  }) => {
    vue.watch(
      () => vue.unref(indicator),
      (val) => {
        if (val) {
          beforeShow == null ? void 0 : beforeShow();
          vue.nextTick(() => {
            if (!vue.unref(indicator))
              return;
            if (shouldSetIntermediate("show")) {
              intermediateIndicator.value = true;
            }
          });
        } else {
          beforeHide == null ? void 0 : beforeHide();
          vue.nextTick(() => {
            if (vue.unref(indicator))
              return;
            if (shouldSetIntermediate("hide")) {
              intermediateIndicator.value = false;
            }
          });
        }
      }
    );
    vue.watch(
      () => intermediateIndicator.value,
      (val) => {
        if (val) {
          afterShow == null ? void 0 : afterShow();
        } else {
          afterHide == null ? void 0 : afterHide();
        }
      }
    );
  };

  const useLockscreen = (trigger) => {
    if (!vue.isRef(trigger)) {
      throwError(
        "[useLockscreen]",
        "You need to pass a ref param to this function"
      );
    }
    const ns = useNamespace("popup");
    const hiddenCls = vue.computed(() => ns.bm("parent", "hidden"));
    if (!isClient || hasClass(document.body, hiddenCls.value)) {
      return;
    }
    let scrollBarWidth = 0;
    let withoutHiddenClass = false;
    let bodyWidth = "0";
    const cleanup = () => {
      setTimeout(() => {
        removeClass(document.body, hiddenCls.value);
        if (withoutHiddenClass) {
          document.body.style.width = bodyWidth;
        }
      }, 200);
    };
    vue.watch(trigger, (val) => {
      if (!val) {
        cleanup();
        return;
      }
      withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
      if (withoutHiddenClass) {
        bodyWidth = document.body.style.width;
      }
      scrollBarWidth = getScrollBarWidth(ns.namespace.value);
      const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
      const bodyOverflowY = getStyle(document.body, "overflowY");
      if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
        document.body.style.width = `calc(100% - ${scrollBarWidth}px)`;
      }
      addClass(document.body, hiddenCls.value);
    });
    vue.onScopeDispose(() => cleanup());
  };

  const modalStack = [];
  const closeModal = (e) => {
    if (modalStack.length === 0)
      return;
    if (e.code === EVENT_CODE.esc) {
      e.stopPropagation();
      const topModal = modalStack[modalStack.length - 1];
      topModal.handleClose();
    }
  };
  const useModal = (instance, visibleRef) => {
    vue.watch(visibleRef, (val) => {
      if (val) {
        modalStack.push(instance);
      } else {
        modalStack.splice(modalStack.indexOf(instance), 1);
      }
    });
  };
  if (isClient)
    useEventListener(document, "keydown", closeModal);

  const _prop = buildProp({
    type: definePropType(Boolean),
    default: null
  });
  const _event = buildProp({
    type: definePropType(Function)
  });
  const createModelToggleComposable = (name) => {
    const updateEventKey = `update:${name}`;
    const updateEventKeyRaw = `onUpdate:${name}`;
    const useModelToggleEmits2 = [updateEventKey];
    const useModelToggleProps2 = {
      [name]: _prop,
      [updateEventKeyRaw]: _event
    };
    const useModelToggle2 = ({
      indicator,
      toggleReason,
      shouldHideWhenRouteChanges,
      shouldProceed,
      processBeforeClosing,
      onShow,
      onHide
    }) => {
      const instance = vue.getCurrentInstance();
      const { emit } = instance;
      const props = instance.props;
      const hasUpdateHandler = vue.computed(
        () => isFunction(props[updateEventKeyRaw])
      );
      const isModelBindingAbsent = vue.computed(() => props[name] === null);
      const doShow = (event) => {
        if (indicator.value === true) {
          return;
        }
        indicator.value = true;
        if (toggleReason) {
          toggleReason.value = event;
        }
        if (isFunction(onShow)) {
          onShow(event);
        }
      };
      const doHide = (event) => {
        if (indicator.value === false) {
          return;
        }
        indicator.value = false;
        if (toggleReason) {
          toggleReason.value = event;
        }
        if (isFunction(onHide)) {
          onHide(event);
        }
      };
      const show = (event) => {
        if (props.disabled === true || isFunction(shouldProceed) && !shouldProceed())
          return;
        const shouldEmit = hasUpdateHandler.value && isClient;
        if (shouldEmit) {
          emit(updateEventKey, true);
        }
        if (isModelBindingAbsent.value || !shouldEmit) {
          doShow(event);
        }
      };
      const hide = (event) => {
        if (props.disabled === true || !isClient || isFunction(processBeforeClosing) && !processBeforeClosing())
          return;
        const shouldEmit = hasUpdateHandler.value && isClient;
        if (shouldEmit) {
          emit(updateEventKey, false);
        }
        if (isModelBindingAbsent.value || !shouldEmit) {
          doHide(event);
        }
      };
      const onChange = (val) => {
        if (!isBoolean(val))
          return;
        if (props.disabled && val) {
          if (hasUpdateHandler.value) {
            emit(updateEventKey, false);
          }
        } else if (indicator.value !== val) {
          if (val) {
            doShow();
          } else {
            doHide();
          }
        }
      };
      const toggle = () => {
        if (indicator.value) {
          hide();
        } else {
          show();
        }
      };
      vue.watch(() => props[name], onChange);
      if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
        vue.watch(
          () => ({
            ...instance.proxy.$route
          }),
          () => {
            if (shouldHideWhenRouteChanges.value && indicator.value) {
              hide();
            }
          }
        );
      }
      vue.onMounted(() => {
        onChange(props[name]);
      });
      return {
        hide,
        show,
        toggle,
        hasUpdateHandler
      };
    };
    return {
      useModelToggle: useModelToggle2,
      useModelToggleProps: useModelToggleProps2,
      useModelToggleEmits: useModelToggleEmits2
    };
  };
  const { useModelToggle, useModelToggleProps, useModelToggleEmits } = createModelToggleComposable("modelValue");

  const getOrderedChildren = (vm, childComponentName, children) => {
    const nodes = flattedChildren(vm.subTree).filter(
      (n) => {
        var _a;
        return vue.isVNode(n) && ((_a = n.type) == null ? void 0 : _a.name) === childComponentName && !!n.component;
      }
    );
    const uids = nodes.map((n) => n.component.uid);
    return uids.map((uid) => children[uid]).filter((p) => !!p);
  };
  const useOrderedChildren = (vm, childComponentName) => {
    const children = {};
    const orderedChildren = vue.shallowRef([]);
    const addChild = (child) => {
      children[child.uid] = child;
      orderedChildren.value = getOrderedChildren(vm, childComponentName, children);
    };
    const removeChild = (uid) => {
      delete children[uid];
      orderedChildren.value = orderedChildren.value.filter(
        (children2) => children2.uid !== uid
      );
    };
    return {
      children: orderedChildren,
      addChild,
      removeChild
    };
  };

  let cachedContainer;
  const usePopperContainerId = () => {
    const namespace = useGlobalConfig("namespace", defaultNamespace);
    const idInjection = useIdInjection();
    const id = vue.computed(() => {
      return `${namespace.value}-popper-container-${idInjection.prefix}`;
    });
    const selector = vue.computed(() => `#${id.value}`);
    return {
      id,
      selector
    };
  };
  const createContainer = (id) => {
    const container = document.createElement("div");
    container.id = id;
    document.body.appendChild(container);
    return container;
  };
  const usePopperContainer = () => {
    const { id, selector } = usePopperContainerId();
    vue.onBeforeMount(() => {
      if (!isClient)
        return;
      if (!cachedContainer && !document.body.querySelector(selector.value)) {
        cachedContainer = createContainer(id.value);
      }
    });
    return {
      id,
      selector
    };
  };

  const usePreventGlobal = (indicator, evt, cb) => {
    const prevent = (e) => {
      if (cb(e))
        e.stopImmediatePropagation();
    };
    let stop = void 0;
    vue.watch(
      () => indicator.value,
      (val) => {
        if (val) {
          stop = useEventListener(document, evt, prevent, true);
        } else {
          stop == null ? void 0 : stop();
        }
      },
      { immediate: true }
    );
  };

  const useRestoreActive = (toggle, initialFocus) => {
    let previousActive;
    vue.watch(
      () => toggle.value,
      (val) => {
        var _a, _b;
        if (val) {
          previousActive = document.activeElement;
          if (vue.isRef(initialFocus)) {
            (_b = (_a = initialFocus.value).focus) == null ? void 0 : _b.call(_a);
          }
        } else {
          {
            previousActive.focus();
          }
        }
      }
    );
  };

  const useSameTarget = (handleClick) => {
    if (!handleClick) {
      return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
    }
    let mousedownTarget = false;
    let mouseupTarget = false;
    const onClick = (e) => {
      if (mousedownTarget && mouseupTarget) {
        handleClick(e);
      }
      mousedownTarget = mouseupTarget = false;
    };
    const onMousedown = (e) => {
      mousedownTarget = e.target === e.currentTarget;
    };
    const onMouseup = (e) => {
      mouseupTarget = e.target === e.currentTarget;
    };
    return { onClick, onMousedown, onMouseup };
  };

  const useTeleport = (contentRenderer, appendToBody) => {
    const isTeleportVisible = vue.ref(false);
    if (!isClient) {
      return {
        isTeleportVisible,
        showTeleport: NOOP,
        hideTeleport: NOOP,
        renderTeleport: NOOP
      };
    }
    let $el = null;
    const showTeleport = () => {
      isTeleportVisible.value = true;
      if ($el !== null)
        return;
      $el = createGlobalNode();
    };
    const hideTeleport = () => {
      isTeleportVisible.value = false;
      if ($el !== null) {
        removeGlobalNode($el);
        $el = null;
      }
    };
    const renderTeleport = () => {
      return appendToBody.value !== true ? contentRenderer() : isTeleportVisible.value ? [vue.h(vue.Teleport, { to: $el }, contentRenderer())] : void 0;
    };
    vue.onUnmounted(hideTeleport);
    return {
      isTeleportVisible,
      showTeleport,
      hideTeleport,
      renderTeleport
    };
  };

  const useThrottleRender = (loading, throttle = 0) => {
    if (throttle === 0)
      return loading;
    const throttled = vue.ref(false);
    let timeoutHandle = 0;
    const dispatchThrottling = () => {
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
      }
      timeoutHandle = window.setTimeout(() => {
        throttled.value = loading.value;
      }, throttle);
    };
    vue.onMounted(dispatchThrottling);
    vue.watch(
      () => loading.value,
      (val) => {
        if (val) {
          dispatchThrottling();
        } else {
          throttled.value = val;
        }
      }
    );
    return throttled;
  };

  const AFTER_APPEAR = "after-appear";
  const AFTER_ENTER = "after-enter";
  const AFTER_LEAVE = "after-leave";
  const APPEAR = "appear";
  const APPEAR_CANCELLED = "appear-cancelled";
  const BEFORE_ENTER = "before-enter";
  const BEFORE_LEAVE = "before-leave";
  const ENTER = "enter";
  const ENTER_CANCELLED = "enter-cancelled";
  const LEAVE = "leave";
  const LEAVE_CANCELLED = "leave-cancelled";
  const useTransitionFallthroughEmits = [
    AFTER_APPEAR,
    AFTER_ENTER,
    AFTER_LEAVE,
    APPEAR,
    APPEAR_CANCELLED,
    BEFORE_ENTER,
    BEFORE_LEAVE,
    ENTER,
    ENTER_CANCELLED,
    LEAVE,
    LEAVE_CANCELLED
  ];
  const useTransitionFallthrough = () => {
    const { emit } = vue.getCurrentInstance();
    return {
      onAfterAppear: () => {
        emit(AFTER_APPEAR);
      },
      onAfterEnter: () => {
        emit(AFTER_ENTER);
      },
      onAfterLeave: () => {
        emit(AFTER_LEAVE);
      },
      onAppearCancelled: () => {
        emit(APPEAR_CANCELLED);
      },
      onBeforeEnter: () => {
        emit(BEFORE_ENTER);
      },
      onBeforeLeave: () => {
        emit(BEFORE_LEAVE);
      },
      onEnter: () => {
        emit(ENTER);
      },
      onEnterCancelled: () => {
        emit(ENTER_CANCELLED);
      },
      onLeave: () => {
        emit(LEAVE);
      },
      onLeaveCancelled: () => {
        emit(LEAVE_CANCELLED);
      }
    };
  };

  const version$1 = "0.2.0-beta.80";

  const makeInstaller = (components = []) => {
    const install = (app, options) => {
      if (app[INSTALLED_KEY])
        return;
      app[INSTALLED_KEY] = true;
      components.forEach((c) => app.use(c));
      if (options)
        provideGlobalConfig(options, app, true);
    };
    return {
      version: version$1,
      install
    };
  };

  const iconProps = buildProps({
    size: {
      type: definePropType([Number, String])
    },
    color: {
      type: String,
      values: vuesaxColors,
      validator: isValidComponentColor,
      default: ""
    }
  });

  var _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };

  const __default__$R = vue.defineComponent({
    name: "VsIcon"
  });
  const _sfc_main$X = vue.defineComponent({
    ...__default__$R,
    props: iconProps,
    setup(__props) {
      const props = __props;
      const ns = useNamespace("icon");
      const style = vue.computed(() => {
        const { size, color } = props;
        if (!size && !color)
          return {};
        return {
          ...ns.cssVar({
            color: getVsColor(color)
          }),
          color: `rgb(${ns.cssVarName("color")})`,
          fontSize: isUndefined(size) ? void 0 : addUnit(size)
        };
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "i",
          {
            class: vue.normalizeClass(vue.unref(ns).b()),
            style: vue.normalizeStyle(style.value)
          },
          [
            vue.renderSlot(_ctx.$slots, "default")
          ],
          6
        );
      };
    }
  });
  var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["__file", "icon.vue"]]);

  const arrowProps = buildProps({
    less: {
      type: Boolean
    }
  });

  const __default__$Q = vue.defineComponent({
    name: "IconArrow"
  });
  const _sfc_main$W = vue.defineComponent({
    ...__default__$Q,
    props: arrowProps,
    setup(__props) {
      const ns = useNamespace("icon-arrow");
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "i",
          {
            class: vue.normalizeClass([vue.unref(ns).b(), vue.unref(ns).is("less", _ctx.less)])
          },
          null,
          2
        );
      };
    }
  });
  var Arrow = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["__file", "arrow.vue"]]);

  const checkProps = buildProps({
    indeterminate: {
      type: Boolean
    },
    active: {
      type: Boolean
    }
  });

  const _hoisted_1$k = /* @__PURE__ */ vue.createElementVNode(
    "path",
    {
      fill: "none",
      d: "M 4.7071 12.2929 l 5 5 c 0.3905 0.3905 1.0237 0.3905 1.4142 0 l 11 -11"
    },
    null,
    -1
  );
  const _hoisted_2$e = [
    _hoisted_1$k
  ];
  const __default__$P = vue.defineComponent({
    name: "IconCheck"
  });
  const _sfc_main$V = vue.defineComponent({
    ...__default__$P,
    props: checkProps,
    setup(__props) {
      const ns = useNamespace("icon-check");
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "i",
          {
            class: vue.normalizeClass([
              vue.unref(ns).b(),
              vue.unref(ns).is("indeterminate", _ctx.indeterminate),
              vue.unref(ns).is("active", _ctx.active)
            ])
          },
          [
            _ctx.indeterminate ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).e("line"))
              },
              null,
              2
            )) : (vue.openBlock(), vue.createElementBlock(
              "svg",
              {
                key: 1,
                class: vue.normalizeClass(vue.unref(ns).e("check")),
                viewBox: "0 0 24 24"
              },
              _hoisted_2$e,
              2
            ))
          ],
          2
        );
      };
    }
  });
  var Check = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["__file", "check.vue"]]);

  const closeProps = buildProps({
    hover: {
      type: String
    },
    scale: {
      type: definePropType([String, Number]),
      validator: (value) => (isStringNumber(`${value}`) || isNumber(value)) && Number(value) >= 0 && Number(value) <= 1,
      default: 1
    }
  });

  const __default__$O = vue.defineComponent({
    name: "IconClose"
  });
  const _sfc_main$U = vue.defineComponent({
    ...__default__$O,
    props: closeProps,
    setup(__props) {
      const ns = useNamespace("icon-close");
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "i",
          {
            class: vue.normalizeClass([vue.unref(ns).b(), _ctx.hover && vue.unref(ns).bm("hover", _ctx.hover)]),
            style: vue.normalizeStyle({ transform: `scale(${_ctx.scale})` })
          },
          null,
          6
        );
      };
    }
  });
  var Close = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["__file", "close.vue"]]);

  const _hoisted_1$j = /* @__PURE__ */ vue.createElementVNode(
    "circle",
    {
      class: "path",
      cx: "25",
      cy: "25",
      r: "25"
    },
    null,
    -1
  );
  const _hoisted_2$d = [
    _hoisted_1$j
  ];
  const _hoisted_3$6 = /* @__PURE__ */ vue.createElementVNode(
    "circle",
    {
      class: "path",
      cx: "25",
      cy: "25",
      r: "25"
    },
    null,
    -1
  );
  const _hoisted_4$1 = [
    _hoisted_3$6
  ];
  const __default__$N = vue.defineComponent({
    name: "IconLoading"
  });
  const _sfc_main$T = vue.defineComponent({
    ...__default__$N,
    setup(__props) {
      const ns = useNamespace("icon-loading");
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(vue.unref(ns).b())
          },
          [
            (vue.openBlock(), vue.createElementBlock(
              "svg",
              {
                viewBox: "0 0 50 50",
                class: vue.normalizeClass([vue.unref(ns).e("item"), vue.unref(ns).e("1")])
              },
              _hoisted_2$d,
              2
            )),
            (vue.openBlock(), vue.createElementBlock(
              "svg",
              {
                viewBox: "0 0 50 50",
                class: vue.normalizeClass([vue.unref(ns).e("item"), vue.unref(ns).e("2")])
              },
              _hoisted_4$1,
              2
            ))
          ],
          2
        );
      };
    }
  });
  var Loading = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["__file", "loading.vue"]]);

  const plusProps = buildProps({
    less: {
      type: Boolean
    }
  });

  const __default__$M = vue.defineComponent({
    name: "IconPlus"
  });
  const _sfc_main$S = vue.defineComponent({
    ...__default__$M,
    props: plusProps,
    setup(__props) {
      const ns = useNamespace("icon");
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "i",
          {
            class: vue.normalizeClass([vue.unref(ns).b("plus"), vue.unref(ns).is("less", _ctx.less)])
          },
          null,
          2
        );
      };
    }
  });
  var Plus = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["__file", "plus.vue"]]);

  const _sfc_main$R = {
    name: "Star"
  };
  const _hoisted_1$i = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  };
  const _hoisted_2$c = /* @__PURE__ */ vue.createElementVNode(
    "path",
    {
      fill: "currentColor",
      d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72L512 747.84zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
    },
    null,
    -1
  );
  const _hoisted_3$5 = [
    _hoisted_2$c
  ];
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$i, _hoisted_3$5);
  }
  var Star = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$1], ["__file", "star.vue"]]);

  const _sfc_main$Q = {
    name: "StarFilled"
  };
  const _hoisted_1$h = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  };
  const _hoisted_2$b = /* @__PURE__ */ vue.createElementVNode(
    "path",
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      d: "M283.84 867.84 512 747.776l228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72z"
    },
    null,
    -1
  );
  const _hoisted_3$4 = [
    _hoisted_2$b
  ];
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$h, _hoisted_3$4);
  }
  var StarFilled = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render], ["__file", "star-filled.vue"]]);

  const VsIcon = withInstall(Icon);
  const IconArrow = withInstall(Arrow);
  const IconCheck = withInstall(Check);
  const IconClose = withInstall(Close);
  const IconLoading = withInstall(Loading);
  const IconPlus = withInstall(Plus);
  const IconStar = withInstall(Star);
  const IconStarFilled = withInstall(StarFilled);

  const __default__$L = vue.defineComponent({
    name: "VsCollapseTransition"
  });
  const _sfc_main$P = vue.defineComponent({
    ...__default__$L,
    setup(__props) {
      const ns = useNamespace("collapse-transition");
      const on = {
        beforeEnter(el) {
          if (!el.dataset)
            el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.style.maxHeight = 0;
          el.style.paddingTop = 0;
          el.style.paddingBottom = 0;
        },
        enter(el) {
          el.dataset.oldOverflow = el.style.overflow;
          if (el.scrollHeight !== 0) {
            el.style.maxHeight = `${el.scrollHeight}px`;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          } else {
            el.style.maxHeight = 0;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          }
          el.style.overflow = "hidden";
        },
        afterEnter(el) {
          el.style.maxHeight = "";
          el.style.overflow = el.dataset.oldOverflow;
        },
        beforeLeave(el) {
          if (!el.dataset)
            el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.dataset.oldOverflow = el.style.overflow;
          el.style.maxHeight = `${el.scrollHeight}px`;
          el.style.overflow = "hidden";
        },
        leave(el) {
          if (el.scrollHeight !== 0) {
            el.style.maxHeight = 0;
            el.style.paddingTop = 0;
            el.style.paddingBottom = 0;
          }
        },
        afterLeave(el) {
          el.style.maxHeight = "";
          el.style.overflow = el.dataset.oldOverflow;
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        }
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.Transition, vue.mergeProps({
          name: vue.unref(ns).b()
        }, vue.toHandlers(on)), {
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["name"]);
      };
    }
  });
  var CollapseTransition = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["__file", "collapse-transition.vue"]]);

  CollapseTransition.install = (app) => {
    app.component(CollapseTransition.name, CollapseTransition);
  };
  const _CollapseTransition = CollapseTransition;
  const VsCollapseTransition = _CollapseTransition;

  const alertProps = buildProps({
    color: { ...useColorProp, default: "primary" },
    closable: {
      type: Boolean
    },
    hiddenContent: {
      type: Boolean,
      default: null
    },
    modelValue: {
      type: Boolean,
      default: true
    },
    page: {
      type: Number,
      default: 0
    },
    progress: {
      type: [Number, String],
      default: 0
    },
    time: {
      type: [Number, String],
      default: 0
    },
    type: {
      type: String,
      values: [
        "",
        "border",
        "flat",
        "gradient",
        "relief",
        "shadow",
        "solid"
      ],
      default: ""
    },
    border: Boolean,
    flat: Boolean,
    gradient: Boolean,
    relief: Boolean,
    shadow: Boolean,
    solid: Boolean
  });
  const alertEmits = {
    [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
    "update:page": (value) => isNumber(value),
    "update:hiddenContent": (value) => isBoolean(value)
  };

  const useAlertDeprecated = (props) => {
    useDeprecated(
      {
        scope: "vs-alert",
        type: "Prop",
        from: "border",
        version: "0.2.0",
        replacement: "type",
        ref: "https://vuesax-alpha.vercel.app/components/alert#props"
      },
      vue.computed(() => !!props.border)
    );
    useDeprecated(
      {
        scope: "vs-alert",
        type: "Prop",
        from: "shadow",
        version: "0.2.0",
        replacement: "type",
        ref: "https://vuesax-alpha.vercel.app/components/alert#props"
      },
      vue.computed(() => !!props.shadow)
    );
    useDeprecated(
      {
        scope: "vs-alert",
        type: "Prop",
        from: "relief",
        version: "0.2.0",
        replacement: "type",
        ref: "https://vuesax-alpha.vercel.app/components/alert#props"
      },
      vue.computed(() => !!props.relief)
    );
    useDeprecated(
      {
        scope: "vs-alert",
        type: "Prop",
        from: "flat",
        version: "0.2.0",
        replacement: "type",
        ref: "https://vuesax-alpha.vercel.app/components/alert#props"
      },
      vue.computed(() => !!props.flat)
    );
    useDeprecated(
      {
        scope: "vs-alert",
        type: "Prop",
        from: "gradient",
        version: "0.2.0",
        replacement: "type",
        ref: "https://vuesax-alpha.vercel.app/components/alert#props"
      },
      vue.computed(() => !!props.gradient)
    );
    useDeprecated(
      {
        scope: "vs-alert",
        type: "Prop",
        from: "solid",
        version: "0.2.0",
        replacement: "type",
        ref: "https://vuesax-alpha.vercel.app/components/alert#props"
      },
      vue.computed(() => !!props.solid)
    );
  };

  const __default__$K = vue.defineComponent({
    name: "VsAlert"
  });
  const _sfc_main$O = vue.defineComponent({
    ...__default__$K,
    props: alertProps,
    emits: alertEmits,
    setup(__props, { emit }) {
      const props = __props;
      const slots = vue.useSlots();
      useAlertDeprecated(props);
      const ns = useNamespace("alert");
      const vsBaseClasses = useVuesaxBaseComponent(useColor());
      const alertClasses = vue.computed(() => [
        vsBaseClasses,
        ns.b(),
        props.type && ns.m(props.type),
        getPages.value.length > 0 && ns.m("pages")
      ]);
      const alertStyles = vue.computed(() => {
        return ns.cssVar({
          color: getVsColor(props.color)
        });
      });
      const getTotalPages = vue.computed(() => {
        const keys = Object.keys(slots).filter((slot) => slot.includes("page-"));
        return keys.length;
      });
      const getPages = vue.computed(() => {
        const pages = Object.keys(slots).filter((slot) => {
          return slot.includes("page-");
        });
        const values = [];
        pages.forEach((page) => {
          values.push(`${props.page}` === page.split("-")[1] && slots[page]);
        });
        return values;
      });
      const handleClickClose = () => {
        emit(UPDATE_MODEL_EVENT, !props.modelValue);
      };
      const handleClickHidden = () => {
        emit("update:hiddenContent", !props.hiddenContent);
      };
      const handleClickPrevPage = () => {
        if (props.page > 1) {
          emit("update:page", props.page - 1);
        }
      };
      const handleClickNextPage = () => {
        if (props.page < getTotalPages.value) {
          emit("update:page", props.page + 1);
        }
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(VsCollapseTransition), null, {
          default: vue.withCtx(() => [
            _ctx.modelValue ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(alertClasses.value),
                style: vue.normalizeStyle(alertStyles.value)
              },
              [
                _ctx.$slots.icon ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 0,
                    class: vue.normalizeClass(vue.unref(ns).e("icon"))
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "icon")
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true),
                _ctx.$slots.title ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 1,
                    class: vue.normalizeClass([
                      vue.unref(ns).e("title"),
                      vue.unref(isBoolean)(_ctx.hiddenContent) && vue.unref(ns).em("title", "click__hidden")
                    ]),
                    onClick: handleClickHidden
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "title"),
                    !_ctx.closable && vue.unref(isBoolean)(_ctx.hiddenContent) ? (vue.openBlock(), vue.createBlock(vue.unref(IconPlus), {
                      key: 0,
                      less: !_ctx.hiddenContent,
                      onClick: vue.withModifiers(handleClickHidden, ["stop"])
                    }, null, 8, ["less", "onClick"])) : vue.createCommentVNode("v-if", true)
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true),
                vue.createVNode(vue.unref(VsCollapseTransition), null, {
                  default: vue.withCtx(() => [
                    !_ctx.hiddenContent ? (vue.openBlock(), vue.createElementBlock(
                      "div",
                      {
                        key: 0,
                        class: vue.normalizeClass(vue.unref(ns).e("content"))
                      },
                      [
                        vue.createElementVNode(
                          "div",
                          {
                            class: vue.normalizeClass(vue.unref(ns).em("content", "text"))
                          },
                          [
                            vue.renderSlot(_ctx.$slots, "default"),
                            vue.renderSlot(_ctx.$slots, `page-${_ctx.page}`)
                          ],
                          2
                        )
                      ],
                      2
                    )) : vue.createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }),
                _ctx.closable ? (vue.openBlock(), vue.createElementBlock(
                  "button",
                  {
                    key: 2,
                    class: vue.normalizeClass(vue.unref(ns).e("close")),
                    onClick: handleClickClose
                  },
                  [
                    vue.createVNode(vue.unref(IconClose), { hover: "less" })
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true),
                _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 3,
                    class: vue.normalizeClass(vue.unref(ns).e("footer"))
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "footer")
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true),
                !!_ctx.progress ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 4,
                    class: vue.normalizeClass(vue.unref(ns).e("progress"))
                  },
                  [
                    vue.createElementVNode(
                      "div",
                      {
                        class: vue.normalizeClass(vue.unref(ns).em("progress", "bar")),
                        style: vue.normalizeStyle({ width: `${_ctx.progress}%` })
                      },
                      null,
                      6
                    )
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true),
                getTotalPages.value > 0 ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 5,
                    class: vue.normalizeClass(vue.unref(ns).e("pagination"))
                  },
                  [
                    vue.createElementVNode("button", {
                      onClick: handleClickPrevPage,
                      textContent: "<"
                    }),
                    vue.createElementVNode(
                      "span",
                      null,
                      vue.toDisplayString(_ctx.page) + " / " + vue.toDisplayString(getTotalPages.value),
                      1
                    ),
                    vue.createElementVNode("button", {
                      onClick: handleClickNextPage,
                      textContent: ">"
                    })
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true)
              ],
              6
            )) : vue.createCommentVNode("v-if", true)
          ]),
          _: 3
        });
      };
    }
  });
  var Alert = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["__file", "alert.vue"]]);

  const VsAlert = withInstall(Alert);

  const avatarProps = buildProps({
    color: useColorProp,
    badgePosition: {
      type: String,
      values: ["top-right", "bottom-right", "bottom-left", "top-left"],
      default: "bottom-right"
    },
    badgeColor: {
      type: String,
      values: vuesaxColors,
      validator: isValidComponentColor,
      default: "primary"
    },
    badge: { type: Boolean },
    history: { type: Boolean },
    historyGradient: { type: Boolean },
    loading: { type: Boolean },
    pointer: { type: Boolean },
    shape: {
      type: String,
      values: ["circle", "square", "default"],
      default: "default"
    },
    size: {
      type: [Number, String]
    },
    writing: { type: Boolean },
    circle: {
      type: Boolean
    },
    square: {
      type: Boolean
    }
  });

  const useAvatarStatus = (slots) => {
    const avatarGroup = useGroupInject(avatarGroupContextKey);
    const isHidden = vue.computed(
      () => avatarGroup && avatarGroup.index.value > avatarGroup.max - 1
    );
    const isLastest = vue.computed(
      () => !!(avatarGroup == null ? void 0 : avatarGroup.max) && avatarGroup.index.value === avatarGroup.max - 1
    );
    const moreNumber = vue.computed(
      () => avatarGroup && avatarGroup.children.length - avatarGroup.index.value - 1
    );
    const showLastest = vue.computed(
      () => avatarGroup && avatarGroup.children.length - avatarGroup.index.value - 1 != 0
    );
    const getText = vue.computed(() => {
      var _a;
      const slotText = (_a = slots.text) == null ? void 0 : _a.call(slots);
      if (!slotText)
        return "";
      if (slotText.length > 1) {
        return "";
      }
      const nodeText = slotText[0];
      if (isArray(nodeText.children) || !nodeText.children)
        return "";
      const text = nodeText.children;
      let getLetters = [text];
      if (text.length > 5) {
        getLetters = text.split(/\s/g).map((item) => item[0]);
      }
      return getLetters.join("");
    });
    return {
      isHidden,
      isLastest,
      getText,
      moreNumber,
      showLastest
    };
  };

  const __default__$J = vue.defineComponent({
    name: "VsAvatar"
  });
  const _sfc_main$N = vue.defineComponent({
    ...__default__$J,
    props: avatarProps,
    setup(__props) {
      const props = __props;
      const slots = vue.useSlots();
      const ns = useNamespace("avatar");
      const root$ = vue.ref();
      const { isHidden, isLastest, getText, showLastest, moreNumber } = useAvatarStatus(slots);
      const vsBaseClasses = useVuesaxBaseComponent(useColor());
      const avatarClassess = vue.computed(() => [
        ns.b("content"),
        vsBaseClasses,
        props.history && "history",
        props.historyGradient && "history--gradient",
        props.shape != "default" && `${ns.be("content", props.shape)}`,
        isHidden.value && `${ns.be("content", "hidden")}`,
        isLastest.value && `${ns.be("content", "latest")}`,
        slots.icons && `${ns.be("content", "hasIcons")}`
      ]);
      const avatarStyles = vue.computed(
        () => ({
          width: `${props.size}px`,
          height: `${props.size}px`,
          cursor: props.pointer ? "pointer" : "",
          ...ns.cssVar({
            color: getVsColor(props.color)
          })
        })
      );
      vue.watch(
        () => props.badgeColor,
        () => {
          var _a;
          setCssVar("avatar-badge", getVsColor(props.badgeColor), root$.value);
          (_a = root$.value) == null ? void 0 : _a.classList.add(ns.em("badge", "change-color"));
        }
      );
      vue.onMounted(() => {
        var _a;
        (_a = root$.value) == null ? void 0 : _a.classList.add(ns.em("badge", "change-color"));
        setCssVar("avatar-badge", getVsColor(props.badgeColor), root$.value);
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            ref_key: "root$",
            ref: root$,
            class: vue.normalizeClass(avatarClassess.value),
            style: vue.normalizeStyle(avatarStyles.value)
          },
          [
            _ctx.loading ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).e("loading"))
              },
              [
                vue.createElementVNode(
                  "div",
                  {
                    class: vue.normalizeClass(vue.unref(ns).em("loading", "animate"))
                  },
                  [
                    vue.createVNode(vue.unref(IconLoading))
                  ],
                  2
                )
              ],
              2
            )) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass([
                  vue.unref(ns).b(),
                  vue.unref(getText).length > 2 && vue.unref(ns).em("letter", `${vue.unref(getText).length}`)
                ])
              },
              [
                _ctx.$slots.text ? (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 0 },
                  [
                    vue.createTextVNode(
                      vue.toDisplayString(vue.unref(getText)),
                      1
                    )
                  ],
                  64
                )) : vue.createCommentVNode("v-if", true),
                vue.renderSlot(_ctx.$slots, "default")
              ],
              2
            ),
            _ctx.$slots.badge || _ctx.badge ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 1,
                class: vue.normalizeClass([
                  vue.unref(ns).e("badge"),
                  vue.unref(ns).is("slot", !!_ctx.$slots.badge),
                  vue.unref(ns).is("writing", _ctx.writing),
                  _ctx.badgePosition
                ])
              },
              [
                _ctx.writing ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 0,
                    class: vue.normalizeClass(vue.unref(ns).e("points"))
                  },
                  [
                    vue.createElementVNode(
                      "div",
                      {
                        class: vue.normalizeClass(vue.unref(ns).em("points", "item"))
                      },
                      null,
                      2
                    ),
                    vue.createElementVNode(
                      "div",
                      {
                        class: vue.normalizeClass(vue.unref(ns).em("points", "item"))
                      },
                      null,
                      2
                    ),
                    vue.createElementVNode(
                      "div",
                      {
                        class: vue.normalizeClass(vue.unref(ns).em("points", "item"))
                      },
                      null,
                      2
                    )
                  ],
                  2
                )) : vue.renderSlot(_ctx.$slots, "badge", { key: 1 })
              ],
              2
            )) : vue.createCommentVNode("v-if", true),
            vue.unref(isLastest) ? vue.withDirectives((vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 2,
                class: vue.normalizeClass(vue.unref(ns).e("lastest"))
              },
              vue.toDisplayString(`+${vue.unref(moreNumber)}`),
              3
            )), [
              [vue.vShow, vue.unref(showLastest)]
            ]) : vue.createCommentVNode("v-if", true),
            _ctx.$slots.icons ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 3,
                class: vue.normalizeClass(vue.unref(ns).e("icons"))
              },
              [
                vue.renderSlot(_ctx.$slots, "icons")
              ],
              2
            )) : vue.createCommentVNode("v-if", true)
          ],
          6
        );
      };
    }
  });
  var Avatar = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["__file", "avatar.vue"]]);

  const avatarGroupProps = buildProps({
    float: {
      type: Boolean
    },
    max: {
      type: [String, Number]
    }
  });

  const __default__$I = vue.defineComponent({
    name: "VsAvatarGroup"
  });
  const _sfc_main$M = vue.defineComponent({
    ...__default__$I,
    props: avatarGroupProps,
    setup(__props) {
      const props = __props;
      const ns = useNamespace("avatar");
      useGroupProvide(avatarGroupContextKey, {
        max: props.max
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass([vue.unref(ns).e("group"), { float: _ctx.float }])
          },
          [
            vue.renderSlot(_ctx.$slots, "default")
          ],
          2
        );
      };
    }
  });
  var AvatarGroup = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["__file", "avatar-group.vue"]]);

  const VsAvatar = withInstall(Avatar, {
    AvatarGroup
  });
  const VsAvatarGroup = withNoopInstall(AvatarGroup);

  const badgeProps = buildProps({
    value: {
      type: [String, Number],
      default: ""
    },
    max: {
      type: Number,
      default: 99
    },
    isDot: Boolean,
    hidden: Boolean,
    type: {
      type: String,
      values: ["primary", "success", "warn", "info", "danger"],
      default: "danger"
    },
    showZero: {
      type: Boolean,
      default: true
    },
    processing: Boolean,
    color: String,
    badgeStyle: {
      type: definePropType([String, Object, Array])
    },
    offset: {
      type: definePropType(Array),
      default: [0, 0]
    },
    badgeClass: {
      type: String
    }
  });

  const _hoisted_1$g = ["textContent"];
  const __default__$H = vue.defineComponent({
    name: "VsBadge"
  });
  const _sfc_main$L = vue.defineComponent({
    ...__default__$H,
    props: badgeProps,
    setup(__props, { expose: __expose }) {
      const props = __props;
      const ns = useNamespace("badge");
      const hidden = vue.computed(() => {
        return props.hidden || props.value === 0 && !props.showZero;
      });
      const content = vue.computed(() => {
        if (props.isDot)
          return "";
        if (isNumber(props.value) && isNumber(props.max)) {
          if (props.max < props.value) {
            return `${props.max}+`;
          }
          return `${props.value}`;
        }
        return `${props.value}`;
      });
      const style = vue.computed(() => {
        var _a, _b, _c, _d, _e;
        return [
          {
            backgroundColor: props.color,
            marginRight: addUnit(-((_b = (_a = props.offset) == null ? void 0 : _a[0]) != null ? _b : 0)),
            marginTop: addUnit((_d = (_c = props.offset) == null ? void 0 : _c[1]) != null ? _d : 0)
          },
          (_e = props.badgeStyle) != null ? _e : {},
          { "--vs-badge-ripple-color": props.color || "" }
        ];
      });
      __expose({
        content
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(vue.unref(ns).b())
          },
          [
            vue.renderSlot(_ctx.$slots, "default"),
            vue.createVNode(vue.Transition, {
              name: `${vue.unref(ns).namespace.value}-zoom-in-center`,
              persisted: ""
            }, {
              default: vue.withCtx(() => [
                vue.withDirectives(vue.createElementVNode("sup", {
                  class: vue.normalizeClass([
                    vue.unref(ns).e("content"),
                    vue.unref(ns).em("content", _ctx.type),
                    vue.unref(ns).is("fixed", !!_ctx.$slots.default),
                    vue.unref(ns).is("dot", _ctx.isDot),
                    vue.unref(ns).is("process", _ctx.processing),
                    _ctx.badgeClass
                  ]),
                  style: vue.normalizeStyle(style.value),
                  textContent: vue.toDisplayString(content.value)
                }, null, 14, _hoisted_1$g), [
                  [vue.vShow, !hidden.value && (content.value || _ctx.isDot)]
                ])
              ]),
              _: 1
            }, 8, ["name"])
          ],
          2
        );
      };
    }
  });
  var Badge = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["__file", "badge.vue"]]);

  const VsBadge = withInstall(Badge);

  const __default__$G = vue.defineComponent({
    name: "VsButtonGroup"
  });
  const _sfc_main$K = vue.defineComponent({
    ...__default__$G,
    setup(__props) {
      const ns = useNamespace("button");
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(vue.unref(ns).e("group"))
          },
          [
            vue.renderSlot(_ctx.$slots, "default")
          ],
          2
        );
      };
    }
  });
  var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["__file", "button-group.vue"]]);

  const buttonTypes = [
    "default",
    "border",
    "flat",
    "floating",
    "gradient",
    "shadow",
    "relief",
    "transparent"
  ];
  const buttonSizes = ["xl", "large", "default", "small", "mini"];
  const buttonProps = buildProps({
    active: { type: Boolean },
    animateInactive: { type: Boolean },
    animationType: {
      type: String,
      values: ["scale", "rotate", "vertical"]
    },
    block: {
      type: Boolean
    },
    color: { ...useColorProp, default: "primary" },
    icon: {
      type: Boolean
    },
    loading: { type: Boolean },
    shape: {
      type: String,
      values: ["circle", "square"]
    },
    size: {
      type: [Number, String],
      values: buttonSizes,
      default: "default"
    },
    ripple: {
      type: String,
      values: ["cut", "reverse"]
    },
    type: {
      type: String,
      values: buttonTypes,
      default: "default"
    },
    upload: {
      type: Boolean
    },
    border: { type: Boolean },
    flat: { type: Boolean },
    floating: { type: Boolean },
    gradient: { type: Boolean },
    shadow: { type: Boolean },
    relief: { type: Boolean },
    transparent: { type: Boolean },
    square: { type: Boolean },
    circle: { type: Boolean },
    to: { type: [String, Object] },
    href: { type: String },
    blank: { type: Boolean }
  });

  const __default__$F = vue.defineComponent({
    name: "VsButton"
  });
  const _sfc_main$J = vue.defineComponent({
    ...__default__$F,
    props: buttonProps,
    setup(__props) {
      const props = __props;
      const slots = vue.useSlots();
      const ns = useNamespace("button");
      const root$ = vue.ref();
      const vsBaseClasses = useVuesaxBaseComponent(useColor());
      const buttonClasses = vue.computed(() => {
        return [
          ns.b(),
          vsBaseClasses,
          props.shape && ns.m(props.shape),
          props.active && ns.m("active"),
          slots.animate && ns.m("animate"),
          props.animationType && ns.m(`animate-${props.animationType}`),
          props.animateInactive && ns.m("animate-inactive"),
          props.block && ns.m("block"),
          props.icon && ns.m("icon"),
          props.loading && ns.m("loading"),
          ns.em("size", props.size),
          ns.m(props.type),
          props.upload && ns.m("upload")
        ];
      });
      const buttonStyles = vue.computed(() => {
        return [
          ns.cssVar({
            color: getVsColor(props.color)
          })
        ];
      });
      const mouseDown = (evs) => {
        if (props.ripple === "reverse") {
          rippleReverse(evs);
        } else if (props.ripple === "cut") {
          rippleCut(evs);
        } else {
          if (props.type === "flat") {
            ripple(
              evs,
              !props.active && document.activeElement !== root$.value ? "inherit" : void 0,
              !props.active && document.activeElement !== root$.value
            );
          } else {
            ripple(evs, void 0, false);
          }
        }
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "button",
          {
            ref_key: "root$",
            ref: root$,
            class: vue.normalizeClass(buttonClasses.value),
            style: vue.normalizeStyle(buttonStyles.value),
            onMousedown: mouseDown
          },
          [
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("content"))
              },
              [
                vue.renderSlot(_ctx.$slots, "default")
              ],
              2
            ),
            _ctx.$slots.animate ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass([vue.unref(ns).e("animate"), vue.unref(ns).em("animate", _ctx.animationType)])
              },
              [
                vue.renderSlot(_ctx.$slots, "animate")
              ],
              2
            )) : vue.createCommentVNode("v-if", true),
            _ctx.loading ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 1,
                class: vue.normalizeClass(vue.unref(ns).e("loading"))
              },
              [
                vue.createVNode(vue.unref(IconLoading))
              ],
              2
            )) : vue.createCommentVNode("v-if", true)
          ],
          38
        );
      };
    }
  });
  var Button = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["__file", "button.vue"]]);

  const VsButton = withInstall(Button, {
    ButtonGroup
  });
  const VsButtonGroup = withNoopInstall(ButtonGroup);

  const cardType = [1, "1", 2, "2", 3, "3", 4, "4", 5, "5"];
  const cardProps = buildProps({
    color: useColorProp,
    type: {
      type: [String, Number],
      values: cardType,
      validator: (val) => cardType.includes(val),
      default: 1
    }
  });

  const __default__$E = vue.defineComponent({
    inheritAttrs: false,
    name: "VsCard"
  });
  const _sfc_main$I = vue.defineComponent({
    ...__default__$E,
    props: cardProps,
    setup(__props) {
      const ns = useNamespace("card");
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass([vue.unref(ns).b("content"), `type-${_ctx.type}`])
          },
          [
            vue.createElementVNode(
              "div",
              vue.mergeProps({
                class: vue.unref(ns).b()
              }, _ctx.$attrs),
              [
                _ctx.$slots.img ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 0,
                    class: vue.normalizeClass(vue.unref(ns).e("img"))
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "img"),
                    _ctx.$slots.interactions ? (vue.openBlock(), vue.createElementBlock(
                      "div",
                      {
                        key: 0,
                        class: vue.normalizeClass(vue.unref(ns).e("interactions"))
                      },
                      [
                        vue.renderSlot(_ctx.$slots, "interactions")
                      ],
                      2
                    )) : vue.createCommentVNode("v-if", true)
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true),
                _ctx.$slots.text ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 1,
                    class: vue.normalizeClass(vue.unref(ns).e("text"))
                  },
                  [
                    _ctx.$slots.title ? (vue.openBlock(), vue.createElementBlock(
                      "div",
                      {
                        key: 0,
                        class: vue.normalizeClass(vue.unref(ns).e("title"))
                      },
                      [
                        vue.renderSlot(_ctx.$slots, "title")
                      ],
                      2
                    )) : vue.createCommentVNode("v-if", true),
                    vue.renderSlot(_ctx.$slots, "text")
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true),
                _ctx.$slots.buttons ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 2,
                    class: vue.normalizeClass(vue.unref(ns).e("button"))
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "buttons")
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true)
              ],
              16
            )
          ],
          2
        );
      };
    }
  });
  var Card = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["__file", "card.vue"]]);

  const GAP = 4;
  const BAR_MAP = {
    vertical: {
      offset: "offsetHeight",
      scroll: "scrollTop",
      scrollSize: "scrollHeight",
      size: "height",
      key: "vertical",
      axis: "Y",
      client: "clientY",
      direction: "top"
    },
    horizontal: {
      offset: "offsetWidth",
      scroll: "scrollLeft",
      scrollSize: "scrollWidth",
      size: "width",
      key: "horizontal",
      axis: "X",
      client: "clientX",
      direction: "left"
    }
  };
  const renderThumbStyle = ({
    move,
    size,
    bar
  }) => ({
    [bar.size]: size,
    transform: `translate${bar.axis}(${move}%)`
  });

  const thumbProps = buildProps({
    vertical: { type: Boolean },
    size: { type: String },
    move: { type: Number },
    ratio: {
      type: Number,
      required: true
    },
    always: { type: Boolean }
  });

  const COMPONENT_NAME$2 = "Thumb";
  const _sfc_main$H = vue.defineComponent({
    __name: "thumb",
    props: thumbProps,
    setup(__props) {
      const props = __props;
      const scrollbar = vue.inject(scrollbarContextKey);
      const ns = useNamespace("scrollbar");
      if (!scrollbar)
        throwError(COMPONENT_NAME$2, "can not inject scrollbar context");
      const instance = vue.ref();
      const thumb = vue.ref();
      const thumbState = vue.ref({});
      const visible = vue.ref(false);
      let cursorDown = false;
      let cursorLeave = false;
      let originalOnSelectStart = isClient ? document.onselectstart : null;
      const bar = vue.computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
      const thumbStyle = vue.computed(
        () => renderThumbStyle({
          size: props.size,
          move: props.move,
          bar: bar.value
        })
      );
      const offsetRatio = vue.computed(
        () => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]
      );
      const clickThumbHandler = (e) => {
        var _a;
        if (e.ctrlKey || [1, 2].includes(e.button))
          return;
        (_a = window.getSelection()) == null ? void 0 : _a.removeAllRanges();
        startDrag(e);
        const el = e.currentTarget;
        if (!el)
          return;
        thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
      };
      const clickTrackHandler = (e) => {
        if (!thumb.value || !instance.value || !scrollbar.wrapElement)
          return;
        scrollbar.wrapElement.style.scrollBehavior = "smooth";
        const offset = Math.abs(
          e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]
        );
        const thumbHalf = thumb.value[bar.value.offset] / 2;
        const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
        scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        scrollbar.wrapElement.style.scrollBehavior = "unset";
      };
      const startDrag = (e) => {
        e.stopImmediatePropagation();
        cursorDown = true;
        document.addEventListener("mousemove", mouseMoveDocumentHandler);
        document.addEventListener("mouseup", mouseUpDocumentHandler);
        originalOnSelectStart = document.onselectstart;
        document.onselectstart = () => false;
      };
      const mouseMoveDocumentHandler = (e) => {
        if (!instance.value || !thumb.value)
          return;
        if (cursorDown === false)
          return;
        const prevPage = thumbState.value[bar.value.axis];
        if (!prevPage)
          return;
        const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
        const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
        const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
        scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
      };
      const mouseUpDocumentHandler = () => {
        cursorDown = false;
        thumbState.value[bar.value.axis] = 0;
        document.removeEventListener("mousemove", mouseMoveDocumentHandler);
        document.removeEventListener("mouseup", mouseUpDocumentHandler);
        restoreOnselectstart();
        if (cursorLeave)
          visible.value = false;
      };
      const mouseMoveScrollbarHandler = () => {
        cursorLeave = false;
        visible.value = !!props.size;
      };
      const mouseLeaveScrollbarHandler = () => {
        cursorLeave = true;
        visible.value = cursorDown;
      };
      vue.onBeforeUnmount(() => {
        restoreOnselectstart();
        document.removeEventListener("mouseup", mouseUpDocumentHandler);
      });
      const restoreOnselectstart = () => {
        if (document.onselectstart !== originalOnSelectStart)
          document.onselectstart = originalOnSelectStart;
      };
      useEventListener(
        vue.toRef(scrollbar, "scrollbarElement"),
        "mousemove",
        mouseMoveScrollbarHandler
      );
      useEventListener(
        vue.toRef(scrollbar, "scrollbarElement"),
        "mouseleave",
        mouseLeaveScrollbarHandler
      );
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.Transition, {
          name: vue.unref(ns).b("fade"),
          persisted: ""
        }, {
          default: vue.withCtx(() => [
            vue.withDirectives(vue.createElementVNode(
              "div",
              {
                ref_key: "instance",
                ref: instance,
                class: vue.normalizeClass([vue.unref(ns).e("bar"), vue.unref(ns).is(bar.value.key)]),
                onMousedown: clickTrackHandler
              },
              [
                vue.createElementVNode(
                  "div",
                  {
                    ref_key: "thumb",
                    ref: thumb,
                    class: vue.normalizeClass(vue.unref(ns).e("thumb")),
                    style: vue.normalizeStyle(thumbStyle.value),
                    onMousedown: clickThumbHandler
                  },
                  null,
                  38
                )
              ],
              34
            ), [
              [vue.vShow, _ctx.always || visible.value]
            ])
          ]),
          _: 1
        }, 8, ["name"]);
      };
    }
  });
  var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["__file", "thumb.vue"]]);

  const barProps = buildProps({
    always: {
      type: Boolean,
      default: true
    },
    width: { type: String },
    height: { type: String },
    ratioX: {
      type: Number,
      default: 1
    },
    ratioY: {
      type: Number,
      default: 1
    },
    thickness: {
      type: [Number, String],
      default: 6
    }
  });

  const _sfc_main$G = vue.defineComponent({
    __name: "bar",
    props: barProps,
    setup(__props, { expose: __expose }) {
      const props = __props;
      const moveX = vue.ref(0);
      const moveY = vue.ref(0);
      const handleScroll = (wrap) => {
        if (wrap) {
          const offsetHeight = wrap.offsetHeight - GAP;
          const offsetWidth = wrap.offsetWidth - GAP;
          moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
          moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
        }
      };
      __expose({
        handleScroll
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          null,
          [
            vue.createVNode(Thumb, {
              move: moveX.value,
              ratio: _ctx.ratioX,
              size: _ctx.width,
              always: _ctx.always,
              style: vue.normalizeStyle(`height: ${_ctx.thickness}px`)
            }, null, 8, ["move", "ratio", "size", "always", "style"]),
            vue.createVNode(Thumb, {
              move: moveY.value,
              ratio: _ctx.ratioY,
              size: _ctx.height,
              vertical: "",
              always: _ctx.always,
              style: vue.normalizeStyle(`width: ${_ctx.thickness}px`)
            }, null, 8, ["move", "ratio", "size", "always", "style"])
          ],
          64
        );
      };
    }
  });
  var Bar = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__file", "bar.vue"]]);

  const scrollbarProps = buildProps({
    height: {
      type: [String, Number],
      default: ""
    },
    maxHeight: {
      type: [String, Number],
      default: ""
    },
    native: {
      type: Boolean,
      default: false
    },
    wrapStyle: {
      type: definePropType([String, Object, Array]),
      default: ""
    },
    wrapClass: {
      type: [String, Array],
      default: ""
    },
    viewClass: {
      type: [String, Array],
      default: ""
    },
    viewStyle: {
      type: [String, Array, Object],
      default: ""
    },
    noresize: { type: Boolean },
    tag: {
      type: String,
      default: "div"
    },
    always: {
      type: Boolean,
      default: true
    },
    minSize: {
      type: Number,
      default: 20
    },
    thickness: {
      type: [Number, String],
      default: 6
    }
  });
  const scrollbarEmits = {
    scroll: ({ scrollTop, scrollLeft }) => [scrollTop, scrollLeft].every(isNumber)
  };

  const COMPONENT_NAME$1 = "VsScrollbar";
  const __default__$D = vue.defineComponent({
    name: COMPONENT_NAME$1
  });
  const _sfc_main$F = vue.defineComponent({
    ...__default__$D,
    props: scrollbarProps,
    emits: scrollbarEmits,
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const ns = useNamespace("scrollbar");
      let stopResizeObserver = void 0;
      let stopResizeListener = void 0;
      const scrollbarRef = vue.ref();
      const wrapRef = vue.ref();
      const resizeRef = vue.ref();
      const sizeWidth = vue.ref("0");
      const sizeHeight = vue.ref("0");
      const barRef = vue.ref();
      const ratioY = vue.ref(1);
      const ratioX = vue.ref(1);
      const style = vue.computed(() => {
        const style2 = {};
        if (props.height)
          style2.height = addUnit(props.height);
        if (props.maxHeight)
          style2.maxHeight = addUnit(props.maxHeight);
        return [props.wrapStyle, style2];
      });
      const wrapKls = vue.computed(() => {
        return [
          props.wrapClass,
          ns.e("wrap"),
          { [ns.em("wrap", "hidden-default")]: !props.native }
        ];
      });
      const resizeKls = vue.computed(() => {
        return [ns.e("view"), props.viewClass];
      });
      const handleScroll = () => {
        var _a;
        if (wrapRef.value) {
          (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrapRef.value);
          emit("scroll", {
            scrollTop: wrapRef.value.scrollTop,
            scrollLeft: wrapRef.value.scrollLeft
          });
        }
      };
      function scrollTo(arg1, arg2) {
        if (isObject(arg1)) {
          wrapRef.value.scrollTo(arg1);
        } else if (isNumber(arg1) && isNumber(arg2)) {
          wrapRef.value.scrollTo(arg1, arg2);
        }
      }
      const setScrollTop = (value) => {
        if (!isNumber(value)) {
          return;
        }
        wrapRef.value.scrollTop = value;
      };
      const setScrollLeft = (value) => {
        if (!isNumber(value)) {
          return;
        }
        wrapRef.value.scrollLeft = value;
      };
      const update = () => {
        if (!wrapRef.value)
          return;
        const offsetHeight = wrapRef.value.offsetHeight - GAP;
        const offsetWidth = wrapRef.value.offsetWidth - GAP;
        const originalHeight = offsetHeight ** 2 / wrapRef.value.scrollHeight;
        const originalWidth = offsetWidth ** 2 / wrapRef.value.scrollWidth;
        const height = Math.max(originalHeight, props.minSize);
        const width = Math.max(originalWidth, props.minSize);
        ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
        ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
        sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
        sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
      };
      vue.watch(
        () => props.noresize,
        (noresize) => {
          if (noresize) {
            stopResizeObserver == null ? void 0 : stopResizeObserver();
            stopResizeListener == null ? void 0 : stopResizeListener();
          } else {
            ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
            stopResizeListener = useEventListener("resize", update);
          }
        },
        { immediate: true }
      );
      vue.watch(
        () => [props.maxHeight, props.height],
        () => {
          if (!props.native)
            vue.nextTick(() => {
              var _a;
              update();
              if (wrapRef.value) {
                (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrapRef.value);
              }
            });
        }
      );
      vue.provide(
        scrollbarContextKey,
        vue.reactive({
          scrollbarElement: scrollbarRef,
          wrapElement: wrapRef
        })
      );
      vue.onMounted(() => {
        if (!props.native)
          vue.nextTick(() => {
            update();
          });
      });
      vue.onUpdated(() => update());
      __expose({
        wrapRef,
        update,
        scrollTo,
        setScrollTop,
        setScrollLeft,
        handleScroll
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            ref_key: "scrollbarRef",
            ref: scrollbarRef,
            class: vue.normalizeClass(vue.unref(ns).b())
          },
          [
            vue.createElementVNode(
              "div",
              {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: vue.normalizeClass(wrapKls.value),
                style: vue.normalizeStyle(style.value),
                onScroll: handleScroll
              },
              [
                (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.tag), {
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: vue.normalizeClass(resizeKls.value),
                  style: vue.normalizeStyle(_ctx.viewStyle)
                }, {
                  default: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["class", "style"]))
              ],
              38
            ),
            !_ctx.native ? (vue.openBlock(), vue.createBlock(Bar, {
              key: 0,
              ref_key: "barRef",
              ref: barRef,
              height: sizeHeight.value,
              width: sizeWidth.value,
              always: _ctx.always,
              "ratio-x": ratioX.value,
              "ratio-y": ratioY.value,
              thickness: _ctx.thickness
            }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y", "thickness"])) : vue.createCommentVNode("v-if", true)
          ],
          2
        );
      };
    }
  });
  var Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["__file", "scrollbar.vue"]]);

  const VsScrollbar = withInstall(Scrollbar);

  const __default__$C = vue.defineComponent({
    name: "VsCardGroup"
  });
  const _sfc_main$E = vue.defineComponent({
    ...__default__$C,
    setup(__props) {
      const ns = useNamespace("card");
      const scrollbarRef = vue.ref();
      const scrollbar = vue.ref({
        scrollTop: 0,
        scrollLeft: 0
      });
      const handleScrollbar = ({ scrollTop, scrollLeft }) => {
        scrollbar.value = { scrollTop, scrollLeft };
      };
      const handleClickNexticon = () => {
        const cards = scrollbarRef.value;
        cards.wrapRef.style.scrollBehavior = "smooth";
        cards.scrollTo(scrollbar.value.scrollLeft + cards.wrapRef.clientWidth, 0);
        cards.wrapRef.style.scrollBehavior = "unset";
      };
      const handleClickPrevicon = () => {
        const cards = scrollbarRef.value;
        cards.wrapRef.style.scrollBehavior = "smooth";
        cards.scrollTo(scrollbar.value.scrollLeft - cards.wrapRef.clientWidth, 0);
        cards.wrapRef.style.scrollBehavior = "unset";
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(vue.unref(ns).e("group"))
          },
          [
            vue.createElementVNode(
              "button",
              {
                class: vue.normalizeClass(vue.unref(ns).em("group", "prev")),
                onClick: handleClickPrevicon
              },
              [
                vue.createVNode(vue.unref(IconArrow))
              ],
              2
            ),
            vue.createVNode(vue.unref(VsScrollbar), {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              always: "",
              "view-class": vue.unref(ns).em("group", "cards"),
              onScroll: handleScrollbar
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["view-class"]),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).em("group", "space"))
              },
              null,
              2
            ),
            vue.createElementVNode(
              "button",
              {
                class: vue.normalizeClass(vue.unref(ns).em("group", "next")),
                onClick: handleClickNexticon
              },
              [
                vue.createVNode(vue.unref(IconArrow))
              ],
              2
            )
          ],
          2
        );
      };
    }
  });
  var CardGroup = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["__file", "card-group.vue"]]);

  const VsCard = withInstall(Card, {
    CardGroup
  });
  const VsCardGroup = withNoopInstall(CardGroup);

  const checkboxProps = buildProps({
    color: useColorProp,
    modelValue: {
      type: definePropType([
        String,
        Number,
        Boolean,
        Object,
        Array
      ]),
      default: void 0
    },
    notValue: {
      type: definePropType([
        String,
        Number,
        Boolean,
        Object,
        Array
      ])
    },
    value: {
      type: definePropType([
        String,
        Number,
        Boolean,
        Object,
        Array
      ])
    },
    id: {
      type: String,
      default: null
    },
    indeterminate: {
      type: Boolean
    },
    checked: {
      type: Boolean
    },
    checkedForce: {
      type: Boolean
    },
    disabled: {
      type: Boolean
    },
    loading: {
      type: Boolean
    },
    label: {
      type: String
    },
    labelBefore: {
      type: Boolean
    },
    lineThrough: {
      type: Boolean
    },
    name: {
      type: String,
      default: void 0
    },
    min: {
      type: Number
    },
    max: {
      type: Number
    }
  });
  const checkboxEmits = {
    [UPDATE_MODEL_EVENT]: (val) => isString(val) || isNumber(val) || isBoolean(val) || isArray(val),
    change: (val) => isString(val) || isNumber(val) || isBoolean(val)
  };

  const setStoreValue = (props, { model }) => {
    if (props.checked) {
      if (isArray(model.value) && !model.value.includes(props.value)) {
        model.value.push(props.value);
      } else {
        model.value = props.value || true;
      }
    }
  };
  const useCheckbox = (props, emit, slots) => {
    const selfModel = vue.ref(false);
    const isLimitExceeded = vue.ref(false);
    const checkboxGroup = vue.inject(checkboxGroupContextKey, void 0);
    const isGroup = vue.computed(() => isUndefined(checkboxGroup) === false);
    const isChecked = vue.computed(() => {
      const value = model.value || (checkboxGroup == null ? void 0 : checkboxGroup.modelValue);
      if (isBoolean(value))
        return value;
      if (isArray(value)) {
        if (isObject(props.value)) {
          return value.map(vue.toRaw).some((o) => isEqual(o, props.value));
        }
        return value.map(vue.toRaw).includes(props.value);
      }
      if (value !== null && value !== void 0)
        return value === props.value;
      if (props.checkedForce)
        return true;
      return !!value;
    });
    const hasOwnLabel = vue.computed(() => {
      return !!(slots.default || props.label);
    });
    const isLimitDisabled = vue.computed(() => {
      var _a, _b;
      const max = Number(((_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value) || props.max);
      const min = Number(((_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value) || props.min);
      return !isNil(max) && toArray(model.value).length >= max && !isChecked.value || !isNil(min) && toArray(model.value).length <= min && isChecked.value;
    });
    const isDisabled = useDisabled(
      vue.computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value)
    );
    const model = vue.computed({
      get() {
        var _a;
        return isGroup.value ? (_a = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a.value : props.modelValue || selfModel.value;
      },
      set(val) {
        var _a, _b;
        if (isDisabled.value || isLimitExceeded.value)
          return;
        if (isGroup.value && isArray(val)) {
          isLimitExceeded.value = ((_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value);
          isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
          return;
        }
        let updatedValue = val;
        if (val && props.value) {
          updatedValue = props.value;
        }
        if (isBoolean(updatedValue)) {
          emit(UPDATE_MODEL_EVENT, updatedValue);
        } else if (isArray(props.modelValue)) {
          const modelValueRaw = props.modelValue.map(vue.toRaw);
          const indexVal = modelValueRaw.findIndex(
            (e) => isEqual(e, updatedValue)
          );
          if (indexVal == -1) {
            modelValueRaw.push(updatedValue);
          } else {
            modelValueRaw.splice(indexVal, 1);
          }
          emit("update:modelValue", modelValueRaw);
        } else {
          if (updatedValue !== props.modelValue) {
            if (val) {
              emit(UPDATE_MODEL_EVENT, [props.modelValue, updatedValue]);
            } else {
              emit(UPDATE_MODEL_EVENT, updatedValue);
            }
          } else {
            emit(UPDATE_MODEL_EVENT, props.notValue || false);
          }
        }
        selfModel.value = !!val;
      }
    });
    vue.onBeforeMount(() => {
      if (props.checked || props.checkedForce) {
        model.value = props.value || true;
      }
    });
    const getCheckboxValue = (value) => {
      return value === props.value || value === true;
    };
    const handleChange = (e) => {
      if (isLimitExceeded.value)
        return;
      const target = e.target;
      emit("change", getCheckboxValue(target.checked));
    };
    setStoreValue(props, { model });
    return {
      isChecked,
      isDisabled,
      hasOwnLabel,
      model,
      handleChange
    };
  };

  const _hoisted_1$f = ["id", "value", "name", "disabled"];
  const _hoisted_2$a = ["for"];
  const __default__$B = vue.defineComponent({
    inheritAttrs: false,
    name: "VsCheckbox"
  });
  const _sfc_main$D = vue.defineComponent({
    ...__default__$B,
    props: checkboxProps,
    emits: checkboxEmits,
    setup(__props, { emit }) {
      var _a;
      const props = __props;
      const slots = vue.useSlots();
      const ns = useNamespace("checkbox");
      const checkboxId = (_a = props.id) != null ? _a : useId();
      const { isChecked, isDisabled, model, hasOwnLabel, handleChange } = useCheckbox(
        props,
        emit,
        slots
      );
      const vsBaseClasses = useVuesaxBaseComponent(useColor());
      const checkboxKls = vue.computed(() => [
        ns.b(),
        vsBaseClasses,
        ns.is("disabled", isDisabled.value),
        ns.is("checked", isChecked.value),
        ns.is("label-before", props.labelBefore),
        ns.is("loading", props.loading)
      ]);
      const checkboxStyles = vue.computed(() => [
        ns.cssVar({
          color: getVsColor(props.color)
        })
      ]);
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(checkboxKls.value),
            style: vue.normalizeStyle(checkboxStyles.value)
          },
          [
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("input"))
              },
              [
                vue.withDirectives(vue.createElementVNode("input", vue.mergeProps(_ctx.$attrs, {
                  id: vue.unref(checkboxId),
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.isRef(model) ? model.value = $event : null),
                  value: _ctx.value,
                  name: _ctx.name,
                  disabled: vue.unref(isDisabled),
                  class: vue.unref(ns).e("original"),
                  type: "checkbox",
                  onChange: _cache[1] || (_cache[1] = (...args) => vue.unref(handleChange) && vue.unref(handleChange)(...args))
                }), null, 16, _hoisted_1$f), [
                  [vue.vModelCheckbox, vue.unref(model)]
                ]),
                vue.createElementVNode(
                  "div",
                  {
                    class: vue.normalizeClass(vue.unref(ns).em("input", "mask"))
                  },
                  [
                    !_ctx.$slots.icon ? (vue.openBlock(), vue.createBlock(vue.unref(IconCheck), {
                      key: 0,
                      active: vue.unref(isChecked),
                      indeterminate: _ctx.indeterminate
                    }, null, 8, ["active", "indeterminate"])) : vue.renderSlot(_ctx.$slots, "icon", { key: 1 })
                  ],
                  2
                ),
                _ctx.loading ? (vue.openBlock(), vue.createBlock(vue.unref(IconLoading), { key: 0 })) : vue.createCommentVNode("v-if", true)
              ],
              2
            ),
            vue.unref(hasOwnLabel) ? (vue.openBlock(), vue.createElementBlock("label", {
              key: 0,
              for: vue.unref(checkboxId),
              class: vue.normalizeClass([vue.unref(ns).e("label"), vue.unref(ns).is("line-through", _ctx.lineThrough)])
            }, [
              vue.renderSlot(_ctx.$slots, "default"),
              !_ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock(
                vue.Fragment,
                { key: 0 },
                [
                  vue.createTextVNode(
                    vue.toDisplayString(_ctx.label),
                    1
                  )
                ],
                64
              )) : vue.createCommentVNode("v-if", true)
            ], 10, _hoisted_2$a)) : vue.createCommentVNode("v-if", true)
          ],
          6
        );
      };
    }
  });
  var Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__file", "checkbox.vue"]]);

  const checkboxGroupProps = buildProps({
    modelValue: {
      type: definePropType(Array),
      default: () => []
    },
    disabled: {
      type: Boolean,
      default: false
    },
    min: {
      type: Number
    },
    max: {
      type: Number
    }
  });
  const checkboxGroupEmits = {
    [UPDATE_MODEL_EVENT]: (val) => isArray(val),
    change: (val) => isArray(val)
  };

  const __default__$A = vue.defineComponent({
    name: "VsCheckboxGroup"
  });
  const _sfc_main$C = vue.defineComponent({
    ...__default__$A,
    props: checkboxGroupProps,
    emits: checkboxGroupEmits,
    setup(__props, { emit }) {
      const props = __props;
      const ns = useNamespace("checkbox");
      const changeEvent = async (value) => {
        emit(UPDATE_MODEL_EVENT, value);
        await vue.nextTick();
        emit("change", value);
      };
      const modelValue = vue.computed({
        get() {
          return props.modelValue;
        },
        set(val) {
          changeEvent(val);
        }
      });
      vue.onBeforeMount(() => {
        if (!isArray(props.modelValue)) {
          modelValue.value = [props.modelValue];
        }
      });
      vue.provide(checkboxGroupContextKey, {
        ...pick(vue.toRefs(props), ["min", "max", "disabled"]),
        modelValue,
        changeEvent
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(vue.unref(ns).b("group"))
          },
          [
            vue.renderSlot(_ctx.$slots, "default")
          ],
          2
        );
      };
    }
  });
  var CheckboxGroup = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["__file", "checkbox-group.vue"]]);

  const VsCheckbox = withInstall(Checkbox, {
    CheckboxGroup
  });
  const VsCheckboxGroup = withNoopInstall(CheckboxGroup);

  const colProps = buildProps({
    span: {
      type: Number,
      default: 12
    },
    offset: {
      type: Number,
      default: 0
    },
    pull: {
      type: Number,
      default: 0
    },
    push: {
      type: Number,
      default: 0
    },
    xs: {
      type: definePropType([Number, Object]),
      default: () => mutable({})
    },
    sm: {
      type: definePropType([Number, Object]),
      default: () => mutable({})
    },
    md: {
      type: definePropType([Number, Object]),
      default: () => mutable({})
    },
    lg: {
      type: definePropType([Number, Object]),
      default: () => mutable({})
    },
    xl: {
      type: definePropType([Number, Object]),
      default: () => mutable({})
    }
  });

  const __default__$z = vue.defineComponent({
    name: "VsCol"
  });
  const _sfc_main$B = vue.defineComponent({
    ...__default__$z,
    props: colProps,
    setup(__props) {
      const props = __props;
      const ns = useNamespace("col");
      const { gutter } = vue.inject(rowContextKey, { gutter: vue.computed(() => 0) });
      const colKls = vue.computed(() => {
        const classes = [];
        const pos = ["span", "offset", "pull", "push"];
        pos.forEach((prop) => {
          const size = props[prop];
          if (isNumber(size)) {
            if (prop === "span")
              classes.push(ns.b(`${props[prop]}`));
            else if (size > 0)
              classes.push(ns.b(`${prop}-${props[prop]}`));
          }
        });
        const sizes = ["xs", "sm", "md", "lg", "xl"];
        sizes.forEach((size) => {
          if (isNumber(props[size])) {
            classes.push(ns.b(`${size}-${props[size]}`));
          } else if (isObject(props[size])) {
            Object.entries(props[size]).forEach(([prop, sizeProp]) => {
              classes.push(
                prop !== "span" ? ns.b(`${size}-${prop}-${sizeProp}`) : ns.b(`${size}-${sizeProp}`)
              );
            });
          }
        });
        if (gutter.value) {
          classes.push(ns.is("guttered"));
        }
        return [ns.b(), classes];
      });
      const colStyle = vue.computed(() => {
        const styles = {};
        if (gutter.value) {
          styles.paddingLeft = styles.paddingRight = `${gutter.value / 2}px`;
        }
        return styles;
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(colKls.value),
            style: vue.normalizeStyle(colStyle.value)
          },
          [
            vue.renderSlot(_ctx.$slots, "default")
          ],
          6
        );
      };
    }
  });
  var Col = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["__file", "col.vue"]]);

  const VsCol = withInstall(Col);

  const dialogProps = buildProps({
    modelValue: {
      type: Boolean,
      default: false
    },
    color: { ...useColorProp, default: "primary" },
    overlayBlur: {
      default: false,
      type: Boolean
    },
    beforeClose: {
      type: definePropType(Function)
    },
    loading: {
      default: false,
      type: Boolean
    },
    fullScreen: {
      default: false,
      type: Boolean
    },
    notClose: {
      default: false,
      type: Boolean
    },
    preventClose: {
      default: false,
      type: Boolean
    },
    notPadding: {
      default: false,
      type: Boolean
    },
    lockScroll: {
      default: false,
      type: Boolean
    },
    shape: {
      type: String,
      values: ["square", "rounded"],
      default: "rounded"
    },
    autoWidth: {
      default: false,
      type: Boolean
    },
    scroll: {
      default: false,
      type: Boolean
    },
    notCenter: {
      default: false,
      type: Boolean
    },
    width: {
      default: null,
      type: String
    },
    overflowHidden: Boolean,
    blur: Boolean
  });
  const dialogEmits = {
    open: () => true,
    opened: () => true,
    close: () => true,
    closed: () => true,
    [UPDATE_MODEL_EVENT]: (value) => isBoolean(value)
  };

  const useDialog = (props, emit) => {
    const rebound = vue.ref(false);
    const visible = vue.ref(false);
    const closed = vue.ref(false);
    const ns = useNamespace("dialog");
    const { nextZIndex } = useZIndex();
    const vsBaseClasses = useVuesaxBaseComponent(useColor());
    const zIndex = vue.ref(nextZIndex());
    const afterEnter = () => {
      emit("opened");
    };
    const beforeLeave = () => {
      emit("close");
    };
    const afterLeave = () => {
      emit("closed");
      emit(UPDATE_MODEL_EVENT, false);
    };
    const doOpen = () => {
      if (!isClient)
        return;
      visible.value = true;
    };
    const doClose = () => {
      visible.value = false;
    };
    const open = () => {
      doOpen();
    };
    const close = () => {
      const hide = (shouldCancel) => {
        if (shouldCancel)
          return;
        closed.value = true;
        visible.value = false;
      };
      if (props.beforeClose) {
        props.beforeClose(hide);
      } else {
        doClose();
      }
    };
    const handleClose = () => {
      if (props.preventClose) {
        rebound.value = true;
        useTimeoutFn(() => rebound.value = false, 300);
        return;
      }
      close();
    };
    if (props.lockScroll) {
      useLockscreen(visible);
    }
    vue.watch(
      () => props.modelValue,
      (val) => {
        if (val) {
          closed.value = false;
          rebound.value = true;
          open();
          zIndex.value = nextZIndex();
          if (props.lockScroll) {
            document.body.style.overflow = "hidden";
          }
          vue.nextTick(() => {
            emit("open");
          });
        } else {
          rebound.value = false;
          if (props.lockScroll) {
            document.body.style.overflow = "";
          }
          if (visible.value) {
            close();
          }
        }
      }
    );
    const dialogKls = vue.computed(() => [
      ns.b("original"),
      vsBaseClasses,
      ns.m(props.shape),
      {
        [ns.m("rebound")]: rebound.value,
        [ns.m("not-padding")]: props.notPadding,
        [ns.m("auto-width")]: props.autoWidth,
        [ns.m("scroll")]: props.scroll,
        [ns.m("loading")]: props.loading,
        [ns.m("not-center")]: props.notCenter
      }
    ]);
    const dialogStyles = vue.computed(() => ({
      width: props.width,
      ...ns.cssVar({
        color: getVsColor(props.color)
      })
    }));
    vue.onMounted(() => {
      if (props.modelValue) {
        visible.value = true;
        open();
      }
    });
    return {
      afterEnter,
      afterLeave,
      beforeLeave,
      handleClose,
      close,
      doClose,
      zIndex,
      closed,
      visible,
      dialogKls,
      dialogStyles
    };
  };

  const dialogDeprecated = (props) => {
    useDeprecated(
      {
        from: "overflowHidden",
        scope: "vs-dialog",
        version: "v0.1.0",
        type: "Prop",
        ref: "https://vuesax-alpha.vercel.app/components/dialog#lockScroll",
        replacement: "lockScroll"
      },
      vue.computed(() => !!props.overflowHidden)
    );
  };

  const __default__$y = vue.defineComponent({
    name: "VsDialog"
  });
  const _sfc_main$A = vue.defineComponent({
    ...__default__$y,
    props: dialogProps,
    emits: dialogEmits,
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      usePopperContainer();
      const { selector } = usePopperContainerId();
      const ns = useNamespace("dialog");
      dialogDeprecated(props);
      const {
        visible,
        zIndex,
        dialogKls,
        dialogStyles,
        close,
        afterEnter,
        afterLeave,
        beforeLeave,
        handleClose
      } = useDialog(props, emit);
      useModal({ handleClose }, visible);
      const clickDialog = useSameTarget(handleClose);
      const rootKls = vue.computed(() => [
        ns.b(),
        ns.is("full-screen", props.fullScreen),
        ns.is("blur", props.overlayBlur)
      ]);
      __expose({
        visible,
        close
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.Teleport, { to: vue.unref(selector) }, [
          vue.createVNode(vue.Transition, {
            name: vue.unref(ns).b(),
            onAfterEnter: vue.unref(afterEnter),
            onAfterLeave: vue.unref(afterLeave),
            onBeforeLeave: vue.unref(beforeLeave)
          }, {
            default: vue.withCtx(() => [
              vue.unref(visible) ? (vue.openBlock(), vue.createElementBlock(
                "div",
                {
                  key: 0,
                  class: vue.normalizeClass(rootKls.value),
                  style: vue.normalizeStyle({ zIndex: vue.unref(zIndex) }),
                  onClick: _cache[1] || (_cache[1] = (...args) => vue.unref(clickDialog).onClick && vue.unref(clickDialog).onClick(...args)),
                  onMousedown: _cache[2] || (_cache[2] = (...args) => vue.unref(clickDialog).onMousedown && vue.unref(clickDialog).onMousedown(...args)),
                  onMouseup: _cache[3] || (_cache[3] = (...args) => vue.unref(clickDialog).onMouseup && vue.unref(clickDialog).onMouseup(...args))
                },
                [
                  vue.createElementVNode(
                    "div",
                    {
                      style: vue.normalizeStyle(vue.unref(dialogStyles)),
                      class: vue.normalizeClass(vue.unref(dialogKls))
                    },
                    [
                      _ctx.loading ? (vue.openBlock(), vue.createElementBlock(
                        "div",
                        {
                          key: 0,
                          class: vue.normalizeClass(vue.unref(ns).e("loading"))
                        },
                        [
                          vue.createVNode(vue.unref(IconLoading))
                        ],
                        2
                      )) : vue.createCommentVNode("v-if", true),
                      !_ctx.notClose ? (vue.openBlock(), vue.createElementBlock(
                        "button",
                        {
                          key: 1,
                          class: vue.normalizeClass(vue.unref(ns).e("close")),
                          onClick: _cache[0] || (_cache[0] = (...args) => vue.unref(close) && vue.unref(close)(...args))
                        },
                        [
                          vue.createVNode(vue.unref(IconClose), { hover: "x" })
                        ],
                        2
                      )) : vue.createCommentVNode("v-if", true),
                      _ctx.$slots.header ? (vue.openBlock(), vue.createElementBlock(
                        "div",
                        {
                          key: 2,
                          class: vue.normalizeClass(vue.unref(ns).e("header"))
                        },
                        [
                          vue.renderSlot(_ctx.$slots, "header")
                        ],
                        2
                      )) : vue.createCommentVNode("v-if", true),
                      vue.createElementVNode(
                        "div",
                        {
                          class: vue.normalizeClass([vue.unref(ns).e("content"), { notFooter: !_ctx.$slots.footer }])
                        },
                        [
                          vue.renderSlot(_ctx.$slots, "default")
                        ],
                        2
                      ),
                      _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock(
                        "div",
                        {
                          key: 3,
                          class: vue.normalizeClass(vue.unref(ns).e("footer"))
                        },
                        [
                          vue.renderSlot(_ctx.$slots, "footer")
                        ],
                        2
                      )) : vue.createCommentVNode("v-if", true)
                    ],
                    6
                  )
                ],
                38
              )) : vue.createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])
        ], 8, ["to"]);
      };
    }
  });
  var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__file", "dialog.vue"]]);

  const VsDialog = withInstall(Dialog);

  const inputProps = buildProps({
    clearable: {
      type: Boolean,
      default: false
    },
    color: useColorProp,
    disabled: { type: Boolean },
    iconAfter: { type: Boolean },
    id: {
      type: String,
      default: null
    },
    inputStyle: {
      type: String,
      values: ["border", "shadow", "transparent"],
      default: null
    },
    labelFloat: {
      type: Boolean,
      default: false
    },
    label: {
      type: String,
      default: null
    },
    loading: { type: Boolean },
    modelValue: {
      type: definePropType([String, Number]),
      default: ""
    },
    placeholder: {
      type: String,
      default: null
    },
    progress: { type: Number },
    shape: {
      type: String,
      values: ["rounded", "square"],
      default: "rounded"
    },
    showPassword: {
      type: Boolean,
      default: false
    },
    state: useColorProp,
    textWhite: { type: Boolean },
    type: {
      type: String,
      default: "text"
    },
    wrapClasses: {
      type: String
    },
    wrapStyles: {
      type: definePropType([String, Object, Array])
    },
    block: { type: Boolean },
    border: Boolean,
    labelPlaceholder: String,
    shadow: Boolean,
    square: Boolean,
    transparent: Boolean
  });
  const inputEmits = {
    [UPDATE_MODEL_EVENT]: (text) => isString(text) || isNumber(text) || isNil(text),
    clickIcon: (evt) => evt instanceof Event,
    mouseleave: (evt) => evt instanceof MouseEvent,
    mouseenter: (evt) => evt instanceof MouseEvent,
    clear: () => true,
    input: (value) => !isNil(value),
    change: (value) => isString(value),
    focus: (evt) => evt instanceof FocusEvent,
    blur: (evt) => evt instanceof FocusEvent,
    keydown: (evt) => evt instanceof Event
  };

  const useInputClearable = (props, {
    hovering,
    focused
  }) => {
    const { emit } = vue.getCurrentInstance();
    const clear = () => {
      if (props.disabled || props.loading)
        return;
      emit(UPDATE_MODEL_EVENT, "");
      emit("change", "");
      emit("clear");
      emit("input", "");
    };
    const showClear = vue.computed(
      () => props.clearable && !props.disabled && !props.loading && String(props.modelValue) && (focused.value || hovering.value)
    );
    return {
      clear,
      showClear
    };
  };

  const useInputEvent = ({
    inputRef
  }) => {
    const { emit } = vue.getCurrentInstance();
    const focused = vue.ref(false);
    const handleInput = (event) => {
      const { value } = event.target;
      emit("input", value);
    };
    const blur = () => {
      var _a;
      return (_a = inputRef.value) == null ? void 0 : _a.blur();
    };
    const handleBlur = (event) => {
      focused.value = false;
      emit("blur", event);
    };
    const select = () => {
      var _a;
      return (_a = inputRef.value) == null ? void 0 : _a.select();
    };
    const handleKeydown = (evt) => {
      emit("keydown", evt);
    };
    const focus = async () => {
      var _a;
      await vue.nextTick();
      (_a = inputRef.value) == null ? void 0 : _a.focus();
    };
    const handleFocus = (event) => {
      focused.value = true;
      emit("focus", event);
    };
    const handleChange = (event) => {
      emit("change", event.target.value);
    };
    return {
      handleInput,
      handleChange,
      blur,
      handleBlur,
      focused,
      focus,
      handleFocus,
      handleKeydown,
      select
    };
  };

  const useInput = (props, emit) => {
    const model = vue.computed({
      get: () => props.modelValue,
      set: (value) => {
        if (props.disabled || props.loading)
          return;
        emit(UPDATE_MODEL_EVENT, value);
      }
    });
    const hovering = vue.ref(false);
    const inputRef = vue.shallowRef();
    const isVisiblePassword = vue.ref(false);
    const {
      blur,
      handleBlur,
      handleInput,
      handleChange,
      focused,
      focus,
      handleFocus,
      select,
      handleKeydown
    } = useInputEvent({ inputRef });
    const { clear, showClear } = useInputClearable(props, { hovering, focused });
    const handleMouseLeave = (evt) => {
      hovering.value = false;
      emit("mouseleave", evt);
    };
    const handleMouseEnter = (evt) => {
      hovering.value = true;
      emit("mouseenter", evt);
    };
    const inputType = vue.computed(() => {
      if (props.showPassword) {
        if (!isVisiblePassword.value)
          return "password";
        return "text";
      }
      return props.type;
    });
    const clickIcon = (evs) => {
      focus();
      emit("clickIcon", evs);
    };
    const isShowPassword = vue.computed(
      () => props.showPassword && !props.disabled && !props.loading && String(props.modelValue)
    );
    const handleShowPassword = () => {
      if (props.disabled || props.loading)
        return;
      isVisiblePassword.value = !isVisiblePassword.value;
    };
    return {
      model,
      inputType,
      isVisiblePassword,
      inputRef,
      isShowPassword,
      focused,
      hovering,
      handleInput,
      focus,
      handleFocus,
      handleKeydown,
      blur,
      handleBlur,
      handleChange,
      select,
      clickIcon,
      handleShowPassword,
      handleMouseLeave,
      handleMouseEnter,
      clear,
      showClear
    };
  };

  const _hoisted_1$e = ["id", "type", "disabled"];
  const _hoisted_2$9 = ["for"];
  const _hoisted_3$3 = ["for"];
  const __default__$x = vue.defineComponent({
    inheritAttrs: false,
    name: "VsInput"
  });
  const _sfc_main$z = vue.defineComponent({
    ...__default__$x,
    props: inputProps,
    emits: inputEmits,
    setup(__props, { expose: __expose, emit }) {
      var _a;
      const props = __props;
      const slots = vue.useSlots();
      useDeprecated(
        {
          from: "border",
          type: "Prop",
          version: "VuesaxAlpha",
          scope: "vs-input",
          ref: "https://vuesax-alpha.vercel.app/components/input#style",
          replacement: "inputStyle"
        },
        vue.computed(() => props.border)
      );
      useDeprecated(
        {
          from: "shadow",
          type: "Prop",
          version: "VuesaxAlpha",
          scope: "vs-input",
          ref: "https://vuesax-alpha.vercel.app/components/input#style",
          replacement: "inputStyle"
        },
        vue.computed(() => props.shadow)
      );
      useDeprecated(
        {
          from: "transparent",
          type: "Prop",
          version: "VuesaxAlpha",
          scope: "vs-input",
          ref: "https://vuesax-alpha.vercel.app/components/input#style",
          replacement: "inputStyle"
        },
        vue.computed(() => props.transparent)
      );
      useDeprecated(
        {
          from: "labelPlaceholder",
          type: "Prop",
          version: "VuesaxAlpha",
          scope: "vs-input",
          ref: "https://vuesax-alpha.vercel.app/components/input#label",
          replacement: "labelFloat"
        },
        vue.computed(() => !!props.labelPlaceholder)
      );
      useDeprecated(
        {
          from: "square",
          type: "Prop",
          version: "VuesaxAlpha",
          scope: "vs-input",
          ref: "https://vuesax-alpha.vercel.app/components/input#shape",
          replacement: "shape"
        },
        vue.computed(() => !!props.square)
      );
      const ns = useNamespace("input");
      const inputId = (_a = props.id) != null ? _a : useId();
      const messageType = ["success", "warn", "danger", "primary", "dark"];
      const {
        model,
        inputType,
        isVisiblePassword,
        isShowPassword,
        focused,
        hovering,
        inputRef,
        blur,
        handleBlur,
        handleKeydown,
        focus,
        handleFocus,
        handleChange,
        select,
        clickIcon,
        handleShowPassword,
        handleMouseLeave,
        handleMouseEnter,
        handleInput,
        showClear,
        clear
      } = useInput(props, emit);
      const vsBaseClasses = useVuesaxBaseComponent(useColor());
      const inputKls = vue.computed(() => [
        vsBaseClasses,
        ns.b(),
        props.wrapClasses,
        { [ns.is(props.inputStyle)]: !!props.inputStyle },
        ns.is("block", props.block),
        ns.is("focus", focused.value),
        ns.is("hovering", hovering.value),
        ns.is(props.shape),
        ns.is("text-white", props.textWhite),
        { [ns.m(`state-${props.state}`)]: !!props.state },
        { [ns.m("has-label")]: props.label || props.labelFloat },
        { [ns.m("has-color")]: props.color },
        { [ns.m("has-icon")]: slots.icon },
        { [ns.m("icon-after")]: props.iconAfter },
        { [ns.m("icon-eye")]: props.showPassword },
        { [ns.m("icon-clearable")]: showClear.value }
      ]);
      const inputStyle = vue.computed(() => [
        ns.cssVar({
          color: getVsColor(props.color)
        }),
        props.wrapStyles
      ]);
      const progressState = vue.computed(() => {
        const progress = useProp("progress");
        if (!progress.value || progress.value <= 33)
          return "danger";
        if (progress.value <= 66)
          return "warn";
        return "success";
      });
      __expose({
        focus,
        blur,
        select,
        clear,
        inputRef
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(inputKls.value),
            style: vue.normalizeStyle(inputStyle.value)
          },
          [
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass([vue.unref(ns).e("wrapper"), vue.unref(ns).is("disabled", _ctx.disabled)]),
                onMouseenter: _cache[13] || (_cache[13] = (...args) => vue.unref(handleMouseEnter) && vue.unref(handleMouseEnter)(...args)),
                onMouseleave: _cache[14] || (_cache[14] = (...args) => vue.unref(handleMouseLeave) && vue.unref(handleMouseLeave)(...args))
              },
              [
                vue.withDirectives(vue.createElementVNode("input", vue.mergeProps(_ctx.$attrs, {
                  id: vue.unref(inputId),
                  ref_key: "inputRef",
                  ref: inputRef,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.isRef(model) ? model.value = $event : null),
                  type: vue.unref(inputType),
                  disabled: _ctx.disabled,
                  class: [vue.unref(ns).e("original"), vue.unref(ns).is("disabled", _ctx.disabled)],
                  placeholder: "",
                  onInput: _cache[1] || (_cache[1] = (...args) => vue.unref(handleInput) && vue.unref(handleInput)(...args)),
                  onFocus: _cache[2] || (_cache[2] = (...args) => vue.unref(handleFocus) && vue.unref(handleFocus)(...args)),
                  onBlur: _cache[3] || (_cache[3] = (...args) => vue.unref(handleBlur) && vue.unref(handleBlur)(...args)),
                  onChange: _cache[4] || (_cache[4] = (...args) => vue.unref(handleChange) && vue.unref(handleChange)(...args)),
                  onKeydown: _cache[5] || (_cache[5] = (...args) => vue.unref(handleKeydown) && vue.unref(handleKeydown)(...args))
                }), null, 16, _hoisted_1$e), [
                  [vue.vModelDynamic, vue.unref(model)]
                ]),
                _ctx.placeholder || _ctx.labelFloat ? (vue.openBlock(), vue.createElementBlock("label", {
                  key: 0,
                  for: vue.unref(inputId),
                  class: vue.normalizeClass([
                    vue.unref(ns).e("placeholder"),
                    { [vue.unref(ns).em("placeholder", "float")]: _ctx.labelFloat },
                    {
                      [vue.unref(ns).em("placeholder", "hidden")]: vue.unref(model) || vue.unref(model) === 0 || vue.unref(inputType) == "date" || vue.unref(inputType) == "time"
                    }
                  ]),
                  onMousedown: _cache[6] || (_cache[6] = vue.withModifiers(
                    (...args) => vue.unref(NOOP) && vue.unref(NOOP)(...args),
                    ["prevent"]
                  ))
                }, vue.toDisplayString(_ctx.placeholder || _ctx.label), 43, _hoisted_2$9)) : vue.createCommentVNode("v-if", true),
                !_ctx.labelFloat ? (vue.openBlock(), vue.createElementBlock("label", {
                  key: 1,
                  for: vue.unref(inputId),
                  class: vue.normalizeClass([vue.unref(ns).e("label")]),
                  onMousedown: _cache[7] || (_cache[7] = vue.withModifiers(
                    (...args) => vue.unref(NOOP) && vue.unref(NOOP)(...args),
                    ["prevent"]
                  ))
                }, vue.toDisplayString(_ctx.label), 43, _hoisted_3$3)) : vue.createCommentVNode("v-if", true),
                _ctx.$slots.icon ? (vue.openBlock(), vue.createElementBlock(
                  "span",
                  {
                    key: 2,
                    class: vue.normalizeClass([vue.unref(ns).e("icon")]),
                    onMousedown: _cache[8] || (_cache[8] = vue.withModifiers(
                      (...args) => vue.unref(NOOP) && vue.unref(NOOP)(...args),
                      ["prevent"]
                    )),
                    onClick: _cache[9] || (_cache[9] = (...args) => vue.unref(clickIcon) && vue.unref(clickIcon)(...args))
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "icon")
                  ],
                  34
                )) : vue.createCommentVNode("v-if", true),
                _ctx.loading ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 3,
                    class: vue.normalizeClass(vue.unref(ns).e("loading"))
                  },
                  [
                    vue.createVNode(vue.unref(IconLoading))
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true),
                vue.createVNode(vue.Transition, { name: "clearable-transition" }, {
                  default: vue.withCtx(() => [
                    vue.unref(showClear) ? (vue.openBlock(), vue.createElementBlock(
                      "div",
                      {
                        key: 0,
                        class: vue.normalizeClass(vue.unref(ns).e("clearable"))
                      },
                      [
                        vue.createVNode(vue.unref(IconClose), {
                          onClick: vue.unref(clear),
                          onMousedown: vue.withModifiers(vue.unref(NOOP), ["prevent"])
                        }, null, 8, ["onClick", "onMousedown"])
                      ],
                      2
                    )) : vue.createCommentVNode("v-if", true)
                  ]),
                  _: 1
                }),
                vue.createVNode(vue.Transition, { name: "clearable-transition" }, {
                  default: vue.withCtx(() => [
                    vue.unref(isShowPassword) ? (vue.openBlock(), vue.createElementBlock(
                      "span",
                      {
                        key: 0,
                        class: vue.normalizeClass(vue.unref(ns).em("icon", "password")),
                        onClick: _cache[11] || (_cache[11] = (...args) => vue.unref(handleShowPassword) && vue.unref(handleShowPassword)(...args)),
                        onMousedown: _cache[12] || (_cache[12] = vue.withModifiers(
                          (...args) => vue.unref(NOOP) && vue.unref(NOOP)(...args),
                          ["prevent"]
                        ))
                      },
                      [
                        vue.createElementVNode(
                          "i",
                          {
                            class: vue.normalizeClass(["bx", vue.unref(isVisiblePassword) ? "bx-show-alt" : "bx-hide"]),
                            onMousedown: _cache[10] || (_cache[10] = vue.withModifiers(
                              (...args) => vue.unref(NOOP) && vue.unref(NOOP)(...args),
                              ["prevent"]
                            ))
                          },
                          null,
                          34
                        )
                      ],
                      34
                    )) : vue.createCommentVNode("v-if", true)
                  ]),
                  _: 1
                }),
                vue.createElementVNode(
                  "div",
                  {
                    class: vue.normalizeClass(vue.unref(ns).e("affects"))
                  },
                  [
                    vue.createElementVNode(
                      "div",
                      {
                        class: vue.normalizeClass(vue.unref(ns).em("affects", "1"))
                      },
                      null,
                      2
                    ),
                    vue.createElementVNode(
                      "div",
                      {
                        class: vue.normalizeClass(vue.unref(ns).em("affects", "2"))
                      },
                      null,
                      2
                    )
                  ],
                  2
                )
              ],
              34
            ),
            _ctx.progress ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass([vue.unref(ns).e("progress"), vue.unref(ns).em("progress", progressState.value)])
              },
              [
                vue.createElementVNode(
                  "div",
                  {
                    class: vue.normalizeClass(vue.unref(ns).em("progress", "bar")),
                    style: vue.normalizeStyle({ width: `${_ctx.progress}%` })
                  },
                  null,
                  6
                )
              ],
              2
            )) : vue.createCommentVNode("v-if", true),
            (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(messageType, (message) => {
                return vue.createVNode(
                  vue.unref(VsCollapseTransition),
                  { key: message },
                  {
                    default: vue.withCtx(() => [
                      _ctx.$slots[`message-${message}`] ? (vue.openBlock(), vue.createElementBlock(
                        "div",
                        {
                          key: 0,
                          class: vue.normalizeClass([vue.unref(ns).e("message"), vue.unref(ns).em("message", message)])
                        },
                        [
                          vue.renderSlot(_ctx.$slots, `message-${message}`)
                        ],
                        2
                      )) : vue.createCommentVNode("v-if", true)
                    ]),
                    _: 2
                  },
                  1024
                );
              }),
              64
            ))
          ],
          6
        );
      };
    }
  });
  var Input = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__file", "input.vue"]]);

  const VsInput = withInstall(Input);

  const nodeList = /* @__PURE__ */ new Map();
  let startClick;
  if (isClient) {
    document.addEventListener("mousedown", (e) => startClick = e);
    document.addEventListener("mouseup", (e) => {
      for (const handlers of nodeList.values()) {
        for (const { documentHandler } of handlers) {
          documentHandler(e, startClick);
        }
      }
    });
  }
  function createDocumentHandler(el, binding) {
    let excludes = [];
    if (Array.isArray(binding.arg)) {
      excludes = binding.arg;
    } else if (isElement$2(binding.arg)) {
      excludes.push(binding.arg);
    }
    return function(mouseup, mousedown) {
      const popperRef = binding.instance.popperRef;
      const mouseUpTarget = mouseup.target;
      const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
      const isBound = !binding || !binding.instance;
      const isTargetExists = !mouseUpTarget || !mouseDownTarget;
      const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
      const isSelf = el === mouseUpTarget;
      const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
      const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
      if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
        return;
      }
      binding.value(mouseup, mousedown);
    };
  }
  const ClickOutside = {
    beforeMount(el, binding) {
      if (!nodeList.has(el)) {
        nodeList.set(el, []);
      }
      nodeList.get(el).push({
        documentHandler: createDocumentHandler(el, binding),
        bindingFn: binding.value
      });
    },
    updated(el, binding) {
      if (!nodeList.has(el)) {
        nodeList.set(el, []);
      }
      const handlers = nodeList.get(el);
      const oldHandlerIndex = handlers.findIndex(
        (item) => item.bindingFn === binding.oldValue
      );
      const newHandler = {
        documentHandler: createDocumentHandler(el, binding),
        bindingFn: binding.value
      };
      if (oldHandlerIndex >= 0) {
        handlers.splice(oldHandlerIndex, 1, newHandler);
      } else {
        handlers.push(newHandler);
      }
    },
    unmounted(el) {
      nodeList.delete(el);
    }
  };

  const loading$1 = {
    mounted(el, binding) {
      const value = binding.value;
      if (isBoolean(value) || vue.isRef(value)) {
        return;
      }
    }
  };

  var v=!1,o,f,s,u,d,N,l,p,m,w,D,x,E,M,F;function a(){if(!v){v=!0;var e=navigator.userAgent,n=/(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e),i=/(Mac OS X)|(Windows)|(Linux)/.exec(e);if(x=/\b(iPhone|iP[ao]d)/.exec(e),E=/\b(iP[ao]d)/.exec(e),w=/Android/i.exec(e),M=/FBAN\/\w+;/i.exec(e),F=/Mobile/i.exec(e),D=!!/Win64/.exec(e),n){o=n[1]?parseFloat(n[1]):n[5]?parseFloat(n[5]):NaN,o&&document&&document.documentMode&&(o=document.documentMode);var r=/(?:Trident\/(\d+.\d+))/.exec(e);N=r?parseFloat(r[1])+4:o,f=n[2]?parseFloat(n[2]):NaN,s=n[3]?parseFloat(n[3]):NaN,u=n[4]?parseFloat(n[4]):NaN,u?(n=/(?:Chrome\/(\d+\.\d+))/.exec(e),d=n&&n[1]?parseFloat(n[1]):NaN):d=NaN;}else o=f=s=d=u=NaN;if(i){if(i[1]){var t=/(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);l=t?parseFloat(t[1].replace("_",".")):!0;}else l=!1;p=!!i[2],m=!!i[3];}else l=p=m=!1;}}var _={ie:function(){return a()||o},ieCompatibilityMode:function(){return a()||N>o},ie64:function(){return _.ie()&&D},firefox:function(){return a()||f},opera:function(){return a()||s},webkit:function(){return a()||u},safari:function(){return _.webkit()},chrome:function(){return a()||d},windows:function(){return a()||p},osx:function(){return a()||l},linux:function(){return a()||m},iphone:function(){return a()||x},mobile:function(){return a()||x||E||w||F},nativeApp:function(){return a()||M},android:function(){return a()||w},ipad:function(){return a()||E}},A=_;var c=!!(typeof window<"u"&&window.document&&window.document.createElement),U={canUseDOM:c,canUseWorkers:typeof Worker<"u",canUseEventListeners:c&&!!(window.addEventListener||window.attachEvent),canUseViewport:c&&!!window.screen,isInWorker:!c},h=U;var X;h.canUseDOM&&(X=document.implementation&&document.implementation.hasFeature&&document.implementation.hasFeature("","")!==!0);function S(e,n){if(!h.canUseDOM||n&&!("addEventListener"in document))return !1;var i="on"+e,r=i in document;if(!r){var t=document.createElement("div");t.setAttribute(i,"return;"),r=typeof t[i]=="function";}return !r&&X&&e==="wheel"&&(r=document.implementation.hasFeature("Events.wheel","3.0")),r}var b=S;var O=10,I=40,P=800;function T(e){var n=0,i=0,r=0,t=0;return "detail"in e&&(i=e.detail),"wheelDelta"in e&&(i=-e.wheelDelta/120),"wheelDeltaY"in e&&(i=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(n=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(n=i,i=0),r=n*O,t=i*O,"deltaY"in e&&(t=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||t)&&e.deltaMode&&(e.deltaMode==1?(r*=I,t*=I):(r*=P,t*=P)),r&&!n&&(n=r<1?-1:1),t&&!i&&(i=t<1?-1:1),{spinX:n,spinY:i,pixelX:r,pixelY:t}}T.getEventType=function(){return A.firefox()?"DOMMouseScroll":b("wheel")?"wheel":"mousewheel"};var Y=T;/**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @param {?boolean} capture Check if the capture phase is supported.
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   */

  const mousewheel = function(element, callback) {
    if (element && element.addEventListener) {
      const fn = function(event) {
        const normalized = Y(event);
        callback && Reflect.apply(callback, this, [event, normalized]);
      };
      element.addEventListener("wheel", fn, { passive: true });
    }
  };
  const Mousewheel = {
    beforeMount(el, binding) {
      mousewheel(el, binding.value);
    }
  };

  const REPEAT_INTERVAL = 100;
  const REPEAT_DELAY = 600;
  const RepeatClick = {
    beforeMount(el, binding) {
      const value = binding.value;
      const { interval = REPEAT_INTERVAL, delay = REPEAT_DELAY } = isFunction(
        value
      ) ? {} : value;
      let intervalId;
      let delayId;
      const handler = () => isFunction(value) ? value() : value.handler();
      const clear = () => {
        if (delayId) {
          clearTimeout(delayId);
          delayId = void 0;
        }
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = void 0;
        }
      };
      el.addEventListener("mousedown", (evt) => {
        if (evt.button !== 0)
          return;
        clear();
        handler();
        document.addEventListener("mouseup", () => clear(), {
          once: true
        });
        delayId = setTimeout(() => {
          intervalId = setInterval(() => {
            handler();
          }, interval);
        }, delay);
      });
    }
  };

  const FOCUSABLE_CHILDREN = "_trap-focus-children";
  const FOCUS_STACK = [];
  const FOCUS_HANDLER = (e) => {
    if (FOCUS_STACK.length === 0)
      return;
    const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
    if (focusableElement.length > 0 && e.code === EVENT_CODE.tab) {
      if (focusableElement.length === 1) {
        e.preventDefault();
        if (document.activeElement !== focusableElement[0]) {
          focusableElement[0].focus();
        }
        return;
      }
      const goingBackward = e.shiftKey;
      const isFirst = e.target === focusableElement[0];
      const isLast = e.target === focusableElement[focusableElement.length - 1];
      if (isFirst && goingBackward) {
        e.preventDefault();
        focusableElement[focusableElement.length - 1].focus();
      }
      if (isLast && !goingBackward) {
        e.preventDefault();
        focusableElement[0].focus();
      }
    }
  };
  const TrapFocus = {
    beforeMount(el) {
      el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
      FOCUS_STACK.push(el);
      if (FOCUS_STACK.length <= 1) {
        document.addEventListener("keydown", FOCUS_HANDLER);
      }
    },
    updated(el) {
      vue.nextTick(() => {
        el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
      });
    },
    unmounted() {
      FOCUS_STACK.shift();
      if (FOCUS_STACK.length === 0) {
        document.removeEventListener("keydown", FOCUS_HANDLER);
      }
    }
  };

  var export_helper_default = (sfc, props) => {
    let target = sfc.__vccOpts || sfc;
    for (let [key, val] of props)
      target[key] = val;
    return target;
  };
  var chevron_down_vue_vue_type_script_lang_default = {
    name: "ChevronDown"
  };
  var _hoisted_159 = {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var _hoisted_259 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M12 16.8c-.7 0-1.4-.27-1.93-.8L3.55 9.48a.754.754 0 0 1 0-1.06c.29-.29.77-.29 1.06 0l6.52 6.52c.48.48 1.26.48 1.74 0l6.52-6.52c.29-.29.77-.29 1.06 0 .29.29.29.77 0 1.06L13.93 16c-.53.53-1.23.8-1.93.8Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_353 = [
    _hoisted_259
  ];
  function _sfc_render59(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_159, _hoisted_353);
  }
  var chevron_down_default = /* @__PURE__ */ export_helper_default(chevron_down_vue_vue_type_script_lang_default, [["render", _sfc_render59], ["__file", "chevron-down.vue"]]);
  var chevron_left_double_vue_vue_type_script_lang_default = {
    name: "ChevronLeftDouble"
  };
  var _hoisted_161 = {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var _hoisted_261 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M18.0052 20.67C17.8152 20.67 17.6252 20.6 17.4752 20.45L10.9552 13.93C9.89516 12.87 9.89516 11.13 10.9552 10.07L17.4752 3.55002C17.7652 3.26002 18.2452 3.26002 18.5352 3.55002C18.8252 3.84002 18.8252 4.32002 18.5352 4.61002L12.0152 11.13C11.5352 11.61 11.5352 12.39 12.0152 12.87L18.5352 19.39C18.8252 19.68 18.8252 20.16 18.5352 20.45C18.3852 20.59 18.1952 20.67 18.0052 20.67Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_355 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M12.0052 20.67C11.8152 20.67 11.6252 20.6 11.4752 20.45L4.95516 13.93C3.89516 12.87 3.89516 11.13 4.95516 10.07L11.4752 3.55002C11.7652 3.26002 12.2452 3.26002 12.5352 3.55002C12.8252 3.84002 12.8252 4.32002 12.5352 4.61002L6.01516 11.13C5.53516 11.61 5.53516 12.39 6.01516 12.87L12.5352 19.39C12.8252 19.68 12.8252 20.16 12.5352 20.45C12.3852 20.59 12.1952 20.67 12.0052 20.67Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_434 = [
    _hoisted_261,
    _hoisted_355
  ];
  function _sfc_render61(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_161, _hoisted_434);
  }
  var chevron_left_double_default = /* @__PURE__ */ export_helper_default(chevron_left_double_vue_vue_type_script_lang_default, [["render", _sfc_render61], ["__file", "chevron-left-double.vue"]]);
  var chevron_left_vue_vue_type_script_lang_default = {
    name: "ChevronLeft"
  };
  var _hoisted_162 = {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var _hoisted_262 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M15 20.67c-.19 0-.38-.07-.53-.22l-6.52-6.52a2.74 2.74 0 0 1 0-3.86l6.52-6.52c.29-.29.77-.29 1.06 0 .29.29.29.77 0 1.06l-6.52 6.52c-.48.48-.48 1.26 0 1.74l6.52 6.52c.29.29.29.77 0 1.06-.15.14-.34.22-.53.22Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_356 = [
    _hoisted_262
  ];
  function _sfc_render62(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_162, _hoisted_356);
  }
  var chevron_left_default = /* @__PURE__ */ export_helper_default(chevron_left_vue_vue_type_script_lang_default, [["render", _sfc_render62], ["__file", "chevron-left.vue"]]);
  var chevron_right_double_vue_vue_type_script_lang_default = {
    name: "ChevronRightDouble"
  };
  var _hoisted_164 = {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var _hoisted_264 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M11.9077 20.67C11.7177 20.67 11.5277 20.6 11.3777 20.45C11.0877 20.16 11.0877 19.68 11.3777 19.39L17.8977 12.87C18.3777 12.39 18.3777 11.61 17.8977 11.13L11.3777 4.61002C11.0877 4.32002 11.0877 3.84002 11.3777 3.55002C11.6677 3.26002 12.1477 3.26002 12.4377 3.55002L18.9577 10.07C19.4677 10.58 19.7577 11.27 19.7577 12C19.7577 12.73 19.4777 13.42 18.9577 13.93L12.4377 20.45C12.2877 20.59 12.0977 20.67 11.9077 20.67Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_358 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M5.90766 20.67C5.71766 20.67 5.52766 20.6 5.37766 20.45C5.08766 20.16 5.08766 19.68 5.37766 19.39L11.8977 12.87C12.3777 12.39 12.3777 11.61 11.8977 11.13L5.37766 4.61002C5.08766 4.32002 5.08766 3.84002 5.37766 3.55002C5.66766 3.26002 6.14766 3.26002 6.43766 3.55002L12.9577 10.07C13.4677 10.58 13.7577 11.27 13.7577 12C13.7577 12.73 13.4777 13.42 12.9577 13.93L6.43766 20.45C6.28766 20.59 6.09766 20.67 5.90766 20.67Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_435 = [
    _hoisted_264,
    _hoisted_358
  ];
  function _sfc_render64(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_164, _hoisted_435);
  }
  var chevron_right_double_default = /* @__PURE__ */ export_helper_default(chevron_right_double_vue_vue_type_script_lang_default, [["render", _sfc_render64], ["__file", "chevron-right-double.vue"]]);
  var chevron_right_vue_vue_type_script_lang_default = {
    name: "ChevronRight"
  };
  var _hoisted_165 = {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var _hoisted_265 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M8.91 20.67c-.19 0-.38-.07-.53-.22a.754.754 0 0 1 0-1.06l6.52-6.52c.48-.48.48-1.26 0-1.74L8.38 4.61a.754.754 0 0 1 0-1.06c.29-.29.77-.29 1.06 0l6.52 6.52c.51.51.8 1.2.8 1.93s-.28 1.42-.8 1.93l-6.52 6.52c-.15.14-.34.22-.53.22Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_359 = [
    _hoisted_265
  ];
  function _sfc_render65(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_165, _hoisted_359);
  }
  var chevron_right_default = /* @__PURE__ */ export_helper_default(chevron_right_vue_vue_type_script_lang_default, [["render", _sfc_render65], ["__file", "chevron-right.vue"]]);
  var close_circle_vue_vue_type_script_lang_default = {
    name: "CloseCircle"
  };
  var _hoisted_171 = {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var _hoisted_271 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M12 22.75C6.07 22.75 1.25 17.93 1.25 12S6.07 1.25 12 1.25 22.75 6.07 22.75 12 17.93 22.75 12 22.75Zm0-20C6.9 2.75 2.75 6.9 2.75 12S6.9 21.25 12 21.25s9.25-4.15 9.25-9.25S17.1 2.75 12 2.75Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_365 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M9.17 15.58c-.19 0-.38-.07-.53-.22a.754.754 0 0 1 0-1.06l5.66-5.66c.29-.29.77-.29 1.06 0 .29.29.29.77 0 1.06L9.7 15.36c-.14.15-.34.22-.53.22Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_438 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M14.83 15.58c-.19 0-.38-.07-.53-.22L8.64 9.7a.754.754 0 0 1 0-1.06c.29-.29.77-.29 1.06 0l5.66 5.66c.29.29.29.77 0 1.06-.15.15-.34.22-.53.22Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_521 = [
    _hoisted_271,
    _hoisted_365,
    _hoisted_438
  ];
  function _sfc_render71(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_171, _hoisted_521);
  }
  var close_circle_default = /* @__PURE__ */ export_helper_default(close_circle_vue_vue_type_script_lang_default, [["render", _sfc_render71], ["__file", "close-circle.vue"]]);
  var message_question_vue_vue_type_script_lang_default = {
    name: "MessageQuestion"
  };
  var _hoisted_1225 = {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var _hoisted_2225 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M8 22.32c-.28 0-.57-.07-.83-.21-.57-.3-.92-.9-.92-1.54v-1.42c-3.02-.31-5-2.53-5-5.71v-6C1.25 4 3.56 1.69 7 1.69h10c3.44 0 5.75 2.31 5.75 5.75v6c0 3.44-2.31 5.75-5.75 5.75h-3.77l-4.26 2.84c-.29.19-.63.29-.97.29ZM7 3.18c-2.58 0-4.25 1.67-4.25 4.25v6c0 2.58 1.67 4.25 4.25 4.25.41 0 .75.34.75.75v2.13c0 .13.08.19.13.22s.15.06.26-.01l4.45-2.96c.12-.08.27-.13.42-.13h4c2.58 0 4.25-1.67 4.25-4.25v-6c0-2.58-1.67-4.25-4.25-4.25H7Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_3190 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M12 12.11c-.41 0-.75-.34-.75-.75v-.21c0-1.16.85-1.73 1.17-1.95.37-.25.49-.42.49-.68 0-.5-.41-.91-.91-.91s-.91.41-.91.91c0 .41-.34.75-.75.75s-.75-.34-.75-.75c0-1.33 1.08-2.41 2.41-2.41s2.41 1.08 2.41 2.41c0 1.14-.84 1.71-1.15 1.92-.39.26-.51.43-.51.71v.21c0 .42-.34.75-.75.75ZM12 14.6a.749.749 0 1 1-.002-1.498A.749.749 0 0 1 12 14.6Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_4132 = [
    _hoisted_2225,
    _hoisted_3190
  ];
  function _sfc_render225(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1225, _hoisted_4132);
  }
  var message_question_default = /* @__PURE__ */ export_helper_default(message_question_vue_vue_type_script_lang_default, [["render", _sfc_render225], ["__file", "message-question.vue"]]);
  var minus_vue_vue_type_script_lang_default = {
    name: "Minus"
  };
  var _hoisted_1242 = {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var _hoisted_2242 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M18 12.75H6c-.41 0-.75-.34-.75-.75s.34-.75.75-.75h12c.41 0 .75.34.75.75s-.34.75-.75.75Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_3203 = [
    _hoisted_2242
  ];
  function _sfc_render242(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1242, _hoisted_3203);
  }
  var minus_default = /* @__PURE__ */ export_helper_default(minus_vue_vue_type_script_lang_default, [["render", _sfc_render242], ["__file", "minus.vue"]]);
  var plus_vue_vue_type_script_lang_default = {
    name: "Plus"
  };
  var _hoisted_1270 = {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var _hoisted_2270 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M18 12.75H6c-.41 0-.75-.34-.75-.75s.34-.75.75-.75h12c.41 0 .75.34.75.75s-.34.75-.75.75Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_3225 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M12 18.75c-.41 0-.75-.34-.75-.75V6c0-.41.34-.75.75-.75s.75.34.75.75v12c0 .41-.34.75-.75.75Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_4157 = [
    _hoisted_2270,
    _hoisted_3225
  ];
  function _sfc_render270(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1270, _hoisted_4157);
  }
  var plus_default = /* @__PURE__ */ export_helper_default(plus_vue_vue_type_script_lang_default, [["render", _sfc_render270], ["__file", "plus.vue"]]);
  var star_bold_vue_vue_type_script_lang_default = {
    name: "StarBold"
  };
  var _hoisted_1335 = {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var _hoisted_2335 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "m13.73 3.51 1.76 3.52c.24.49.88.96 1.42 1.05l3.19.53c2.04.34 2.52 1.82 1.05 3.28l-2.48 2.48c-.42.42-.65 1.23-.52 1.81l.71 3.07c.56 2.43-.73 3.37-2.88 2.1l-2.99-1.77c-.54-.32-1.43-.32-1.98 0l-2.99 1.77c-2.14 1.27-3.44.32-2.88-2.1l.71-3.07c.13-.58-.1-1.39-.52-1.81l-2.48-2.48c-1.46-1.46-.99-2.94 1.05-3.28l3.19-.53c.53-.09 1.17-.56 1.41-1.05l1.76-3.52c.96-1.91 2.52-1.91 3.47 0Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_3286 = [
    _hoisted_2335
  ];
  function _sfc_render335(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1335, _hoisted_3286);
  }
  var star_bold_default = /* @__PURE__ */ export_helper_default(star_bold_vue_vue_type_script_lang_default, [["render", _sfc_render335], ["__file", "star-bold.vue"]]);
  var star_vue_vue_type_script_lang_default = {
    name: "Star"
  };
  var _hoisted_1336 = {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var _hoisted_2336 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M17.66 22.67c-.53 0-1.21-.17-2.06-.67l-2.99-1.77c-.31-.18-.91-.18-1.21 0L8.4 22c-1.77 1.05-2.81.63-3.28.29-.46-.34-1.18-1.21-.71-3.21l.71-3.07c.08-.32-.08-.87-.32-1.11l-2.48-2.48c-1.24-1.24-1.14-2.3-.97-2.82.17-.52.71-1.44 2.43-1.73l3.19-.53c.3-.05.73-.37.86-.64L9.6 3.17c.8-1.61 1.85-1.85 2.4-1.85.55 0 1.6.24 2.4 1.85l1.76 3.52c.14.27.57.59.87.64l3.19.53c1.73.29 2.27 1.21 2.43 1.73.16.52.26 1.58-.97 2.82L19.2 14.9c-.24.24-.39.78-.32 1.11l.71 3.07c.46 2-.25 2.87-.71 3.21-.25.18-.65.38-1.22.38ZM12 18.59c.49 0 .98.12 1.37.35l2.99 1.77c.87.52 1.42.52 1.63.37.21-.15.36-.68.14-1.66l-.71-3.07c-.19-.83.12-1.9.72-2.51l2.48-2.48c.49-.49.71-.97.61-1.3-.11-.33-.57-.6-1.25-.71l-3.19-.53c-.77-.13-1.61-.75-1.96-1.45l-1.76-3.52c-.32-.64-.72-1.02-1.07-1.02-.35 0-.75.38-1.06 1.02L9.17 7.37c-.35.7-1.19 1.32-1.96 1.45l-3.18.53c-.68.11-1.14.38-1.25.71-.11.33.12.82.61 1.3l2.48 2.48c.6.6.91 1.68.72 2.51l-.71 3.07c-.23.99-.07 1.51.14 1.66.21.15.75.14 1.63-.37l2.99-1.77c.38-.23.87-.35 1.36-.35Z",
    fill: "currentColor"
  }, null, -1);
  var _hoisted_3287 = [
    _hoisted_2336
  ];
  function _sfc_render336(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1336, _hoisted_3287);
  }
  var star_default = /* @__PURE__ */ export_helper_default(star_vue_vue_type_script_lang_default, [["render", _sfc_render336], ["__file", "star.vue"]]);
  /*! Vuesax Alpha Icons Vue v0.0.2-beta.12 */

  const inputNumberProps = buildProps({
    color: useColorProp,
    background: useColorProp,
    id: {
      type: String,
      default: void 0
    },
    step: {
      type: Number,
      default: 1
    },
    stepStrictly: { type: Boolean },
    max: {
      type: Number,
      default: Number.POSITIVE_INFINITY
    },
    min: {
      type: Number,
      default: Number.NEGATIVE_INFINITY
    },
    modelValue: { type: Number },
    readonly: { type: Boolean },
    disabled: { type: Boolean },
    controls: {
      type: Boolean,
      default: true
    },
    valueOnClear: {
      type: [String, Number, null],
      validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
      default: null
    },
    name: { type: String },
    label: { type: String },
    placeholder: { type: String },
    precision: {
      type: Number,
      validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
    }
  });
  const inputNumberEmits = {
    [CHANGE_EVENT]: (cur, prev) => prev !== cur,
    blur: (e) => e instanceof FocusEvent,
    focus: (e) => e instanceof FocusEvent,
    [INPUT_EVENT]: (val) => isNumber(val) || isNil(val),
    [UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil(val)
  };

  const _hoisted_1$d = ["onKeydown"];
  const _hoisted_2$8 = ["onKeydown"];
  const __default__$w = vue.defineComponent({
    name: "VsInputNumber"
  });
  const _sfc_main$y = vue.defineComponent({
    ...__default__$w,
    props: inputNumberProps,
    emits: inputNumberEmits,
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const ns = useNamespace("input-number");
      const input = vue.ref();
      const data = vue.reactive({
        currentValue: props.modelValue,
        userInput: null
      });
      const wrapperStyle = vue.computed(() => ({
        [ns.cssVarBlockName("color")]: getVsColor(props.color),
        [ns.cssVarBlockName("background")]: getVsColor(props.background)
      }));
      const isDisabled = useDisabled(vue.toRef(props, "disabled"));
      const minDisabled = vue.computed(
        () => isNumber(props.modelValue) && props.modelValue <= props.min
      );
      const maxDisabled = vue.computed(
        () => isNumber(props.modelValue) && props.modelValue >= props.max
      );
      const numPrecision = vue.computed(() => {
        const stepPrecision = getPrecision(props.step);
        if (!isUndefined(props.precision)) {
          if (stepPrecision > props.precision) ;
          return props.precision;
        } else {
          return Math.max(getPrecision(props.modelValue), stepPrecision);
        }
      });
      const displayValue = vue.computed(() => {
        if (data.userInput !== null) {
          return data.userInput;
        }
        let currentValue = data.currentValue;
        if (isNil(currentValue))
          return "";
        if (isNumber(currentValue)) {
          if (Number.isNaN(currentValue))
            return "";
          if (!isUndefined(props.precision)) {
            currentValue = currentValue.toFixed(props.precision);
          }
        }
        return currentValue;
      });
      const toPrecision = (num, pre) => {
        if (isUndefined(pre))
          pre = numPrecision.value;
        if (pre === 0)
          return Math.round(num);
        let snum = String(num);
        const pointPos = snum.indexOf(".");
        if (pointPos === -1)
          return num;
        const nums = snum.replace(".", "").split("");
        const datum = nums[pointPos + pre];
        if (!datum)
          return num;
        const length = snum.length;
        if (snum.charAt(length - 1) === "5") {
          snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
        }
        return Number.parseFloat(Number(snum).toFixed(pre));
      };
      const getPrecision = (value) => {
        if (isNil(value))
          return 0;
        const valueString = value.toString();
        const dotPosition = valueString.indexOf(".");
        let precision = 0;
        if (dotPosition !== -1) {
          precision = valueString.length - dotPosition - 1;
        }
        return precision;
      };
      const ensurePrecision = (val, coefficient = 1) => {
        if (!isNumber(val))
          return data.currentValue;
        return toPrecision(val + props.step * coefficient);
      };
      const increase = () => {
        if (props.readonly || isDisabled.value || maxDisabled.value)
          return;
        const value = Number(displayValue.value) || 0;
        const newVal = ensurePrecision(value);
        setCurrentValue(newVal);
        emit(INPUT_EVENT, data.currentValue);
      };
      const decrease = () => {
        if (props.readonly || isDisabled.value || minDisabled.value)
          return;
        const value = Number(displayValue.value) || 0;
        const newVal = ensurePrecision(value, -1);
        setCurrentValue(newVal);
        emit(INPUT_EVENT, data.currentValue);
      };
      const verifyValue = (value, update) => {
        const { max, min, step, precision, stepStrictly, valueOnClear } = props;
        if (max < min) {
          throwError("InputNumber", "min should not be greater than max.");
        }
        let newVal = Number(value);
        if (isNil(value) || Number.isNaN(newVal)) {
          return null;
        }
        if (value === "") {
          if (valueOnClear === null) {
            return null;
          }
          newVal = isString(valueOnClear) ? { min, max }[valueOnClear] : valueOnClear;
        }
        if (stepStrictly) {
          newVal = toPrecision(Math.round(newVal / step) * step, precision);
        }
        if (!isUndefined(precision)) {
          newVal = toPrecision(newVal, precision);
        }
        if (newVal > max || newVal < min) {
          newVal = newVal > max ? max : min;
          update && emit(UPDATE_MODEL_EVENT, newVal);
        }
        return newVal;
      };
      const setCurrentValue = (value, emitChange = true) => {
        const oldVal = data.currentValue;
        const newVal = verifyValue(value);
        if (!emitChange) {
          emit(UPDATE_MODEL_EVENT, newVal);
          return;
        }
        if (oldVal === newVal)
          return;
        data.userInput = null;
        emit(UPDATE_MODEL_EVENT, newVal);
        emit(CHANGE_EVENT, newVal, oldVal);
        data.currentValue = newVal;
      };
      const handleInput = (value) => {
        data.userInput = value;
        const newVal = value === "" ? null : Number(value);
        emit(INPUT_EVENT, newVal);
        setCurrentValue(newVal, false);
      };
      const handleInputChange = (value) => {
        const newVal = value !== "" ? Number(value) : "";
        if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
          setCurrentValue(newVal);
        }
        data.userInput = null;
      };
      const focus = () => {
        var _a, _b;
        (_b = (_a = input.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
      };
      const blur = () => {
        var _a, _b;
        (_b = (_a = input.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
      };
      const handleFocus = (event) => {
        emit("focus", event);
      };
      const handleBlur = (event) => {
        emit("blur", event);
      };
      vue.watch(
        () => props.modelValue,
        (value) => {
          const userInput = verifyValue(data.userInput);
          const newValue = verifyValue(value, true);
          if (!isNumber(userInput) && (!userInput || userInput !== newValue)) {
            data.currentValue = newValue;
            data.userInput = null;
          }
        },
        { immediate: true }
      );
      vue.onMounted(() => {
        var _a;
        const { min, max, modelValue } = props;
        const innerInput = (_a = input.value) == null ? void 0 : _a.inputRef;
        innerInput.setAttribute("role", "spinbutton");
        if (Number.isFinite(max)) {
          innerInput.setAttribute("aria-valuemax", String(max));
        } else {
          innerInput.removeAttribute("aria-valuemax");
        }
        if (Number.isFinite(min)) {
          innerInput.setAttribute("aria-valuemin", String(min));
        } else {
          innerInput.removeAttribute("aria-valuemin");
        }
        innerInput.setAttribute(
          "aria-valuenow",
          data.currentValue || data.currentValue === 0 ? String(data.currentValue) : ""
        );
        innerInput.setAttribute("aria-disabled", String(isDisabled.value));
        if (!isNumber(modelValue) && modelValue != null) {
          let val = Number(modelValue);
          if (Number.isNaN(val)) {
            val = null;
          }
          emit(UPDATE_MODEL_EVENT, val);
        }
      });
      vue.onUpdated(() => {
        var _a, _b;
        const innerInput = (_a = input.value) == null ? void 0 : _a.inputRef;
        innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${(_b = data.currentValue) != null ? _b : ""}`);
      });
      __expose({
        focus,
        blur
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass([
              vue.unref(ns).b(),
              vue.unref(ns).is("disabled", vue.unref(isDisabled)),
              vue.unref(ns).is("readonly", _ctx.readonly),
              vue.unref(ns).is("without-controls", !_ctx.controls)
            ]),
            style: vue.normalizeStyle(wrapperStyle.value),
            onDragstart: _cache[1] || (_cache[1] = vue.withModifiers(() => {
            }, ["prevent"]))
          },
          [
            _ctx.controls ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("span", {
              key: 0,
              role: "button",
              class: vue.normalizeClass([vue.unref(ns).e("decrease"), vue.unref(ns).is("disabled", minDisabled.value)]),
              onKeydown: vue.withKeys(decrease, ["enter"])
            }, [
              vue.createVNode(vue.unref(VsIcon), null, {
                default: vue.withCtx(() => [
                  vue.createVNode(vue.unref(minus_default))
                ]),
                _: 1
              })
            ], 42, _hoisted_1$d)), [
              [vue.unref(RepeatClick), decrease]
            ]) : vue.createCommentVNode("v-if", true),
            _ctx.controls ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("span", {
              key: 1,
              role: "button",
              class: vue.normalizeClass([vue.unref(ns).e("increase"), vue.unref(ns).is("disabled", maxDisabled.value)]),
              onKeydown: vue.withKeys(increase, ["enter"])
            }, [
              vue.createVNode(vue.unref(VsIcon), null, {
                default: vue.withCtx(() => [
                  vue.createVNode(vue.unref(plus_default))
                ]),
                _: 1
              })
            ], 42, _hoisted_2$8)), [
              [vue.unref(RepeatClick), increase]
            ]) : vue.createCommentVNode("v-if", true),
            vue.createVNode(vue.unref(VsInput), {
              id: _ctx.id,
              ref_key: "input",
              ref: input,
              type: "number",
              block: "",
              step: _ctx.step,
              "model-value": displayValue.value,
              placeholder: _ctx.placeholder,
              readonly: _ctx.readonly,
              disabled: vue.unref(isDisabled),
              max: _ctx.max,
              min: _ctx.min,
              name: _ctx.name,
              label: _ctx.label,
              onWheel: _cache[0] || (_cache[0] = vue.withModifiers(() => {
              }, ["prevent"])),
              onKeydown: [
                vue.withKeys(vue.withModifiers(increase, ["prevent"]), ["up"]),
                vue.withKeys(vue.withModifiers(decrease, ["prevent"]), ["down"])
              ],
              onBlur: handleBlur,
              onFocus: handleFocus,
              onInput: handleInput,
              onChange: handleInputChange
            }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "max", "min", "name", "label", "onKeydown"])
          ],
          38
        );
      };
    }
  });
  var InputNumber = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__file", "input-number.vue"]]);

  const VsInputNumber = withInstall(InputNumber);

  const navbarRegisterContextKey = Symbol("navbar-register");
  const navbarContextKey = Symbol("navbar");
  const navbarGroupRegisterContextKey = Symbol("navbar-group-register");

  const navbarProps = buildProps({
    modelValue: {
      type: String
    },
    color: useColorProp,
    fixed: {
      type: Boolean
    },
    shadow: {
      type: Boolean
    },
    shadowScroll: {
      type: Boolean
    },
    hideScroll: {
      type: Boolean
    },
    textWhite: {
      type: Boolean
    },
    square: {
      type: Boolean
    },
    paddingScroll: {
      type: Boolean
    },
    notLine: {
      type: Boolean
    },
    leftCollapsed: {
      type: Boolean
    },
    centerCollapsed: {
      type: Boolean
    },
    rightCollapsed: {
      type: Boolean
    },
    targetScroll: {
      type: String
    }
  });
  const navbarEmits = {
    collapsed: (val) => isBoolean(val),
    [UPDATE_MODEL_EVENT]: (val) => isString(val)
  };

  const __default__$v = vue.defineComponent({
    name: "VsNavbar"
  });
  const _sfc_main$x = vue.defineComponent({
    ...__default__$v,
    props: navbarProps,
    emits: navbarEmits,
    setup(__props, { emit }) {
      const props = __props;
      const ns = useNamespace("navbar");
      const navbarRef = vue.ref();
      const navbarLeftRef = vue.ref();
      const navbarRightRef = vue.ref();
      const navbarCenterRef = vue.ref();
      const children = vue.reactive(/* @__PURE__ */ new Set());
      const state = vue.reactive({
        scrollTop: 0,
        collapsedWidth: 0,
        collapsedForced: false,
        hidden: false,
        shadowActive: false,
        paddingScrollActive: false,
        lineNotTransition: false
      });
      const vsBaseClasses = useVuesaxBaseComponent(useColor());
      const navbarKls = vue.computed(() => [
        ns.b(),
        vsBaseClasses,
        ns.is("fixed", props.fixed),
        ns.is("shadow", props.shadow),
        ns.is("not-line", props.notLine),
        ns.is("hidden", state.hidden),
        ns.is("shadow-active", state.shadowActive),
        ns.is("text-white", props.textWhite),
        ns.is("padding-scroll", props.paddingScroll),
        ns.is("padding-scroll-active", state.paddingScrollActive),
        ns.is("square", props.square)
      ]);
      const navbarStyles = vue.computed(
        () => ns.cssVar({
          color: getVsColor(props.color)
        })
      );
      const scroll = () => {
        const _scrollTop = props.targetScroll ? document.querySelector(props.targetScroll).scrollTop : window.pageYOffset;
        if (props.hideScroll) {
          if (Math.sign(_scrollTop - state.scrollTop) === 1) {
            state.hidden = true;
          } else {
            state.hidden = false;
          }
        }
        if (props.shadowScroll) {
          if (_scrollTop > 0) {
            state.shadowActive = true;
          } else {
            state.shadowActive = false;
          }
        }
        if (props.paddingScroll) {
          if (_scrollTop > 0) {
            state.paddingScrollActive = true;
          } else {
            state.paddingScrollActive = false;
          }
        }
        state.scrollTop = _scrollTop;
      };
      const handleScroll = () => {
        if (props.hideScroll || props.shadowScroll || props.paddingScroll) {
          if (props.targetScroll) {
            const scrollElement = document.querySelector(props.targetScroll);
            scrollElement == null ? void 0 : scrollElement.addEventListener("scroll", scroll);
          } else {
            window.addEventListener("scroll", scroll);
          }
        }
      };
      const handleResize = () => {
        const navbar = navbarRef.value;
        if (props.leftCollapsed || props.centerCollapsed || props.rightCollapsed) {
          if (navbar.offsetWidth < state.collapsedWidth) {
            state.collapsedForced = true;
          }
        }
        if (state.collapsedForced) {
          emit("collapsed", true);
        } else {
          emit("collapsed", false);
        }
        if (navbar.offsetWidth < state.collapsedWidth) {
          emit("collapsed", true);
        } else {
          emit("collapsed", false);
          state.collapsedForced = false;
        }
      };
      const isLeft = vue.computed(
        () => props.leftCollapsed ? !state.collapsedForced : true
      );
      const isRight = vue.computed(
        () => props.rightCollapsed ? !state.collapsedForced : true
      );
      const isCenter = vue.computed(
        () => props.centerCollapsed ? !state.collapsedForced : true
      );
      vue.watch(
        [() => props.hideScroll, () => props.paddingScroll, () => props.shadowScroll],
        handleScroll
      );
      vue.provide(navbarContextKey, {
        modelValue: vue.computed(() => props.modelValue)
      });
      vue.provide(navbarRegisterContextKey, (id) => {
        children.add(id);
        return {
          unregister: () => children.delete(id),
          onClick: () => emit(UPDATE_MODEL_EVENT, id),
          isActive: vue.computed(() => props.modelValue === id)
        };
      });
      vue.onMounted(() => {
        vue.nextTick(() => {
          if (navbarRef.value && navbarLeftRef.value && navbarCenterRef.value && navbarRightRef.value) {
            const left = navbarLeftRef.value;
            const center = navbarCenterRef.value;
            const right = navbarRightRef.value;
            const navbar = navbarRef.value;
            const GAP_PADDING_SLOT = 120 + 30;
            state.collapsedWidth = left.offsetWidth + center.offsetWidth + right.offsetWidth + GAP_PADDING_SLOT;
            if (navbar.offsetWidth < state.collapsedWidth) {
              state.collapsedForced = true;
              emit("collapsed", true);
              handleResize();
            }
          }
        });
        handleScroll();
        useEventListener(window, "resize", handleResize);
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            ref_key: "navbarRef",
            ref: navbarRef,
            class: vue.normalizeClass(navbarKls.value),
            style: vue.normalizeStyle(navbarStyles.value)
          },
          [
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("content"))
              },
              [
                isLeft.value ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 0,
                    ref_key: "navbarLeftRef",
                    ref: navbarLeftRef,
                    class: vue.normalizeClass(vue.unref(ns).e("left"))
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "left")
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true),
                isCenter.value ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 1,
                    ref_key: "navbarCenterRef",
                    ref: navbarCenterRef,
                    class: vue.normalizeClass(vue.unref(ns).e("center"))
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "default")
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true),
                isRight.value ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 2,
                    ref_key: "navbarRightRef",
                    ref: navbarRightRef,
                    class: vue.normalizeClass(vue.unref(ns).e("right"))
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "right")
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true)
              ],
              2
            )
          ],
          6
        );
      };
    }
  });
  var Navbar = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__file", "navbar.vue"]]);

  const navbarItemProps = buildProps({
    active: {
      type: Boolean
    },
    to: {
      type: definePropType([String, Object])
    },
    link: {
      type: definePropType([Object])
    },
    id: {
      type: String,
      required: true
    }
  });

  const __default__$u = vue.defineComponent({
    name: "VsNavbarItem"
  });
  const _sfc_main$w = vue.defineComponent({
    ...__default__$u,
    props: navbarItemProps,
    setup(__props) {
      const props = __props;
      const navbarRegister = vue.inject(navbarRegisterContextKey, void 0);
      const navbarGroupRegister = vue.inject(navbarGroupRegisterContextKey, void 0);
      if (!navbarRegister) {
        throwError("navbar-item", "need to call inside navbar component");
      }
      const { unregister, onClick, isActive } = navbarRegister(props.id);
      const navbarGroup = navbarGroupRegister == null ? void 0 : navbarGroupRegister(props.id);
      const ns = useNamespace("navbar-item");
      const handleClickItem = (router) => {
        onClick();
        if (props.to) {
          router.push(props.to);
        } else {
          if (props.link) {
            window.open(props.link.path, props.link.target);
          }
        }
      };
      vue.onBeforeUnmount(() => {
        unregister();
        navbarGroup == null ? void 0 : navbarGroup.unregister();
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "button",
          {
            class: vue.normalizeClass([vue.unref(ns).b(), vue.unref(ns).is("active", _ctx.active || vue.unref(isActive))]),
            onClick: _cache[0] || (_cache[0] = ($event) => handleClickItem(_ctx.$router))
          },
          [
            vue.renderSlot(_ctx.$slots, "default", {}, () => {
              var _a;
              return [
                vue.createTextVNode(
                  vue.toDisplayString((_a = _ctx.link) == null ? void 0 : _a.text),
                  1
                )
              ];
            })
          ],
          2
        );
      };
    }
  });
  var NavbarItem = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__file", "navbar-item.vue"]]);

  const __default__$t = vue.defineComponent({
    name: "VsNavbarGroup"
  });
  const _sfc_main$v = vue.defineComponent({
    ...__default__$t,
    setup(__props) {
      const { modelValue } = vue.inject(navbarContextKey);
      const ns = useNamespace("navbar-group");
      const children = vue.reactive(/* @__PURE__ */ new Set());
      const isGroupActive = vue.computed(() => children.has(`${modelValue.value}`));
      vue.provide(navbarGroupRegisterContextKey, (id) => {
        children.add(id);
        return {
          unregister: () => children.delete(id)
        };
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass([vue.unref(ns).b(), vue.unref(ns).is("active", isGroupActive.value)])
          },
          [
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("text"))
              },
              [
                vue.renderSlot(_ctx.$slots, "default")
              ],
              2
            ),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("items"))
              },
              [
                vue.renderSlot(_ctx.$slots, "items")
              ],
              2
            )
          ],
          2
        );
      };
    }
  });
  var NavbarGroup = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__file", "navbar-group.vue"]]);

  const VsNavbar = withInstall(Navbar, {
    NavbarItem,
    NavbarGroup
  });
  const VsNavbarItem = withNoopInstall(NavbarItem);
  const VsNavbarGroup = withNoopInstall(NavbarGroup);

  const usePagination = () => {
    const pagination = vue.inject(paginationContextKey);
    return pagination;
  };

  const paginationNextProps = buildProps({
    nextText: {
      type: String,
      default: ""
    },
    nextIcon: {
      type: iconPropType
    }
  });

  const _hoisted_1$c = ["disabled", "aria-disabled"];
  const _hoisted_2$7 = { key: 0 };
  const __default__$s = vue.defineComponent({
    name: "VsPaginationNext"
  });
  const _sfc_main$u = vue.defineComponent({
    ...__default__$s,
    props: paginationNextProps,
    setup(__props) {
      const { pageCount, disabled, currentPage, infinite } = usePagination();
      const internalDisabled = vue.computed(
        () => disabled.value || currentPage.value === pageCount.value || pageCount.value === 0
      );
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("button", {
          type: "button",
          class: "btn-next",
          disabled: internalDisabled.value && !vue.unref(infinite),
          "aria-disabled": internalDisabled.value && !vue.unref(infinite)
        }, [
          _ctx.nextText ? (vue.openBlock(), vue.createElementBlock(
            "span",
            _hoisted_2$7,
            vue.toDisplayString(_ctx.nextText),
            1
          )) : (vue.openBlock(), vue.createBlock(vue.unref(VsIcon), { key: 1 }, {
            default: vue.withCtx(() => [
              (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.nextIcon)))
            ]),
            _: 1
          }))
        ], 8, _hoisted_1$c);
      };
    }
  });
  var Next = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__file", "next.vue"]]);

  const paginationPrevProps = buildProps({
    prevText: {
      type: String,
      default: ""
    },
    prevIcon: {
      type: iconPropType
    }
  });

  const _hoisted_1$b = ["disabled", "aria-disabled"];
  const _hoisted_2$6 = { key: 0 };
  const __default__$r = vue.defineComponent({
    name: "VsPaginationPrev"
  });
  const _sfc_main$t = vue.defineComponent({
    ...__default__$r,
    props: paginationPrevProps,
    setup(__props) {
      const { disabled, currentPage, infinite } = usePagination();
      const internalDisabled = vue.computed(
        () => disabled.value || currentPage.value <= 1
      );
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("button", {
          type: "button",
          class: "btn-prev",
          disabled: internalDisabled.value && !vue.unref(infinite),
          "aria-disabled": internalDisabled.value && !vue.unref(infinite)
        }, [
          _ctx.prevText ? (vue.openBlock(), vue.createElementBlock(
            "span",
            _hoisted_2$6,
            vue.toDisplayString(_ctx.prevText),
            1
          )) : (vue.openBlock(), vue.createBlock(vue.unref(VsIcon), { key: 1 }, {
            default: vue.withCtx(() => [
              (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.prevIcon)))
            ]),
            _: 1
          }))
        ], 8, _hoisted_1$b);
      };
    }
  });
  var Prev = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__file", "prev.vue"]]);

  const POSITIONING_STRATEGIES = ["fixed", "absolute"];
  const popperContentProps = buildProps({
    animation: {
      type: String,
      default: "fade-in-linear"
    },
    appendTo: {
      type: definePropType(String)
    },
    visible: {
      type: definePropType(Boolean),
      default: null
    },
    teleported: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean
    },
    strategy: {
      type: definePropType(String),
      values: POSITIONING_STRATEGIES,
      default: "absolute"
    },
    fit: {
      type: Boolean
    },
    placement: {
      type: definePropType(String),
      values: placements,
      default: "bottom"
    },
    zIndex: {
      type: Number,
      default: defaultZIndex
    },
    interactivity: {
      type: Boolean,
      default: true
    },
    flip: {
      type: definePropType([Object, Boolean]),
      default: () => ({})
    },
    shift: {
      type: definePropType([Object, Boolean]),
      default: () => ({})
    },
    windowResize: {
      type: Boolean,
      default: true
    },
    windowScroll: {
      type: Boolean,
      default: true
    },
    showArrow: {
      type: Boolean,
      default: true
    },
    offset: {
      type: definePropType([Number, Object]),
      default: 12
    },
    content: {
      type: String
    },
    rawContent: {
      type: Boolean
    },
    popperClass: {
      type: definePropType([String, Array, Object]),
      default: ""
    },
    popperStyle: {
      type: definePropType([String, Array, Object]),
      default: ""
    },
    persistent: {
      type: Boolean
    }
  });
  const popperContentEmits = {
    mouseenter: (evt) => evt instanceof MouseEvent,
    mouseleave: (evt) => evt instanceof MouseEvent,
    focus: () => true,
    blur: () => true,
    close: () => true
  };

  const EventHandler = {
    type: definePropType(Function)
  };
  const popperTriggerProps = buildProps({
    disabled: {
      type: Boolean
    },
    trigger: {
      type: definePropType([String, Array]),
      default: "hover"
    },
    virtualRef: {
      type: definePropType(Object)
    },
    virtualTriggering: {
      type: Boolean
    },
    onMouseenter: EventHandler,
    onMouseleave: EventHandler,
    onClick: EventHandler,
    onKeydown: EventHandler,
    onFocus: EventHandler,
    onBlur: EventHandler,
    onContextmenu: EventHandler,
    triggerClass: {
      type: definePropType([String, Array, Object])
    },
    triggerStyle: {
      type: definePropType([String, Array, Object])
    }
  });

  const {
    useModelToggleProps: usePopperModelToggleProps,
    useModelToggleEmits: usePopperModelToggleEmits,
    useModelToggle: usePopperModelToggle
  } = createModelToggleComposable("visible");
  const popperProps = buildProps({
    ...useDelayedToggleProps,
    ...popperContentProps,
    ...popperTriggerProps,
    ...usePopperModelToggleProps,
    processBeforeOpen: {
      type: definePropType(Function),
      default: () => true
    },
    processBeforeClose: {
      type: definePropType(Function),
      default: () => true
    },
    showArrow: {
      type: Boolean,
      default: true
    },
    loading: {
      type: Boolean
    }
  });
  const popperEmits = [
    ...usePopperModelToggleEmits,
    "before-show",
    "show",
    "before-hide",
    "hide"
  ];

  const _hoisted_1$a = ["data-popper-placement"];
  const _hoisted_2$5 = ["innerHTML"];
  const __default__$q = vue.defineComponent({
    name: "VsPopper"
  });
  const _sfc_main$s = vue.defineComponent({
    ...__default__$q,
    props: popperContentProps,
    emits: popperContentEmits,
    setup(__props) {
      const props = __props;
      const ns = useNamespace("popper");
      const {
        contentRef,
        controlled,
        open,
        trigger,
        updatePopper,
        onOpen,
        onClose,
        onShow,
        onHide,
        onBeforeShow,
        onBeforeHide
      } = vue.inject(popperContextKey, void 0);
      const destroyed = vue.ref(false);
      const persistentRef = vue.computed(() => {
        return props.persistent;
      });
      const shouldRender = vue.computed(() => {
        return vue.unref(persistentRef) ? true : vue.unref(open);
      });
      const shouldShow = vue.computed(() => {
        return props.disabled ? false : vue.unref(open);
      });
      const popperKls = vue.computed(() => [
        ns.b(),
        ns.is("not-arrow", !props.showArrow),
        props.popperClass
      ]);
      const togglePopperAlive = () => {
        updatePopper(false);
      };
      const stopWhenControlled = () => {
        if (vue.unref(controlled))
          return true;
      };
      const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
        if (props.interactivity && vue.unref(trigger) === "hover") {
          onOpen();
        }
      });
      const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
        if (vue.unref(trigger) === "hover") {
          onClose();
        }
      });
      const onTransitionLeave = () => {
        onHide();
      };
      const onBeforeEnter = () => {
        updatePopper();
        onBeforeShow == null ? void 0 : onBeforeShow();
      };
      const onBeforeLeave = () => {
        onBeforeHide == null ? void 0 : onBeforeHide();
      };
      let stopHandle;
      const onAfterShow = () => {
        onShow();
        stopHandle = onClickOutside(
          vue.computed(() => {
            return unrefElement(contentRef);
          }),
          () => {
            if (vue.unref(controlled))
              return;
            const $trigger = vue.unref(trigger);
            if ($trigger !== "hover") {
              onClose();
            }
          }
        );
      };
      vue.onMounted(() => {
        vue.watch(() => props.visible, togglePopperAlive, { immediate: true });
      });
      vue.watch(
        () => vue.unref(open),
        (val) => {
          if (!val) {
            stopHandle == null ? void 0 : stopHandle();
          }
        },
        {
          flush: "post"
        }
      );
      vue.watch(
        () => props.content,
        () => {
          updatePopper();
        }
      );
      vue.onBeforeUnmount(() => {
        destroyed.value = true;
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.Teleport, {
          to: _ctx.appendTo,
          disabled: !_ctx.teleported
        }, [
          vue.createVNode(vue.Transition, {
            name: _ctx.animation,
            onAfterLeave: onTransitionLeave,
            onBeforeEnter,
            onAfterEnter: onAfterShow,
            onBeforeLeave
          }, {
            default: vue.withCtx(() => [
              shouldRender.value ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
                key: 0,
                ref_key: "contentRef",
                ref: contentRef,
                class: vue.normalizeClass(popperKls.value),
                style: vue.normalizeStyle(_ctx.popperStyle),
                "data-popper-placement": _ctx.placement,
                onMouseenter: _cache[0] || (_cache[0] = (...args) => vue.unref(onContentEnter) && vue.unref(onContentEnter)(...args)),
                onMouseleave: _cache[1] || (_cache[1] = (...args) => vue.unref(onContentLeave) && vue.unref(onContentLeave)(...args))
              }, [
                !destroyed.value ? (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 0 },
                  [
                    _ctx.content ? (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 0 },
                      [
                        _ctx.rawContent ? (vue.openBlock(), vue.createElementBlock("div", {
                          key: 0,
                          innerHTML: _ctx.content
                        }, null, 8, _hoisted_2$5)) : (vue.openBlock(), vue.createElementBlock(
                          vue.Fragment,
                          { key: 1 },
                          [
                            vue.createTextVNode(
                              vue.toDisplayString(_ctx.content),
                              1
                            )
                          ],
                          64
                        ))
                      ],
                      64
                    )) : vue.renderSlot(_ctx.$slots, "default", { key: 1 })
                  ],
                  64
                )) : vue.createCommentVNode("v-if", true)
              ], 46, _hoisted_1$a)), [
                [vue.vShow, shouldShow.value]
              ]) : vue.createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 8, ["name"])
        ], 8, ["to", "disabled"]);
      };
    }
  });
  var popperContent = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__file", "content.vue"]]);

  const NAME = "VsOnlyChild";
  const OnlyChild = vue.defineComponent({
    name: NAME,
    setup(_, { slots, attrs }) {
      return () => {
        var _a, _b;
        const forwardRefInjection = vue.inject(FORWARD_REF_INJECTION_KEY, void 0);
        const forwardRefDirective = useForwardRefDirective(
          (_a = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a : NOOP
        );
        const defaultSlot = (_b = slots.default) == null ? void 0 : _b.call(slots, attrs);
        if (!defaultSlot)
          return null;
        if (defaultSlot.length > 1) {
          return null;
        }
        const firstLegitNode = findFirstLegitChild(defaultSlot);
        if (!firstLegitNode) {
          return null;
        }
        return vue.withDirectives(vue.cloneVNode(firstLegitNode), [
          [forwardRefDirective]
        ]);
      };
    }
  });
  function findFirstLegitChild(node) {
    if (!node)
      return null;
    const children = node;
    for (const child of children) {
      if (isObject(child)) {
        switch (child.type) {
          case vue.Comment:
            continue;
          case vue.Text:
          case "svg":
            return wrapTextContent(child);
          case vue.Fragment:
            return findFirstLegitChild(child.children);
          default:
            return child;
        }
      }
      return wrapTextContent(child);
    }
    return null;
  }
  function wrapTextContent(s) {
    const ns = useNamespace("only-child");
    return vue.h(
      "span",
      {
        className: ns.e("content")
      },
      s
    );
  }

  const isTriggerType = (trigger, type) => {
    if (isArray(trigger)) {
      return trigger.includes(type);
    }
    return trigger === type;
  };
  const whenTrigger = (trigger, type, handler) => {
    return (e) => {
      isTriggerType(vue.unref(trigger), type) && handler(e);
    };
  };

  const _sfc_main$r = vue.defineComponent({
    __name: "trigger",
    props: popperTriggerProps,
    setup(__props) {
      const props = __props;
      const ns = useNamespace("popper");
      const { triggerRef, onOpen, onClose, onToggle } = vue.inject(
        popperContextKey,
        void 0
      );
      useForwardRef(triggerRef);
      const stopWhenControlledOrDisabled = () => {
        if (props.disabled) {
          return true;
        }
      };
      const trigger = vue.toRef(props, "trigger");
      const onMouseenter = composeEventHandlers(
        stopWhenControlledOrDisabled,
        whenTrigger(trigger, "hover", onOpen)
      );
      const onMouseleave = composeEventHandlers(
        stopWhenControlledOrDisabled,
        whenTrigger(trigger, "hover", onClose)
      );
      const onClick = composeEventHandlers(
        stopWhenControlledOrDisabled,
        whenTrigger(trigger, "click", (e) => {
          if (e.button === 0) {
            onToggle(e);
          }
        })
      );
      const onFocus = composeEventHandlers(
        stopWhenControlledOrDisabled,
        whenTrigger(trigger, "focus", onOpen)
      );
      const onBlur = composeEventHandlers(
        stopWhenControlledOrDisabled,
        whenTrigger(trigger, "focus", onClose)
      );
      const onContextMenu = composeEventHandlers(
        stopWhenControlledOrDisabled,
        whenTrigger(trigger, "contextmenu", (e) => {
          e.preventDefault();
          onToggle(e);
        })
      );
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(OnlyChild), {
          ref_key: "triggerRef",
          ref: triggerRef,
          class: vue.normalizeClass(vue.unref(ns).e("trigger")),
          onMouseenter: vue.unref(onMouseenter),
          onMouseleave: vue.unref(onMouseleave),
          onClick: vue.unref(onClick),
          onFocus: vue.unref(onFocus),
          onBlur: vue.unref(onBlur),
          onContextmenu: vue.unref(onContextMenu)
        }, {
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["class", "onMouseenter", "onMouseleave", "onClick", "onFocus", "onBlur", "onContextmenu"]);
      };
    }
  });
  var popperTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__file", "trigger.vue"]]);

  const __default__$p = vue.defineComponent({
    name: "VsPopper",
    inheritAttrs: false
  });
  const _sfc_main$q = vue.defineComponent({
    ...__default__$p,
    props: popperProps,
    emits: popperEmits,
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      usePopperContainer();
      const { selector, id } = usePopperContainerId();
      const appendTo = vue.computed(() => props.appendTo || selector.value);
      const { currentZIndex, nextZIndex } = useZIndex();
      const zIndex = vue.computed(() => currentZIndex.value);
      const triggerRef = vue.ref();
      const contentRef = vue.ref();
      const arrowRef = vue.ref();
      const open = vue.ref(false);
      const toggleReason = vue.ref();
      const { show, hide, hasUpdateHandler } = usePopperModelToggle({
        indicator: open,
        toggleReason,
        processBeforeClosing: props.processBeforeClose,
        shouldProceed: props.processBeforeOpen
      });
      const { onOpen, onClose } = useDelayedToggle({
        showAfter: vue.toRef(props, "showAfter"),
        hideAfter: vue.toRef(props, "hideAfter"),
        autoClose: vue.toRef(props, "autoClose"),
        open: show,
        close: hide
      });
      const {
        update,
        placement: popperPlacement,
        floatingStyles
      } = useFloating(triggerRef, contentRef, {
        open,
        middleware: vue.ref([
          !isEmpty(props.offset) && offset(props.offset),
          !isEmpty(props.flip) && flip(isBoolean(props.flip) ? void 0 : props.flip),
          !isEmpty(props.shift) && shift(isBoolean(props.shift) ? void 0 : props.shift),
          arrow({
            element: arrowRef
          })
        ]),
        placement: vue.computed(() => props.placement),
        strategy: vue.computed(() => props.strategy),
        transform: false,
        fit: vue.computed(() => props.fit)
      });
      const controlled = vue.computed(
        () => isBoolean(props.visible) && !hasUpdateHandler.value
      );
      const updatePopper = (shouldUpdateZIndex = true) => {
        update();
        shouldUpdateZIndex && nextZIndex();
      };
      const onBlur = () => {
        if (!props.virtualTriggering) {
          onClose();
        }
      };
      const isFocusInsideContent = () => {
        var _a;
        return !!((_a = contentRef.value) == null ? void 0 : _a.contains(document.activeElement));
      };
      vue.watch(
        () => props.disabled,
        (disabled) => {
          if (disabled && open.value) {
            open.value = false;
          }
        }
      );
      vue.onDeactivated(() => open.value && hide());
      vue.provide(popperContextKey, {
        contentRef,
        triggerRef,
        arrowRef,
        referenceRef: triggerRef,
        controlled,
        id,
        open: vue.readonly(open),
        trigger: vue.toRef(props, "trigger"),
        onOpen,
        onClose,
        onToggle: (event) => {
          if (vue.unref(open)) {
            onClose(event);
          } else {
            onOpen(event);
          }
        },
        onShow: () => {
          emit("show", toggleReason.value);
        },
        onHide: () => {
          emit("hide", toggleReason.value);
        },
        onBeforeShow: () => {
          emit("before-show", toggleReason.value);
        },
        onBeforeHide: () => {
          emit("before-hide", toggleReason.value);
        },
        updatePopper
      });
      __expose(
        vue.reactive({
          triggerRef,
          contentRef,
          isFocusInsideContent,
          updatePopper,
          onOpen,
          onClose,
          hide,
          popperPlacement
        })
      );
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          null,
          [
            vue.createVNode(popperTrigger, {
              disabled: _ctx.disabled,
              trigger: _ctx.trigger,
              "virtual-ref": _ctx.virtualRef,
              "virtual-triggering": _ctx.virtualTriggering,
              "on-mouseenter": _ctx.onMouseenter,
              "on-mouseleave": _ctx.onMouseleave,
              "on-click": _ctx.onClick,
              "on-keydown": _ctx.onKeydown,
              "on-focus": _ctx.onFocus,
              "on-blur": onBlur,
              "on-contextmenu": _ctx.onContextmenu
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["disabled", "trigger", "virtual-ref", "virtual-triggering", "on-mouseenter", "on-mouseleave", "on-click", "on-keydown", "on-focus", "on-contextmenu"]),
            vue.createVNode(popperContent, {
              animation: _ctx.animation,
              "append-to": appendTo.value,
              teleported: _ctx.teleported,
              persistent: _ctx.persistent,
              placement: vue.unref(popperPlacement),
              content: _ctx.content,
              interactivity: _ctx.interactivity,
              "popper-class": _ctx.popperClass,
              "popper-style": [_ctx.popperStyle, vue.unref(floatingStyles), { zIndex: zIndex.value }],
              disabled: _ctx.disabled,
              visible: _ctx.visible,
              "show-arrow": _ctx.showArrow,
              onBlur,
              onClose: vue.unref(onClose)
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "content")
              ]),
              _: 3
            }, 8, ["animation", "append-to", "teleported", "persistent", "placement", "content", "interactivity", "popper-class", "popper-style", "disabled", "visible", "show-arrow", "onClose"])
          ],
          64
        );
      };
    }
  });
  var Popper = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__file", "popper.vue"]]);

  const VsPopper = withInstall(Popper);

  const selectContextKey = Symbol();
  const selectRegisterKey = Symbol();
  const optionGroupContextKey = Symbol();
  const optionGroupRegisterKey = Symbol();

  const optionProps = buildProps({
    value: {
      type: definePropType([String, Number, Object]),
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    label: {
      type: String
    },
    created: { type: Boolean, default: false }
  });

  const __default__$o = vue.defineComponent({
    name: "VsOption"
  });
  const _sfc_main$p = vue.defineComponent({
    ...__default__$o,
    props: optionProps,
    setup(__props) {
      const props = __props;
      const ns = useNamespace("select");
      const value = vue.toRef(props, "value");
      const select = vue.inject(selectContextKey);
      const selectRegister = vue.inject(selectRegisterKey);
      const optionGroupRegister = vue.inject(optionGroupRegisterKey, void 0);
      if (!select || !selectRegister) {
        throwError(
          "Select Option",
          "`Option` component must be called inside `select` or `option-group` component"
        );
      }
      const selectGroup = vue.inject(optionGroupContextKey, { disabled: false });
      const el = vue.ref();
      const isObject = vue.computed(() => isObject$1(props.value));
      const limitReached = vue.computed(() => {
        if (select.multiple && select.multipleLimit) {
          const modelValue = select.selectedArray;
          return !isSelected.value && modelValue.length >= select.multipleLimit && select.multipleLimit > 0;
        }
        return false;
      });
      const currentLabel = vue.computed(() => {
        return props.label || (isObject.value ? "" : `${props.value}`);
      });
      const isDisabled = vue.computed(() => {
        return props.disabled || states.groupDisabled || limitReached.value;
      });
      const isSelected = vue.computed(() => {
        return select.selectedArray.some((e) => e.value == states.value);
      });
      const states = vue.reactive({
        index: -1,
        el,
        value,
        currentLabel,
        isDisabled,
        groupDisabled: false,
        visible: true,
        hit: false,
        hover: false,
        created: props.created
      });
      const { unregister, updateOption } = selectRegister(states);
      const { unregister: optionGroupUnregister } = (optionGroupRegister == null ? void 0 : optionGroupRegister(states)) || {};
      vue.onBeforeUnmount(() => {
        unregister();
        optionGroupUnregister == null ? void 0 : optionGroupUnregister();
      });
      const hoverItem = () => {
        if (!props.disabled && !selectGroup.disabled) {
          select.hoverIndex = select.optionsArray.indexOf(states);
        }
      };
      vue.watch(currentLabel, () => {
        if (!props.created)
          select.setSelected();
      });
      vue.watch(
        () => props.value,
        (val, oldVal) => {
          if (!Object.is(val, oldVal)) {
            updateOption(states);
          }
          if (!props.created)
            select.setSelected();
        }
      );
      vue.watch(
        () => selectGroup.disabled,
        (val) => {
          states.groupDisabled = val;
        },
        { immediate: true }
      );
      vue.watch(
        () => select.queryChange,
        (query) => {
          const regexp = new RegExp(escapeStringRegexp(`${query}`), "i");
          states.visible = regexp.test(`${currentLabel.value}`) || props.created;
          if (!states.visible) {
            select.states.filteredOptionsCount--;
          }
        }
      );
      const optionKls = vue.computed(() => [
        ns.e("option"),
        ns.is("hover", states.hover),
        ns.is("active", isSelected.value),
        ns.is("disabled", isDisabled.value),
        ns.is("hidden", !states.visible)
      ]);
      const selectOptionClick = () => {
        if (props.disabled !== true && states.groupDisabled !== true) {
          select.handleOptionSelect(states, true);
        }
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "button",
          {
            ref_key: "el",
            ref: el,
            class: vue.normalizeClass(optionKls.value),
            onMouseenter: hoverItem,
            onClick: selectOptionClick
          },
          [
            vue.renderSlot(_ctx.$slots, "default", {}, () => [
              vue.createTextVNode(
                vue.toDisplayString(currentLabel.value),
                1
              )
            ])
          ],
          34
        );
      };
    }
  });
  var Option = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__file", "option.vue"]]);

  const chipProps = buildProps({
    disabled: { type: Boolean },
    hit: {
      type: Boolean,
      default: false
    },
    shape: {
      type: String,
      values: ["square"],
      default: ""
    },
    showClose: {
      type: Boolean,
      default: true
    }
  });
  const chipEmits = {
    click: (e) => e instanceof Event,
    close: (e) => e instanceof Event
  };

  const __default__$n = vue.defineComponent({
    name: "VsChip"
  });
  const _sfc_main$o = vue.defineComponent({
    ...__default__$n,
    props: chipProps,
    emits: chipEmits,
    setup(__props, { emit }) {
      const props = __props;
      const ns = useNamespace("chip");
      const select = vue.inject(selectContextKey);
      const chipKls = vue.computed(() => [
        ns.b(),
        ns.is("disabled", props.disabled),
        ns.is("hit", props.hit),
        ns.is(props.shape)
      ]);
      const onClick = (e) => {
        emit("click", e);
      };
      const onClose = (e) => {
        emit("close", e);
      };
      const onMouseEnterClose = () => {
        select.handleTarget("chip-close", !props.disabled);
      };
      const onMouseLeaveClose = () => {
        select.handleTarget(null);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "span",
          {
            class: vue.normalizeClass(chipKls.value),
            onClick
          },
          [
            vue.renderSlot(_ctx.$slots, "default"),
            !_ctx.disabled && _ctx.showClose ? (vue.openBlock(), vue.createBlock(vue.unref(IconClose), {
              key: 0,
              hover: "less",
              scale: "0.5",
              onClick: onClose,
              onMouseenter: onMouseEnterClose,
              onMouseleave: onMouseLeaveClose
            })) : vue.createCommentVNode("v-if", true)
          ],
          2
        );
      };
    }
  });
  var VsChip = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__file", "chip.vue"]]);

  const selectProps = buildProps({
    showAfter: {
      type: Number,
      default: 0,
      validator: (val) => isNumber(val) && val >= 0
    },
    hideAfter: {
      type: Number,
      default: 0,
      validator: (val) => isNumber(val) && val >= 0
    },
    flip: {
      ...popperProps.flip,
      default: true
    },
    fit: {
      ...popperProps.fit,
      default: true
    },
    disabled: popperProps.disabled,
    onClick: popperProps.onClick,
    onBlur: popperProps.onBlur,
    onFocus: popperProps.onFocus,
    onMouseenter: popperProps.onMouseenter,
    onMouseleave: popperProps.onMouseleave,
    onContextmenu: popperProps.onContextmenu,
    onKeydown: popperProps.onKeydown,
    strategy: { ...popperProps.strategy, default: "absolute" },
    teleported: popperProps.teleported,
    modelValue: {
      type: definePropType([Array, String, Number, Object]),
      default: ""
    },
    notValue: {
      type: definePropType([String, Number, Object]),
      default: ""
    },
    loadingText: { type: String },
    noMatchText: { type: String },
    noDataText: { type: String },
    allowCreate: { type: Boolean, default: false },
    multiple: { type: Boolean, default: false },
    multipleLimit: {
      type: Number,
      default: 0
    },
    filter: { type: Boolean },
    filterMethod: {
      type: definePropType(Function)
    },
    collapseChips: { type: Boolean },
    maxCollapseChips: {
      type: Number,
      default: 1,
      validator: (value) => isNumber(value) && value >= 0
    },
    defaultFirstOption: { type: Boolean },
    loading: { type: Boolean },
    color: { ...useColorProp, default: "primary" },
    state: useColorProp,
    block: { type: Boolean },
    hideScrollbar: { type: Boolean },
    labelFloat: { type: Boolean },
    label: {
      type: String,
      default: null
    },
    placeholder: {
      type: String,
      default: null
    },
    shape: {
      type: String,
      values: ["square"],
      default: ""
    },
    id: {
      type: String
    },
    nativeScrollbar: { type: Boolean },
    clearable: { type: Boolean }
  });
  const selectEmits = {
    "update:modelValue": (val) => isArray(val) || isString(val) || isNumber(val) || isBoolean(val) || isObject(val) || isNil(val),
    "visible-change": (val) => isBoolean(val),
    "remove-tag": (val) => val,
    focus: (event) => event instanceof Event,
    blur: (event) => event instanceof Event,
    change: (val) => isArray(val) || isString(val) || isNumber(val) || isBoolean(val) || isObject(val) || isNil(val),
    clear: () => true
  };

  function useSelectStates(props) {
    return vue.reactive({
      options: /* @__PURE__ */ new Map(),
      cachedOptions: /* @__PURE__ */ new Map(),
      selected: /* @__PURE__ */ new Map(),
      disabledOptions: /* @__PURE__ */ new Map(),
      createdLabel: null,
      targetOnElement: null,
      createdSelected: false,
      optionsCount: 0,
      filteredOptionsCount: 0,
      visible: false,
      softFocus: false,
      selectedLabel: "",
      hoverIndex: -1,
      query: "",
      previousQuery: null,
      cachedPlaceHolder: "",
      currentPlaceholder: props.placeholder,
      menuVisibleOnFocus: false,
      isOnComposition: false,
      isSilentBlur: false,
      mouseEnter: false
    });
  }
  const useSelect = (props, states, emit) => {
    const ns = useNamespace("select");
    const { t } = useLocale();
    const reference = vue.ref();
    const input = vue.ref();
    const popperRef = vue.ref();
    const chips = vue.ref();
    const selectWrapper = vue.ref();
    const scrollbar = vue.ref();
    const hoverOption = vue.ref();
    const inputId = useId(props.id);
    const queryChange = vue.shallowRef("");
    const debounce$1 = vue.ref(0);
    const readonly = vue.computed(
      () => !props.filter || props.multiple || !states.visible
    );
    const selectDisabled = vue.computed(() => props.disabled);
    const showClose = vue.computed(() => {
      const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
      const criteria = props.clearable && !selectDisabled.value && states.mouseEnter && hasValue;
      return criteria;
    });
    const optionsArray = vue.computed(() => Array.from(states.options.values()));
    const cachedOptionsArray = vue.computed(
      () => Array.from(states.cachedOptions.values())
    );
    const selectedArray = vue.computed(() => Array.from(states.selected.values()));
    const showNewOption = vue.computed(() => {
      const hasExistingOption = optionsArray.value.filter((option) => {
        return !option.created;
      }).some((option) => {
        return option.currentLabel === states.query;
      });
      return props.filter && props.allowCreate && states.query !== "" && !hasExistingOption;
    });
    const dropMenuVisible = vue.computed({
      get() {
        return states.visible;
      },
      set(val) {
        states.visible = val;
      }
    });
    const emptyText = vue.computed(() => {
      if (props.loading) {
        return props.loadingText || t("vs.select.loading");
      }
      if (props.filter && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
        return props.noMatchText || t("vs.select.noMatch");
      }
      if (states.options.size === 0) {
        return props.noDataText || t("vs.select.noData");
      }
      return null;
    });
    vue.watch(
      () => props.placeholder,
      (val) => {
        states.cachedPlaceHolder = states.currentPlaceholder = val;
        const hasValue = props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0;
        if (hasValue) {
          states.currentPlaceholder = "";
        }
      }
    );
    vue.watch(
      () => props.modelValue,
      (val) => {
        if (props.multiple) {
          if (val && val.length > 0 || input.value && states.query !== "") {
            states.currentPlaceholder = "";
          } else {
            states.currentPlaceholder = states.cachedPlaceHolder;
          }
          if (props.filter) {
            states.query = "";
            handleQueryChange(states.query);
          }
          vue.nextTick(() => {
            if (reference.value && chips.value) {
              reference.value.style.height = `${chips.value.scrollHeight - 1}px`;
            }
          });
        }
        setSelected();
        vue.nextTick(() => {
          var _a;
          (_a = popperRef.value) == null ? void 0 : _a.updatePopper();
        });
      },
      {
        flush: "post",
        deep: true
      }
    );
    vue.watch(
      () => states.visible,
      (val) => {
        var _a, _b;
        if (!val) {
          input.value && input.value.blur();
          handleQueryChange("");
          states.query = "";
          states.previousQuery = null;
          states.selectedLabel = "";
          states.menuVisibleOnFocus = false;
          resetHoverIndex();
          vue.nextTick(() => {
            if (input.value && input.value.value === "" && selectedArray.value.length === 0) {
              states.currentPlaceholder = states.cachedPlaceHolder;
            }
          });
          if (!props.multiple) {
            if (selectedArray.value.length) {
              if (props.filter && props.allowCreate && states.createdSelected && states.createdLabel) {
                states.selectedLabel = states.createdLabel;
              } else {
                states.selectedLabel = selectedArray.value[0].currentLabel;
              }
              if (props.filter)
                states.query = states.selectedLabel;
            }
            if (props.filter) {
              states.currentPlaceholder = states.cachedPlaceHolder;
            }
          }
        } else {
          (_a = popperRef.value) == null ? void 0 : _a.updatePopper();
          if (props.filter) {
            states.filteredOptionsCount = states.optionsCount;
            states.query = states.selectedLabel;
            if (props.multiple) {
              (_b = input.value) == null ? void 0 : _b.focus();
            } else {
              if (states.selectedLabel) {
                states.currentPlaceholder = `${states.selectedLabel}`;
                states.selectedLabel = "";
              }
            }
            states.query && handleQueryChange(states.query);
            if (!props.multiple) {
              queryChange.value = "";
              vue.triggerRef(queryChange);
            }
          }
        }
        emit("visible-change", val);
      }
    );
    vue.watch(
      () => states.options.entries(),
      () => {
        var _a, _b;
        if (!isClient)
          return;
        (_a = popperRef.value) == null ? void 0 : _a.updatePopper();
        const inputs = ((_b = selectWrapper.value) == null ? void 0 : _b.querySelectorAll("input")) || [];
        if (!Array.from(inputs).includes(document.activeElement)) {
          setSelected();
        }
        if (props.defaultFirstOption && props.filter && states.filteredOptionsCount) {
          checkDefaultFirstOption();
        }
      },
      {
        flush: "post"
      }
    );
    vue.watch(
      () => states.hoverIndex,
      (val) => {
        if (val > -1) {
          hoverOption.value = optionsArray.value[val];
        } else {
          hoverOption.value = void 0;
        }
        optionsArray.value.forEach((option) => {
          option.hover = isEqual(hoverOption.value, option);
        });
      }
    );
    const showTagList = vue.computed(() => {
      if (!props.multiple) {
        return [];
      }
      return props.collapseChips ? selectedArray.value.slice(0, props.maxCollapseChips) : selectedArray.value;
    });
    const collapseTagList = vue.computed(() => {
      if (!props.multiple) {
        return [];
      }
      return props.collapseChips ? selectedArray.value.slice(props.maxCollapseChips) : [];
    });
    const handleQueryChange = (val) => {
      if (states.previousQuery === val || states.isOnComposition)
        return;
      if (states.previousQuery === null && isFunction(props.filterMethod)) {
        states.previousQuery = val;
        return;
      }
      states.previousQuery = val;
      vue.nextTick(() => {
        var _a;
        if (states.visible)
          (_a = popperRef.value) == null ? void 0 : _a.updatePopper();
      });
      states.hoverIndex = -1;
      if (props.multiple && props.filter) {
        vue.nextTick(() => {
          managePlaceholder();
        });
      }
      if (isFunction(props.filterMethod)) {
        props.filterMethod(val);
      } else {
        states.filteredOptionsCount = states.optionsCount;
        queryChange.value = val;
        vue.triggerRef(queryChange);
      }
      if (props.defaultFirstOption && props.filter && states.filteredOptionsCount) {
        vue.nextTick(() => {
          checkDefaultFirstOption();
        });
      }
    };
    const managePlaceholder = () => {
      var _a;
      if (states.currentPlaceholder !== "") {
        states.currentPlaceholder = ((_a = input.value) == null ? void 0 : _a.value) ? "" : states.cachedPlaceHolder;
      }
    };
    const checkDefaultFirstOption = () => {
      const optionsInDropdown = optionsArray.value.filter(
        (n) => n.visible && !n.isDisabled && !n.groupDisabled
      );
      const userCreatedOption = optionsInDropdown.find((n) => n.created);
      const firstOriginOption = optionsInDropdown[0];
      states.hoverIndex = getValueIndex(
        optionsArray.value,
        firstOriginOption || userCreatedOption
      );
    };
    const setSelected = () => {
      states.selected.clear();
      if (!props.multiple) {
        const option = getOption(props.modelValue);
        if (option.created) {
          states.createdLabel = `${option.value}`;
          states.createdSelected = true;
        } else {
          states.createdSelected = false;
        }
        states.selectedLabel = option.currentLabel;
        states.selected.set(option.value, option);
        if (props.filter)
          states.query = states.selectedLabel;
        return;
      }
      states.selectedLabel = "";
      if (Array.isArray(props.modelValue)) {
        props.modelValue.forEach((value) => {
          const option = getOption(value);
          states.selected.set(option.value, option);
        });
      }
    };
    const getOption = (value) => {
      let option = null;
      for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
        const cachedOption = cachedOptionsArray.value[i];
        const isEqualValue = isObject(value) ? isEqual(cachedOption.value, value) : cachedOption.value === value;
        if (isEqualValue) {
          option = cachedOption;
          break;
        }
      }
      if (option)
        return option;
      const label = isObject(value) ? "" : !isNil(value) ? String(value) : "";
      const newOption = {
        value,
        currentLabel: label,
        label,
        hit: true
      };
      if (props.multiple) {
        newOption.hit = false;
      }
      return newOption;
    };
    const resetHoverIndex = () => {
      setTimeout(() => {
        if (!props.multiple) {
          states.hoverIndex = optionsArray.value.findIndex((item) => {
            return isEqual(item, selectedArray.value[0]);
          });
          return;
        }
        if (selectedArray.value.length > 0) {
          states.hoverIndex = Math.min.apply(
            null,
            selectedArray.value.map((selected) => {
              return optionsArray.value.findIndex((item) => {
                return isEqual(item.value, selected.value);
              });
            })
          );
          return;
        }
        states.hoverIndex = -1;
      }, 300);
    };
    const handleResize = () => {
      var _a;
      if (reference.value && chips.value) {
        reference.value.style.height = `${chips.value.scrollHeight}px`;
      }
      (_a = popperRef.value) == null ? void 0 : _a.updatePopper();
    };
    const onInputChange = () => {
      if (props.filter && states.query !== states.selectedLabel) {
        states.query = states.selectedLabel;
        handleQueryChange(states.selectedLabel || "");
      }
    };
    const debouncedOnInputChange = debounce(() => {
      onInputChange();
    }, debounce$1.value);
    const debouncedQueryChange = debounce((e) => {
      handleQueryChange(e.target.value);
    }, debounce$1.value);
    const emitChange = (val) => {
      if (!isEqual(props.modelValue, val)) {
        emit("change", val);
      }
    };
    const getLastNotDisabledIndex = (value) => findLastIndex(
      value,
      (it) => !states.disabledOptions.has(it)
    );
    const deletePrevTag = (e) => {
      if (!props.multiple)
        return;
      if (e.code === EVENT_CODE.delete)
        return;
      const value = e.target.value;
      if (value.length <= 0 && !toggleLastOptionHitState()) {
        const value2 = props.modelValue.slice();
        const lastNotDisabledIndex = getLastNotDisabledIndex(value2);
        if (lastNotDisabledIndex < 0)
          return;
        value2.splice(lastNotDisabledIndex, 1);
        emit(UPDATE_MODEL_EVENT, value2);
        emitChange(value2);
      }
      if (value.length === 1 && props.modelValue.length === 0) {
        states.currentPlaceholder = states.cachedPlaceHolder;
      }
    };
    const deleteTag = (tag) => {
      const hasTag = states.cachedOptions.get(tag);
      if (!hasTag)
        return;
      const index = getValueIndex(selectedArray.value, hasTag);
      if (index > -1 && !selectDisabled.value) {
        const value = props.modelValue.slice();
        value.splice(index, 1);
        emit(UPDATE_MODEL_EVENT, value);
        emitChange(value);
        emit("remove-tag", tag);
      }
      focus();
    };
    const deleteSelected = () => {
      const value = props.multiple ? [] : props.notValue;
      if (isArray$1(value)) {
        for (const item of selectedArray.value) {
          if (item.isDisabled)
            value.push(item.value);
        }
      }
      emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
      states.hoverIndex = -1;
      states.visible = false;
      emit("clear");
      focus();
    };
    const handleOptionSelect = (option, byClick) => {
      var _a;
      if (props.multiple) {
        let modelValue = props.modelValue;
        if (!isArray$1(props.modelValue)) {
          if (states.options.has(modelValue)) {
            modelValue = [modelValue];
          } else {
            modelValue = [];
          }
        }
        const value = modelValue.slice();
        const optionIndex = getValueIndex(selectedArray.value, option);
        if (optionIndex > -1) {
          value.splice(optionIndex, 1);
        } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
          value.push(option.value);
        }
        emit(UPDATE_MODEL_EVENT, value);
        emitChange(value);
        if (option.created) {
          states.query = "";
          handleQueryChange("");
        }
        if (props.filter)
          (_a = input.value) == null ? void 0 : _a.focus();
      } else {
        emit(UPDATE_MODEL_EVENT, option.value);
        emitChange(option.value);
        states.visible = false;
      }
      states.isSilentBlur = byClick;
      setSoftFocus();
      if (states.visible)
        return;
      vue.nextTick(() => {
        scrollToOption(option);
      });
    };
    const getValueIndex = (arr, option) => {
      let index = -1;
      arr.some((item, i) => {
        if (isEqual(item.value, option.value)) {
          index = i;
          return true;
        }
        return false;
      });
      return index;
    };
    const setSoftFocus = () => {
      states.softFocus = true;
      const _input = input.value || reference.value;
      if (_input) {
        _input == null ? void 0 : _input.focus();
      }
    };
    const scrollToOption = (option) => {
      var _a, _b, _c, _d;
      let target;
      if (option == null ? void 0 : option.value) {
        const options = optionsArray.value.filter(
          (item) => item.value === option.value
        );
        if (options.length > 0) {
          target = options[0].el;
        }
      }
      if (popperRef.value && target) {
        const menu = (_c = (_b = (_a = popperRef.value) == null ? void 0 : _a.contentRef) == null ? void 0 : _b.querySelector) == null ? void 0 : _c.call(_b, `.${ns.e("options")}`);
        if (menu) {
          setStyle(menu, "scroll-behavior", "smooth");
          scrollIntoView(menu, target);
          removeStyle(menu, "scroll-behavior");
        }
      }
      (_d = scrollbar.value) == null ? void 0 : _d.handleScroll();
    };
    const onOptionCreate = (value, option) => {
      states.optionsCount++;
      states.filteredOptionsCount++;
      states.options.set(value, option);
      states.cachedOptions.set(value, option);
      option.isDisabled && states.disabledOptions.set(value, option);
    };
    const onOptionDestroy = (value, option) => {
      if (states.options.get(value) === option) {
        states.optionsCount--;
        states.filteredOptionsCount--;
        states.options.delete(value);
      }
    };
    const resetInputState = (e) => {
      if (e.code !== EVENT_CODE.backspace)
        toggleLastOptionHitState(false);
    };
    const toggleLastOptionHitState = (hit) => {
      if (!selectedArray.value.length)
        return;
      const lastNotDisabledIndex = getLastNotDisabledIndex(
        selectedArray.value.map((it) => it.value)
      );
      const option = selectedArray.value[lastNotDisabledIndex];
      if (!option)
        return;
      if (isBoolean(hit)) {
        option.hit = hit;
        return hit;
      }
      option.hit = !option.hit;
      return option.hit;
    };
    const handleComposition = (event) => {
      var _a;
      const text = (_a = event.target) == null ? void 0 : _a.value;
      if (event.type === "compositionend") {
        states.isOnComposition = false;
        vue.nextTick(() => handleQueryChange(text));
      } else {
        const lastCharacter = text[text.length - 1] || "";
        states.isOnComposition = !isKorean(lastCharacter);
      }
    };
    const handleTarget = (target, condition = true) => {
      if (condition)
        states.targetOnElement = target;
    };
    const handleMenuEnter = () => {
      vue.nextTick(() => scrollToOption(selectedArray.value[0]));
    };
    const focus = () => {
      var _a;
      states.visible = true;
      (_a = reference.value) == null ? void 0 : _a.focus();
    };
    const handleFocus = (event) => {
      if (!states.softFocus) {
        if (props.filter) {
          if (!states.visible) {
            states.menuVisibleOnFocus = true;
          }
        }
        emit("focus", event);
      } else {
        states.softFocus = false;
      }
    };
    const blur = () => {
      var _a;
      states.visible = false;
      (_a = reference.value) == null ? void 0 : _a.blur();
    };
    const handleBlur = (event) => {
      vue.nextTick(() => {
        if (states.isSilentBlur) {
          states.isSilentBlur = false;
        } else {
          emit("blur", event);
        }
      });
      states.softFocus = false;
    };
    const handleClearClick = () => {
      deleteSelected();
    };
    const showClearable = vue.computed(() => {
      if (!props.clearable || props.disabled || props.loading)
        return false;
      if (optionsArray.value.length === 0)
        return false;
      const ignoreDisabledOptions = optionsArray.value.filter(
        (e) => e.isDisabled === false
      );
      if (ignoreDisabledOptions.length === 0)
        return false;
      return states.mouseEnter;
    });
    const handleClose = () => {
      states.visible = false;
    };
    const handleKeydownEscape = (event) => {
      if (states.visible) {
        event.preventDefault();
        event.stopPropagation();
        states.visible = false;
      }
    };
    const toggleMenu = (e) => {
      var _a;
      if (e && !states.mouseEnter)
        return;
      if (!selectDisabled.value) {
        if (states.menuVisibleOnFocus) {
          states.menuVisibleOnFocus = false;
        } else {
          if (!popperRef.value || !popperRef.value.isFocusInsideContent) {
            states.visible = !states.visible;
          }
        }
        if (states.visible) {
          (_a = input.value || reference.value) == null ? void 0 : _a.focus();
        }
      }
    };
    const selectOption = () => {
      if (!states.visible) {
        toggleMenu();
      } else {
        if (optionsArray.value[states.hoverIndex]) {
          handleOptionSelect(optionsArray.value[states.hoverIndex], false);
        }
      }
    };
    const optionsAllDisabled = vue.computed(
      () => optionsArray.value.filter((option) => option.visible).every((option) => option.isDisabled)
    );
    const navigateOptions = (direction = "next") => {
      if (!states.visible) {
        states.visible = true;
        return;
      }
      if (states.options.size === 0 || states.filteredOptionsCount === 0)
        return;
      if (states.isOnComposition)
        return;
      if (!optionsAllDisabled.value) {
        if (direction === "next") {
          states.hoverIndex++;
          if (states.hoverIndex === states.options.size) {
            states.hoverIndex = 0;
          }
        } else if (direction === "prev") {
          states.hoverIndex--;
          if (states.hoverIndex < 0) {
            states.hoverIndex = states.options.size - 1;
          }
        }
        const option = optionsArray.value[states.hoverIndex];
        if (option.isDisabled === true || option.groupDisabled === true || !option.visible) {
          navigateOptions(direction);
        }
        vue.nextTick(
          () => !isNil(hoverOption.value) && scrollToOption(hoverOption.value)
        );
      }
    };
    const handleMouseEnter = () => {
      states.mouseEnter = true;
    };
    const handleMouseLeave = () => {
      states.mouseEnter = false;
    };
    const processBeforeOpen = () => true;
    const processBeforeClose = () => {
      if (states.targetOnElement == null)
        return true;
      return !["chip-close", "input-filter"].includes(states.targetOnElement);
    };
    return {
      showNewOption,
      inputId,
      optionsArray,
      cachedOptionsArray,
      selectedArray,
      handleResize,
      debouncedOnInputChange,
      debouncedQueryChange,
      deletePrevTag,
      deleteTag,
      deleteSelected,
      handleOptionSelect,
      scrollToOption,
      readonly,
      showClose,
      handleTarget,
      setSelected,
      managePlaceholder,
      selectDisabled,
      toggleLastOptionHitState,
      resetInputState,
      handleComposition,
      onOptionCreate,
      onOptionDestroy,
      handleMenuEnter,
      focus,
      handleFocus,
      blur,
      handleBlur,
      handleClearClick,
      showClearable,
      handleClose,
      handleKeydownEscape,
      toggleMenu,
      selectOption,
      navigateOptions,
      dropMenuVisible,
      queryChange,
      showTagList,
      collapseTagList,
      reference,
      input,
      popperRef,
      chips,
      selectWrapper,
      scrollbar,
      handleMouseEnter,
      handleMouseLeave,
      processBeforeOpen,
      processBeforeClose,
      emptyText,
      resetHoverIndex
    };
  };

  const _hoisted_1$9 = ["placeholder", "disabled"];
  const _hoisted_2$4 = ["id", "readonly"];
  const _hoisted_3$2 = ["for"];
  const __default__$m = vue.defineComponent({
    name: "VsSelect",
    inheritAttrs: false
  });
  const _sfc_main$n = vue.defineComponent({
    ...__default__$m,
    props: selectProps,
    emits: selectEmits,
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const messageTypes = ["success", "warn", "danger", "primary", "dark"];
      const ns = useNamespace("select");
      const states = useSelectStates(props);
      const color = useColor("primary");
      const colorCssVar = vue.computed(
        () => ns.cssVar({
          color: getVsColor(color.value)
        })
      );
      const optionsAnimation = vue.computed(() => ns.b());
      const {
        showNewOption,
        debouncedQueryChange,
        managePlaceholder,
        deletePrevTag,
        deleteTag,
        handleClearClick,
        showClose,
        inputId,
        emptyText,
        readonly,
        input,
        reference,
        showTagList,
        collapseTagList,
        chips,
        popperRef,
        selectDisabled,
        selectWrapper,
        handleMouseEnter,
        handleMouseLeave,
        handleTarget,
        selectOption,
        handleComposition,
        navigateOptions,
        handleKeydownEscape,
        dropMenuVisible,
        debouncedOnInputChange,
        handleFocus,
        handleBlur,
        toggleMenu,
        handleMenuEnter,
        handleResize,
        setSelected,
        handleClose,
        onOptionCreate,
        onOptionDestroy,
        handleOptionSelect,
        focus,
        blur,
        processBeforeOpen,
        processBeforeClose,
        queryChange,
        optionsArray,
        cachedOptionsArray,
        selectedArray
      } = useSelect(props, states, emit);
      const { visible, hoverIndex, query } = toRefs(states);
      const popperPaneRef = vue.computed(() => {
        var _a;
        return unrefElement((_a = popperRef.value) == null ? void 0 : _a.contentRef);
      });
      if (props.multiple && !Array.isArray(props.modelValue)) {
        emit(UPDATE_MODEL_EVENT, []);
      }
      if (!props.multiple && Array.isArray(props.modelValue)) {
        emit(UPDATE_MODEL_EVENT, "");
      }
      const selectKls = vue.computed(() => {
        var _a, _b;
        return [
          ns.is("block", props.block),
          ns.b(),
          ns.em("state", props.state),
          ns.is("open", dropMenuVisible.value),
          ns.is("hovering", states.mouseEnter),
          ns.is("focus", states.softFocus),
          ns.is("disabled", selectDisabled.value),
          ns.is("multiple", props.multiple),
          ns.is("loading", props.loading),
          ns.is((_b = (_a = popperRef.value) == null ? void 0 : _a.popperPlacement) != null ? _b : "bottom"),
          { [ns.m("has-label")]: props.label || props.labelFloat }
        ];
      });
      const selectStyle = vue.computed(() => [colorCssVar.value]);
      vue.onMounted(() => {
        states.cachedPlaceHolder = states.currentPlaceholder = props.placeholder;
        if (props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0) {
          states.currentPlaceholder = "";
        }
        useResizeObserver(selectWrapper, handleResize);
        setSelected();
      });
      vue.provide(
        selectContextKey,
        vue.reactive({
          multiple: vue.toRef(props, "multiple"),
          multipleLimit: vue.toRef(props, "multipleLimit"),
          states,
          queryChange,
          hoverIndex,
          selectWrapper,
          selectedArray,
          optionsArray,
          cachedOptionsArray,
          handleTarget,
          setSelected,
          handleOptionSelect
        })
      );
      vue.provide(selectRegisterKey, (option) => {
        option.index = states.optionsCount;
        onOptionCreate(option.value, option);
        return {
          updateOption: (newOption) => {
            onOptionDestroy(option.value, option);
            onOptionCreate(newOption.value, newOption);
          },
          unregister: () => {
            const doesSelected = selectedArray.value.some(
              (e) => e.value == option.value
            );
            vue.nextTick(() => {
              if (states.cachedOptions.get(option.value) === option && !doesSelected) {
                states.cachedOptions.delete(option.value);
              }
            });
            onOptionDestroy(option.value, option);
          }
        };
      });
      __expose({
        focus,
        blur
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(VsPopper), {
          ref_key: "popperRef",
          ref: popperRef,
          visible: vue.unref(dropMenuVisible),
          "onUpdate:visible": _cache[36] || (_cache[36] = ($event) => vue.isRef(dropMenuVisible) ? dropMenuVisible.value = $event : null),
          trigger: "click",
          placement: "bottom",
          persistent: "",
          animation: optionsAnimation.value,
          flip: _ctx.flip,
          fit: _ctx.fit,
          "hide-after": _ctx.hideAfter,
          "show-after": _ctx.showAfter,
          loading: _ctx.loading,
          disabled: _ctx.disabled,
          "on-blur": _ctx.onBlur,
          "on-focus": _ctx.onFocus,
          "on-click": _ctx.onClick,
          "on-contextmenu": _ctx.onContextmenu,
          "on-mouseenter": _ctx.onMouseenter,
          "on-mouseleave": _ctx.onMouseleave,
          "on-keydown": _ctx.onKeydown,
          teleported: _ctx.teleported,
          strategy: _ctx.strategy,
          "popper-class": [vue.unref(ns).e("content"), vue.unref(useVuesaxBaseComponent)(vue.unref(color))],
          "popper-style": colorCssVar.value,
          "show-arrow": false,
          offset: 0,
          "process-before-open": vue.unref(processBeforeOpen),
          "process-before-close": vue.unref(processBeforeClose),
          onShow: vue.unref(handleMenuEnter)
        }, {
          content: vue.withCtx(() => [
            vue.withDirectives(vue.createVNode(vue.unref(VsScrollbar), {
              "max-height": "200",
              thickness: "3",
              "wrap-class": [
                vue.unref(ns).e("options"),
                vue.unref(ns).is(
                  "empty",
                  !_ctx.allowCreate && Boolean(vue.unref(query)) && vue.unref(states).filteredOptionsCount === 0
                )
              ],
              native: _ctx.nativeScrollbar,
              onMouseleave: _cache[35] || (_cache[35] = ($event) => hoverIndex.value = -1)
            }, {
              default: vue.withCtx(() => [
                vue.unref(showNewOption) ? (vue.openBlock(), vue.createBlock(Option, {
                  key: 0,
                  value: vue.unref(query),
                  created: true
                }, null, 8, ["value"])) : vue.createCommentVNode("v-if", true),
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["wrap-class", "native"]), [
              [vue.vShow, vue.unref(states).options.size > 0 && !_ctx.loading]
            ]),
            vue.unref(emptyText) && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && vue.unref(states).options.size === 0) ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 0 },
              [
                _ctx.$slots.empty ? vue.renderSlot(_ctx.$slots, "empty", { key: 0 }) : (vue.openBlock(), vue.createElementBlock(
                  "p",
                  {
                    key: 1,
                    class: vue.normalizeClass(vue.unref(ns).em("options", "empty"))
                  },
                  vue.toDisplayString(vue.unref(emptyText)),
                  3
                ))
              ],
              64
            )) : vue.createCommentVNode("v-if", true)
          ]),
          default: vue.withCtx(() => {
            var _a;
            return [
              vue.withDirectives((vue.openBlock(), vue.createElementBlock(
                "div",
                {
                  ref_key: "selectWrapper",
                  ref: selectWrapper,
                  class: vue.normalizeClass(selectKls.value),
                  style: vue.normalizeStyle(selectStyle.value),
                  onMouseenter: _cache[32] || (_cache[32] = (...args) => vue.unref(handleMouseEnter) && vue.unref(handleMouseEnter)(...args)),
                  onMouseleave: _cache[33] || (_cache[33] = (...args) => vue.unref(handleMouseLeave) && vue.unref(handleMouseLeave)(...args)),
                  onClick: _cache[34] || (_cache[34] = (...args) => vue.unref(toggleMenu) && vue.unref(toggleMenu)(...args))
                },
                [
                  _ctx.multiple ? (vue.openBlock(), vue.createElementBlock(
                    "div",
                    {
                      key: 0,
                      ref_key: "chips",
                      ref: chips,
                      class: vue.normalizeClass([vue.unref(ns).e("chips")])
                    },
                    [
                      (vue.openBlock(true), vue.createElementBlock(
                        vue.Fragment,
                        null,
                        vue.renderList(vue.unref(showTagList), (item, cIndex) => {
                          return vue.openBlock(), vue.createBlock(VsChip, {
                            key: cIndex + "chip",
                            shape: _ctx.shape,
                            disabled: vue.unref(selectDisabled) || item.isDisabled,
                            hit: item.hit,
                            onClose: ($event) => vue.unref(deleteTag)(item.value)
                          }, {
                            default: vue.withCtx(() => [
                              vue.createTextVNode(
                                vue.toDisplayString(item.currentLabel),
                                1
                              )
                            ]),
                            _: 2
                          }, 1032, ["shape", "disabled", "hit", "onClose"]);
                        }),
                        128
                      )),
                      _ctx.collapseChips && vue.unref(selectedArray).length > _ctx.maxCollapseChips ? (vue.openBlock(), vue.createBlock(VsChip, {
                        key: 0,
                        "show-close": false,
                        shape: _ctx.shape,
                        hit: vue.unref(collapseTagList).some((item) => item.hit)
                      }, {
                        default: vue.withCtx(() => [
                          vue.createTextVNode(
                            " + " + vue.toDisplayString(vue.unref(selectedArray).length - _ctx.maxCollapseChips),
                            1
                          )
                        ]),
                        _: 1
                      }, 8, ["shape", "hit"])) : vue.createCommentVNode("v-if", true),
                      _ctx.filter && !vue.unref(selectDisabled) ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
                        key: 1,
                        ref_key: "input",
                        ref: input,
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.isRef(query) ? query.value = $event : null),
                        type: "text",
                        class: vue.normalizeClass([
                          vue.unref(ns).e("input-filter"),
                          vue.unref(ns).is("disabled", vue.unref(selectDisabled)),
                          vue.unref(ns).be("chips", "input")
                        ]),
                        placeholder: vue.unref(states).selectedLabel ? "" : (_a = vue.unref(states).query) != null ? _a : "",
                        disabled: vue.unref(selectDisabled),
                        onFocus: _cache[1] || (_cache[1] = (...args) => vue.unref(handleFocus) && vue.unref(handleFocus)(...args)),
                        onBlur: _cache[2] || (_cache[2] = (...args) => vue.unref(handleBlur) && vue.unref(handleBlur)(...args)),
                        onMouseenter: _cache[3] || (_cache[3] = ($event) => vue.unref(handleTarget)("input-filter")),
                        onMouseleave: _cache[4] || (_cache[4] = ($event) => vue.unref(handleTarget)(null)),
                        onKeyup: _cache[5] || (_cache[5] = (...args) => vue.unref(managePlaceholder) && vue.unref(managePlaceholder)(...args)),
                        onKeydown: [
                          _cache[6] || (_cache[6] = vue.withKeys(vue.withModifiers(($event) => vue.unref(navigateOptions)("next"), ["prevent"]), ["down"])),
                          _cache[7] || (_cache[7] = vue.withKeys(vue.withModifiers(($event) => vue.unref(navigateOptions)("prev"), ["prevent"]), ["up"])),
                          _cache[8] || (_cache[8] = vue.withKeys(
                            (...args) => vue.unref(handleKeydownEscape) && vue.unref(handleKeydownEscape)(...args),
                            ["esc"]
                          )),
                          _cache[9] || (_cache[9] = vue.withKeys(vue.withModifiers(
                            (...args) => vue.unref(selectOption) && vue.unref(selectOption)(...args),
                            ["stop", "prevent"]
                          ), ["enter"])),
                          _cache[10] || (_cache[10] = vue.withKeys(
                            (...args) => vue.unref(deletePrevTag) && vue.unref(deletePrevTag)(...args),
                            ["delete"]
                          )),
                          _cache[11] || (_cache[11] = vue.withKeys(($event) => visible.value = false, ["tab"]))
                        ],
                        onCompositionstart: _cache[12] || (_cache[12] = (...args) => vue.unref(handleComposition) && vue.unref(handleComposition)(...args)),
                        onCompositionupdate: _cache[13] || (_cache[13] = (...args) => vue.unref(handleComposition) && vue.unref(handleComposition)(...args)),
                        onCompositionend: _cache[14] || (_cache[14] = (...args) => vue.unref(handleComposition) && vue.unref(handleComposition)(...args)),
                        onInput: _cache[15] || (_cache[15] = (...args) => vue.unref(debouncedQueryChange) && vue.unref(debouncedQueryChange)(...args))
                      }, null, 42, _hoisted_1$9)), [
                        [vue.vModelText, vue.unref(query)]
                      ]) : vue.createCommentVNode("v-if", true)
                    ],
                    2
                  )) : vue.createCommentVNode("v-if", true),
                  vue.withDirectives(vue.createElementVNode("input", {
                    id: vue.unref(inputId),
                    ref_key: "reference",
                    ref: reference,
                    "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => vue.unref(states).selectedLabel = $event),
                    class: vue.normalizeClass([vue.unref(ns).e("input"), vue.unref(ns).is("multiple", _ctx.multiple)]),
                    readonly: vue.unref(readonly),
                    onFocus: _cache[17] || (_cache[17] = (...args) => vue.unref(handleFocus) && vue.unref(handleFocus)(...args)),
                    onBlur: _cache[18] || (_cache[18] = (...args) => vue.unref(handleBlur) && vue.unref(handleBlur)(...args)),
                    onMouseenter: _cache[19] || (_cache[19] = ($event) => vue.unref(handleTarget)("input-filter", !vue.unref(readonly))),
                    onMouseleave: _cache[20] || (_cache[20] = ($event) => vue.unref(handleTarget)(null)),
                    onInput: _cache[21] || (_cache[21] = (...args) => vue.unref(debouncedOnInputChange) && vue.unref(debouncedOnInputChange)(...args)),
                    onPaste: _cache[22] || (_cache[22] = (...args) => vue.unref(debouncedOnInputChange) && vue.unref(debouncedOnInputChange)(...args)),
                    onCompositionstart: _cache[23] || (_cache[23] = (...args) => vue.unref(handleComposition) && vue.unref(handleComposition)(...args)),
                    onCompositionupdate: _cache[24] || (_cache[24] = (...args) => vue.unref(handleComposition) && vue.unref(handleComposition)(...args)),
                    onCompositionend: _cache[25] || (_cache[25] = (...args) => vue.unref(handleComposition) && vue.unref(handleComposition)(...args)),
                    onKeydown: [
                      _cache[26] || (_cache[26] = vue.withKeys(vue.withModifiers(($event) => vue.unref(navigateOptions)("next"), ["prevent"]), ["down"])),
                      _cache[27] || (_cache[27] = vue.withKeys(vue.withModifiers(($event) => vue.unref(navigateOptions)("prev"), ["prevent"]), ["up"])),
                      _cache[28] || (_cache[28] = vue.withKeys(vue.withModifiers(
                        (...args) => vue.unref(selectOption) && vue.unref(selectOption)(...args),
                        ["prevent"]
                      ), ["enter"])),
                      _cache[29] || (_cache[29] = vue.withKeys(
                        (...args) => vue.unref(handleKeydownEscape) && vue.unref(handleKeydownEscape)(...args),
                        ["esc"]
                      )),
                      _cache[30] || (_cache[30] = vue.withKeys(($event) => vue.unref(states).visible = false, ["tab"]))
                    ]
                  }, null, 42, _hoisted_2$4), [
                    [vue.vModelText, vue.unref(states).selectedLabel]
                  ]),
                  _ctx.label ? (vue.openBlock(), vue.createElementBlock("label", {
                    key: 1,
                    for: vue.unref(inputId),
                    class: vue.normalizeClass([
                      vue.unref(ns).e("label"),
                      vue.unref(ns).is(
                        "placeholder",
                        _ctx.labelFloat && !vue.unref(dropMenuVisible) && (vue.unref(isEqual)(_ctx.modelValue, _ctx.notValue) || !_ctx.modelValue && _ctx.modelValue != 0)
                      )
                    ])
                  }, vue.toDisplayString(_ctx.label), 11, _hoisted_3$2)) : vue.createCommentVNode("v-if", true),
                  !_ctx.multiple && !_ctx.labelFloat && vue.unref(states).currentPlaceholder ? (vue.openBlock(), vue.createElementBlock(
                    "span",
                    {
                      key: 2,
                      class: vue.normalizeClass([vue.unref(ns).e("placeholder"), vue.unref(ns).is("hidden", !!_ctx.modelValue)])
                    },
                    vue.toDisplayString(vue.unref(states).currentPlaceholder),
                    3
                  )) : vue.createCommentVNode("v-if", true),
                  _ctx.loading ? (vue.openBlock(), vue.createBlock(vue.unref(IconLoading), {
                    key: 3,
                    class: "vs-select__loading"
                  })) : vue.createCommentVNode("v-if", true),
                  vue.createVNode(vue.unref(VsIcon), {
                    class: vue.normalizeClass(vue.unref(ns).e("arrow")),
                    size: "14"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(chevron_down_default))
                    ]),
                    _: 1
                  }, 8, ["class"]),
                  vue.createVNode(vue.Transition, { name: "v-clearable" }, {
                    default: vue.withCtx(() => [
                      vue.unref(showClose) ? (vue.openBlock(), vue.createElementBlock(
                        "span",
                        {
                          key: 0,
                          class: vue.normalizeClass(vue.unref(ns).e("clearable")),
                          onClick: _cache[31] || (_cache[31] = (...args) => vue.unref(handleClearClick) && vue.unref(handleClearClick)(...args))
                        },
                        [
                          vue.createVNode(vue.unref(IconClose), {
                            hover: "less",
                            scale: "0.675"
                          })
                        ],
                        2
                      )) : vue.createCommentVNode("v-if", true)
                    ]),
                    _: 1
                  }),
                  (vue.openBlock(), vue.createElementBlock(
                    vue.Fragment,
                    null,
                    vue.renderList(messageTypes, (messageType, index) => {
                      return vue.createVNode(
                        vue.unref(_CollapseTransition),
                        { key: index },
                        {
                          default: vue.withCtx(() => [
                            _ctx.$slots[`message-${messageType}`] ? (vue.openBlock(), vue.createElementBlock(
                              "div",
                              {
                                key: 0,
                                class: vue.normalizeClass([vue.unref(ns).e("message"), vue.unref(ns).em("message", messageType)])
                              },
                              [
                                vue.renderSlot(_ctx.$slots, `message-${messageType}`)
                              ],
                              2
                            )) : vue.createCommentVNode("v-if", true)
                          ]),
                          _: 2
                        },
                        1024
                      );
                    }),
                    64
                  ))
                ],
                38
              )), [
                [vue.unref(ClickOutside), vue.unref(handleClose), popperPaneRef.value]
              ])
            ];
          }),
          _: 3
        }, 8, ["visible", "animation", "flip", "fit", "hide-after", "show-after", "loading", "disabled", "on-blur", "on-focus", "on-click", "on-contextmenu", "on-mouseenter", "on-mouseleave", "on-keydown", "teleported", "strategy", "popper-class", "popper-style", "process-before-open", "process-before-close", "onShow"]);
      };
    }
  });
  var Select = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__file", "select.vue"]]);

  const optionGroupProps = buildProps({
    label: {
      type: String,
      required: true
    }
  });

  const __default__$l = vue.defineComponent({
    name: "VsOptionGroup"
  });
  const _sfc_main$m = vue.defineComponent({
    ...__default__$l,
    props: optionGroupProps,
    setup(__props) {
      const ns = useNamespace("option-group");
      const select = vue.inject(selectContextKey);
      if (!select) {
        throwError(
          "Option Group",
          "`option-group` component must be called inside `select` component"
        );
      }
      const visible = vue.ref(true);
      const options = vue.ref(/* @__PURE__ */ new Map());
      const optionsArray = vue.computed(() => Array.from(options.value.values()));
      vue.watch(
        () => select.queryChange,
        () => {
          visible.value = optionsArray.value.some((option) => option.visible === true);
        },
        { flush: "post" }
      );
      vue.provide(optionGroupRegisterKey, (option) => {
        options.value.set(option.value, option);
        return {
          unregister() {
            options.value.delete(option.value);
          }
        };
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass([vue.unref(ns).b(), vue.unref(ns).is("hidden", !visible.value)])
          },
          [
            vue.createElementVNode(
              "h5",
              null,
              vue.toDisplayString(_ctx.label),
              1
            ),
            vue.renderSlot(_ctx.$slots, "default")
          ],
          2
        );
      };
    }
  });
  var OptionGroup = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__file", "option-group.vue"]]);

  const VsSelect = withInstall(Select, {
    Option,
    OptionGroup
  });
  const VsOption = withNoopInstall(Option);
  const VsOptionGroup = withNoopInstall(OptionGroup);

  const paginationSizesProps = buildProps({
    pageSize: {
      type: Number,
      required: true
    },
    pageSizes: {
      type: definePropType(Array),
      default: () => mutable([10, 20, 30, 40, 50, 100])
    }
  });
  const paginationSizesEmits = {
    "page-size-change": (val) => isNumber(val)
  };

  const __default__$k = vue.defineComponent({
    name: "VsPaginationSizes"
  });
  const _sfc_main$l = vue.defineComponent({
    ...__default__$k,
    props: paginationSizesProps,
    emits: paginationSizesEmits,
    setup(__props, { emit }) {
      const props = __props;
      const ns = useNamespace("pagination");
      const { disabled, handleSizeChange } = usePagination();
      const innerPageSize = vue.ref(props.pageSize);
      vue.watch(
        () => props.pageSizes,
        (newVal, oldVal) => {
          if (isEqual(newVal, oldVal))
            return;
          if (Array.isArray(newVal)) {
            const pageSize = newVal.includes(props.pageSize) ? props.pageSize : props.pageSizes[0];
            emit("page-size-change", pageSize);
          }
        }
      );
      vue.watch(
        () => props.pageSize,
        (newVal) => {
          innerPageSize.value = newVal;
        }
      );
      const innerPageSizes = vue.computed(() => props.pageSizes);
      function handleChange(val) {
        if (val !== innerPageSize.value && typeof val === "number") {
          innerPageSize.value = val;
          handleSizeChange(Number(val));
        }
      }
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "span",
          {
            class: vue.normalizeClass(vue.unref(ns).e("sizes"))
          },
          [
            vue.createVNode(vue.unref(VsSelect), {
              "model-value": innerPageSize.value,
              disabled: vue.unref(disabled),
              onChange: handleChange
            }, {
              default: vue.withCtx(() => [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList(innerPageSizes.value, (item) => {
                    return vue.openBlock(), vue.createBlock(vue.unref(VsOption), {
                      key: item,
                      value: item,
                      label: `${item} / page`
                    }, null, 8, ["value", "label"]);
                  }),
                  128
                ))
              ]),
              _: 1
            }, 8, ["model-value", "disabled"])
          ],
          2
        );
      };
    }
  });
  var Sizes = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__file", "sizes.vue"]]);

  const _hoisted_1$8 = ["disabled"];
  const __default__$j = vue.defineComponent({
    name: "VsPaginationJumper"
  });
  const _sfc_main$k = vue.defineComponent({
    ...__default__$j,
    setup(__props) {
      const ns = useNamespace("pagination");
      const { pageCount, disabled, currentPage, changeEvent } = usePagination();
      const userInput = vue.ref();
      const innerValue = vue.computed(() => {
        var _a;
        return (_a = userInput.value) != null ? _a : currentPage.value;
      });
      function handleInput(val) {
        userInput.value = Number(val);
      }
      function handleChange(val) {
        val = Math.trunc(+val);
        changeEvent(+val);
        userInput.value = void 0;
      }
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("span", {
          class: vue.normalizeClass(vue.unref(ns).e("jump")),
          disabled: vue.unref(disabled)
        }, [
          vue.createElementVNode(
            "span",
            {
              class: vue.normalizeClass(vue.unref(ns).e("goto"))
            },
            "Goto",
            2
          ),
          vue.createVNode(vue.unref(VsInput), {
            type: "number",
            class: vue.normalizeClass([vue.unref(ns).e("editor"), vue.unref(ns).is("in-pagination")]),
            min: 1,
            max: vue.unref(pageCount),
            disabled: vue.unref(disabled),
            "model-value": innerValue.value,
            onChange: handleChange,
            "onUpdate:modelValue": handleInput
          }, null, 8, ["class", "max", "disabled", "model-value"])
        ], 10, _hoisted_1$8);
      };
    }
  });
  var Jumper = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__file", "jumper.vue"]]);

  const paginationTotalProps = buildProps({
    total: { type: Number }
  });

  const _hoisted_1$7 = ["disabled"];
  const __default__$i = vue.defineComponent({
    name: "VsPaginationTotal"
  });
  const _sfc_main$j = vue.defineComponent({
    ...__default__$i,
    props: paginationTotalProps,
    setup(__props) {
      const ns = useNamespace("pagination");
      const { disabled } = usePagination();
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("span", {
          class: vue.normalizeClass(vue.unref(ns).e("total")),
          disabled: vue.unref(disabled)
        }, " Total " + vue.toDisplayString(_ctx.total), 11, _hoisted_1$7);
      };
    }
  });
  var Total = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__file", "total.vue"]]);

  const paginationPagerProps = buildProps({
    pagerCount: {
      type: Number,
      default: 7
    },
    color: useColorProp,
    progress: { type: Boolean }
  });

  const _sfc_main$i = vue.defineComponent({
    __name: "progress",
    setup(__props) {
      const { pageCount, currentPage } = usePagination();
      const ns = useNamespace("pagination");
      const progress = vue.computed(() => currentPage.value * 100 / pageCount.value);
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(vue.unref(ns).e("progress"))
          },
          [
            vue.createElementVNode(
              "div",
              {
                class: "progress",
                style: vue.normalizeStyle({ width: `${progress.value}%` })
              },
              null,
              4
            )
          ],
          2
        );
      };
    }
  });
  var PaginationProgress = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__file", "progress.vue"]]);

  const _hoisted_1$6 = ["aria-current", "tabindex"];
  const _hoisted_2$3 = ["tabindex"];
  const _hoisted_3$1 = /* @__PURE__ */ vue.createElementVNode(
    "span",
    null,
    "...",
    -1
  );
  const _hoisted_4 = ["aria-label", "aria-current", "tabindex", "onClick", "onKeyup"];
  const _hoisted_5 = ["tabindex"];
  const _hoisted_6 = /* @__PURE__ */ vue.createElementVNode(
    "span",
    null,
    "...",
    -1
  );
  const _hoisted_7 = ["aria-current", "aria-label", "tabindex"];
  const __default__$h = vue.defineComponent({
    name: "VsPaginationPager"
  });
  const _sfc_main$h = vue.defineComponent({
    ...__default__$h,
    props: paginationPagerProps,
    emits: ["change"],
    setup(__props, { emit }) {
      const props = __props;
      const nsPager = useNamespace("pager");
      const nsIcon = useNamespace("icon");
      const {
        currentPage,
        disabled,
        pageCount,
        buttonsDotted,
        isPagerDisabled,
        isPagerLoading
      } = usePagination();
      const pagerRef = vue.ref();
      const showPrevMore = vue.ref(false);
      const showNextMore = vue.ref(false);
      const quickPrevHover = vue.ref(false);
      const quickNextHover = vue.ref(false);
      const quickPrevFocus = vue.ref(false);
      const quickNextFocus = vue.ref(false);
      const isChange = vue.ref(false);
      const pageActive = vue.reactive({
        left: 0
      });
      const pagers = vue.computed(() => {
        const pagerCount = props.pagerCount;
        const halfPagerCount = (pagerCount - 1) / 2;
        let showPrevMore2 = false;
        let showNextMore2 = false;
        if (pageCount.value > pagerCount) {
          if (currentPage.value > pagerCount - halfPagerCount) {
            showPrevMore2 = true;
          }
          if (currentPage.value < pageCount.value - halfPagerCount) {
            showNextMore2 = true;
          }
        }
        const array = [];
        if (showPrevMore2 && !showNextMore2) {
          const startPage = pageCount.value - (pagerCount - 2);
          for (let i = startPage; i < pageCount.value; i++) {
            array.push(i);
          }
        } else if (!showPrevMore2 && showNextMore2) {
          for (let i = 2; i < pagerCount; i++) {
            array.push(i);
          }
        } else if (showPrevMore2 && showNextMore2) {
          const offset = Math.floor(pagerCount / 2) - 1;
          for (let i = currentPage.value - offset; i <= currentPage.value + offset; i++) {
            array.push(i);
          }
        } else {
          for (let i = 2; i < pageCount.value; i++) {
            array.push(i);
          }
        }
        return array;
      });
      const tabindex = (index = Number.NaN) => isPagerDisabled(index) ? -1 : 0;
      vue.watchEffect(() => {
        const halfPagerCount = (props.pagerCount - 1) / 2;
        showPrevMore.value = false;
        showNextMore.value = false;
        if (pageCount.value > props.pagerCount) {
          if (currentPage.value > props.pagerCount - halfPagerCount) {
            showPrevMore.value = true;
          }
          if (currentPage.value < pageCount.value - halfPagerCount) {
            showNextMore.value = true;
          }
        }
      });
      vue.watch([pagerRef, currentPage], () => {
        vue.nextTick(() => {
          var _a;
          const pageActived = (_a = pagerRef.value) == null ? void 0 : _a.querySelector(`[aria-label="${currentPage.value}"]`);
          if (isNil(pageActived) || isNil(pagerRef.value)) {
            pageActive.left = 0;
            return;
          }
          isChange.value = true;
          const offsetLeftButtonActive = pageActived.offsetLeft;
          pageActive.left = offsetLeftButtonActive;
          setTimeout(() => isChange.value = false, 300);
        });
      });
      function onMouseEnter(forward = false) {
        if (disabled.value)
          return;
        if (forward) {
          quickPrevHover.value = true;
        } else {
          quickNextHover.value = true;
        }
      }
      function onFocus(forward = false) {
        if (forward) {
          quickPrevFocus.value = true;
        } else {
          quickNextFocus.value = true;
        }
      }
      function onMoreClick(key) {
        let newPage = currentPage.value;
        const pagerCountOffset = props.pagerCount - 2;
        if (key == "prev") {
          newPage = currentPage.value - pagerCountOffset;
        } else if (key == "next") {
          newPage = currentPage.value + pagerCountOffset;
        }
        emitChange(newPage);
      }
      function onPageClick(page) {
        if (!Number.isNaN(+page)) {
          if (page < 1)
            page = 1;
          if (page > pageCount.value)
            page = pageCount.value;
        }
        if (page != currentPage.value)
          emitChange(page);
      }
      function emitChange(page) {
        if (disabled.value || Number.isNaN(+page))
          return;
        emit("change", page);
      }
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            ref_key: "pagerRef",
            ref: pagerRef,
            class: vue.normalizeClass(vue.unref(nsPager).b())
          },
          [
            vue.unref(pageCount) > 0 ? (vue.openBlock(), vue.createElementBlock("button", {
              key: 0,
              class: vue.normalizeClass([[
                vue.unref(nsPager).is("active", vue.unref(currentPage) === 1),
                vue.unref(nsPager).is("disabled", vue.unref(isPagerDisabled)(1)),
                vue.unref(nsPager).is("loading", vue.unref(isPagerLoading)(1))
              ], "number"]),
              "aria-current": vue.unref(currentPage) === 1,
              "aria-label": "1",
              tabindex: tabindex(1),
              onClick: _cache[0] || (_cache[0] = ($event) => onPageClick(1)),
              onKeyup: _cache[1] || (_cache[1] = vue.withKeys(($event) => onPageClick(1), ["enter"]))
            }, [
              vue.createTextVNode(
                vue.toDisplayString(vue.unref(buttonsDotted) ? "" : 1) + " ",
                1
              ),
              vue.unref(isPagerLoading)(1) ? (vue.openBlock(), vue.createBlock(vue.unref(IconLoading), {
                key: 0,
                class: vue.normalizeClass(vue.unref(nsPager).e("loading"))
              }, null, 8, ["class"])) : vue.createCommentVNode("v-if", true)
            ], 42, _hoisted_1$6)) : vue.createCommentVNode("v-if", true),
            showPrevMore.value && !vue.unref(buttonsDotted) ? (vue.openBlock(), vue.createElementBlock("button", {
              key: 1,
              class: vue.normalizeClass([
                "more",
                "btn-quickprev",
                vue.unref(nsIcon).b(),
                vue.unref(nsPager).is("disabled", vue.unref(disabled))
              ]),
              tabindex: tabindex(),
              onMouseenter: _cache[2] || (_cache[2] = ($event) => onMouseEnter(true)),
              onMouseleave: _cache[3] || (_cache[3] = ($event) => quickPrevHover.value = false),
              onFocus: _cache[4] || (_cache[4] = ($event) => onFocus(true)),
              onBlur: _cache[5] || (_cache[5] = ($event) => quickPrevFocus.value = false),
              onClick: _cache[6] || (_cache[6] = ($event) => onMoreClick("prev")),
              onKeyup: _cache[7] || (_cache[7] = vue.withKeys(($event) => onMoreClick("prev"), ["enter"]))
            }, [
              vue.createVNode(vue.unref(chevron_left_double_default)),
              _hoisted_3$1
            ], 42, _hoisted_2$3)) : vue.createCommentVNode("v-if", true),
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(pagers.value, (pager) => {
                return vue.openBlock(), vue.createElementBlock("button", {
                  key: pager,
                  class: vue.normalizeClass([[
                    vue.unref(nsPager).is("active", vue.unref(currentPage) === pager),
                    vue.unref(nsPager).is("disabled", vue.unref(isPagerDisabled)(pager)),
                    vue.unref(nsPager).is("loading", vue.unref(isPagerLoading)(pager))
                  ], "number"]),
                  "aria-label": `${pager}`,
                  "aria-current": vue.unref(currentPage) === pager,
                  tabindex: tabindex(pager),
                  onClick: ($event) => onPageClick(pager),
                  onKeyup: vue.withKeys(($event) => onPageClick(pager), ["enter"])
                }, [
                  vue.createTextVNode(
                    vue.toDisplayString(vue.unref(buttonsDotted) ? "" : pager) + " ",
                    1
                  ),
                  vue.unref(isPagerLoading)(pager) ? (vue.openBlock(), vue.createBlock(vue.unref(IconLoading), {
                    key: 0,
                    class: vue.normalizeClass(vue.unref(nsPager).e("loading"))
                  }, null, 8, ["class"])) : vue.createCommentVNode("v-if", true)
                ], 42, _hoisted_4);
              }),
              128
            )),
            showNextMore.value && !vue.unref(buttonsDotted) ? (vue.openBlock(), vue.createElementBlock("button", {
              key: 2,
              class: vue.normalizeClass([
                "more",
                "btn-quicknext",
                vue.unref(nsIcon).b(),
                vue.unref(nsPager).is("disabled", vue.unref(disabled))
              ]),
              tabindex: tabindex(),
              onMouseenter: _cache[8] || (_cache[8] = ($event) => onMouseEnter()),
              onMouseleave: _cache[9] || (_cache[9] = ($event) => quickNextHover.value = false),
              onFocus: _cache[10] || (_cache[10] = ($event) => onFocus()),
              onBlur: _cache[11] || (_cache[11] = ($event) => quickNextFocus.value = false),
              onClick: _cache[12] || (_cache[12] = ($event) => onMoreClick("next")),
              onKeyup: _cache[13] || (_cache[13] = vue.withKeys(($event) => onMoreClick("next"), ["enter"]))
            }, [
              vue.createVNode(vue.unref(chevron_right_double_default)),
              _hoisted_6
            ], 42, _hoisted_5)) : vue.createCommentVNode("v-if", true),
            vue.unref(pageCount) > 1 ? (vue.openBlock(), vue.createElementBlock("button", {
              key: 3,
              class: vue.normalizeClass([[
                vue.unref(nsPager).is("active", vue.unref(currentPage) === vue.unref(pageCount)),
                vue.unref(nsPager).is("disabled", vue.unref(isPagerDisabled)(vue.unref(pageCount))),
                vue.unref(nsPager).is("loading", vue.unref(isPagerLoading)(vue.unref(pageCount)))
              ], "number"]),
              "aria-current": vue.unref(currentPage) === vue.unref(pageCount),
              "aria-label": `${vue.unref(pageCount)}`,
              tabindex: tabindex(vue.unref(pageCount)),
              onClick: _cache[14] || (_cache[14] = ($event) => onPageClick(vue.unref(pageCount))),
              onKeyup: _cache[15] || (_cache[15] = vue.withKeys(($event) => onPageClick(vue.unref(pageCount)), ["enter"]))
            }, [
              vue.createTextVNode(
                vue.toDisplayString(vue.unref(buttonsDotted) ? "" : vue.unref(pageCount)) + " ",
                1
              ),
              vue.unref(isPagerLoading)(vue.unref(pageCount)) ? (vue.openBlock(), vue.createBlock(vue.unref(IconLoading), {
                key: 0,
                class: vue.normalizeClass(vue.unref(nsPager).e("loading"))
              }, null, 8, ["class"])) : vue.createCommentVNode("v-if", true)
            ], 42, _hoisted_7)) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass([vue.unref(nsPager).e("aria-active"), vue.unref(nsPager).is("change", isChange.value)]),
                style: vue.normalizeStyle({ left: `${pageActive.left}px` })
              },
              vue.toDisplayString(vue.unref(buttonsDotted) ? "" : vue.unref(currentPage)),
              7
            ),
            _ctx.progress ? (vue.openBlock(), vue.createBlock(PaginationProgress, { key: 4 })) : vue.createCommentVNode("v-if", true)
          ],
          2
        );
      };
    }
  });
  var Pager = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__file", "pager.vue"]]);

  const isAbsent = (v) => typeof v !== "number";
  const paginationProps = buildProps({
    color: useColorProp,
    total: { type: Number },
    defaultCurrentPage: { type: Number },
    currentPage: { type: Number },
    defaultPageSize: { type: Number },
    pageSize: { type: Number },
    pageCount: { type: Number },
    pagerCount: {
      type: Number,
      validator: (value) => {
        return isNumber(value) && Math.trunc(value) === value && value > 4 && value < 22 && value % 2 === 1;
      },
      default: 7
    },
    layout: {
      type: definePropType([String, Array]),
      default: () => mutable([
        "prev",
        "pager",
        "next",
        "jumper",
        "->",
        "total",
        "slot",
        "sizes"
      ])
    },
    pageSizes: {
      type: definePropType(Array),
      default: () => mutable([10, 20, 30, 40, 50, 100])
    },
    hideOnSinglePage: { type: Boolean },
    prevText: {
      type: String,
      default: ""
    },
    prevIcon: {
      type: iconPropType,
      default: () => chevron_left_default
    },
    nextText: {
      type: String,
      default: ""
    },
    nextIcon: {
      type: iconPropType,
      default: () => chevron_right_default
    },
    infinite: { type: Boolean, default: false },
    progress: { type: Boolean },
    notMargin: { type: Boolean },
    buttonsDotted: { type: Boolean, default: false },
    shape: {
      type: String,
      values: ["circle", "square"],
      default: ""
    },
    disabled: { type: Boolean, default: false },
    disabledItems: {
      type: definePropType(Array),
      default: () => []
    },
    loadingItems: {
      type: definePropType(Array),
      default: () => []
    }
  });
  const paginationEmits = {
    "update:current-page": (val) => isNumber(val),
    "update:page-size": (val) => isNumber(val),
    "size-change": (val) => isNumber(val),
    "page-change": (val) => isNumber(val),
    "prev-click": (val) => isNumber(val),
    "next-click": (val) => isNumber(val)
  };
  const COMPONENT_NAME = "VsPagination";
  var Pagination = vue.defineComponent({
    name: COMPONENT_NAME,
    props: paginationProps,
    emits: paginationEmits,
    setup(props, { emit, slots }) {
      const ns = useNamespace("pagination");
      const vnodeProps = vue.getCurrentInstance().vnode.props || {};
      const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
      const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
      const assertValidUsage = vue.computed(() => {
        if (isAbsent(props.total) && isAbsent(props.pageCount))
          return "need to set props `total` or `pageCount`, otherwise count of pages cannot be determined.";
        if (!isAbsent(props.currentPage) && !hasCurrentPageListener)
          return "You have to use v-model binding of `currentPage`.\nIf you just want to provide a default value, `defaultCurrentPage` is here for you.";
        if (props.layout.includes("sizes")) {
          if (!isAbsent(props.pageCount)) {
            if (!hasPageSizeListener)
              return "Your layout having `sizes`. If `pageCount` is assign, then you have to watch `pageSize` change and recalculate `pageCount`.";
          } else if (!isAbsent(props.total)) {
            if (!isAbsent(props.pageSize)) {
              if (!hasPageSizeListener) {
                return "Your layout having `sizes`. If you have `pageSize` defined, meaning you want to have `pageSize` controlled yourself from component. Thus page size `listener` is required, you are account for `pageSize` changed.";
              }
            }
          }
        }
        return true;
      });
      const innerPageSize = vue.ref(
        isAbsent(props.defaultPageSize) ? 10 : props.defaultPageSize
      );
      const innerCurrentPage = vue.ref(
        isAbsent(props.defaultCurrentPage) ? 1 : props.defaultCurrentPage
      );
      const pageSizeBridge = vue.computed({
        get() {
          return isAbsent(props.pageSize) ? innerPageSize.value : props.pageSize;
        },
        set(v) {
          if (isAbsent(props.pageSize)) {
            innerPageSize.value = v;
          }
          if (hasPageSizeListener) {
            emit("update:page-size", v);
            emit("size-change", v);
          }
        }
      });
      const pageCountBridge = vue.computed(() => {
        let pageCount = 0;
        if (!isAbsent(props.pageCount)) {
          pageCount = props.pageCount;
        } else if (!isAbsent(props.total)) {
          pageCount = Math.max(1, Math.ceil(props.total / pageSizeBridge.value));
        }
        return pageCount;
      });
      const currentPageBridge = vue.computed({
        get() {
          return isAbsent(props.currentPage) ? innerCurrentPage.value : props.currentPage;
        },
        set(v) {
          let newCurrentPage = v;
          if (v < 1) {
            newCurrentPage = props.infinite ? pageCountBridge.value : 1;
          } else if (v > pageCountBridge.value) {
            newCurrentPage = props.infinite ? 1 : pageCountBridge.value;
          }
          if (isAbsent(props.currentPage)) {
            innerCurrentPage.value = newCurrentPage;
          }
          if (hasCurrentPageListener) {
            emit("update:current-page", newCurrentPage);
            emit("page-change", newCurrentPage);
          }
        }
      });
      vue.watch(currentPageBridge, (newValue, oldValue) => {
        if (isPagerDisabled(newValue) || isPagerLoading(newValue)) {
          let newVal = newValue;
          if (newValue > oldValue) {
            newVal += 1;
          } else {
            newVal -= 1;
          }
          if (newVal > pageCountBridge.value) {
            newVal = props.infinite ? 1 : oldValue;
          } else if (newVal <= 0) {
            newVal = props.infinite ? pageCountBridge.value : newValue + 1;
          }
          currentPageBridge.value = newVal;
        }
      });
      vue.watch(pageCountBridge, (val) => {
        if (currentPageBridge.value > val)
          currentPageBridge.value = val;
      });
      const isPagerLoading = (pager = Number.NaN) => props.loadingItems.includes(pager);
      const isPagerDisabled = (pager = Number.NaN) => props.disabled || props.disabledItems.includes(pager);
      function handleCurrentChange(val) {
        currentPageBridge.value = val;
      }
      function handleSizeChange(val) {
        pageSizeBridge.value = val;
        const newPageCount = pageCountBridge.value;
        if (currentPageBridge.value > newPageCount) {
          currentPageBridge.value = newPageCount;
        }
      }
      function prev() {
        if (props.disabled)
          return;
        currentPageBridge.value -= 1;
        emit("prev-click", currentPageBridge.value);
      }
      function next() {
        if (props.disabled)
          return;
        currentPageBridge.value += 1;
        emit("next-click", currentPageBridge.value);
      }
      function addClass(element, cls) {
        if (element) {
          if (!element.props) {
            element.props = {};
          }
          element.props.class = [element.props.class, cls].join(" ");
        }
      }
      vue.provide(paginationContextKey, {
        pageCount: pageCountBridge,
        disabled: vue.computed(() => props.disabled),
        currentPage: currentPageBridge,
        buttonsDotted: vue.computed(() => props.buttonsDotted),
        infinite: vue.computed(() => props.infinite),
        loadingItems: vue.computed(() => props.loadingItems),
        disabledItems: vue.computed(() => props.disabledItems),
        isPagerDisabled,
        isPagerLoading,
        changeEvent: handleCurrentChange,
        handleSizeChange
      });
      return () => {
        var _a, _b;
        if (assertValidUsage.value != true) {
          debugWarn(COMPONENT_NAME, assertValidUsage.value);
          return null;
        }
        if (!props.layout.length)
          return null;
        if (props.hideOnSinglePage && pageCountBridge.value <= 1)
          return null;
        const rootChildren = [];
        const rightWrapperChildren = [];
        const rightWrapperRoot = vue.h(
          "div",
          { class: ns.e("rightwrapper") },
          rightWrapperChildren
        );
        const TEMPLATE_MAP = {
          prev: vue.h(Prev, {
            prevText: props.prevText,
            prevIcon: props.prevIcon,
            onClick: prev
          }),
          jumper: vue.h(Jumper),
          pager: vue.h(Pager, {
            color: props.color,
            progress: props.progress,
            pagerCount: props.pagerCount,
            onChange: handleCurrentChange
          }),
          next: vue.h(Next, {
            nextText: props.nextText,
            nextIcon: props.nextIcon,
            onClick: next
          }),
          sizes: vue.h(Sizes, {
            pageSize: pageSizeBridge.value,
            pageSizes: props.pageSizes
          }),
          slot: (_b = (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots, {
            currentPage: currentPageBridge.value,
            total: props.total,
            pageSize: pageSizeBridge.value,
            pageSizes: props.pageSizes,
            pagerCount: props.pagerCount
          })) != null ? _b : null,
          total: vue.h(Total, { total: isAbsent(props.total) ? 0 : props.total })
        };
        const components = props.layout.toString().split(",").map((item) => item.trim());
        let haveRightWrapper = false;
        components.forEach((c) => {
          if (c === "->") {
            haveRightWrapper = true;
            return;
          }
          if (!haveRightWrapper) {
            rootChildren.push(TEMPLATE_MAP[c]);
          } else {
            rightWrapperChildren.push(TEMPLATE_MAP[c]);
          }
        });
        addClass(rootChildren[0], ns.is("first"));
        addClass(rootChildren[rootChildren.length - 1], ns.is("last"));
        if (haveRightWrapper && rightWrapperChildren.length > 0) {
          addClass(rightWrapperChildren[0], ns.is("first"));
          addClass(
            rightWrapperChildren[rightWrapperChildren.length - 1],
            ns.is("last")
          );
          rootChildren.push(rightWrapperRoot);
        }
        return vue.h(
          "div",
          {
            role: "pagination",
            "aria-label": "pagination",
            class: [
              ns.b(),
              ns.is(props.shape),
              ns.is("buttons-dotted", props.buttonsDotted),
              ns.is("not-margin", props.notMargin)
            ],
            style: ns.cssVar({
              color: getVsColor(props.color)
            })
          },
          rootChildren
        );
      };
    }
  });

  const VsPagination = withInstall(Pagination);

  const tooltipProps = buildProps({
    ...popperProps,
    shift: {
      type: definePropType([Object, Boolean]),
      default: true
    },
    color: useColorProp,
    animation: {
      type: String,
      default: "tooltip"
    },
    interactivity: {
      type: Boolean,
      default: false
    },
    appendTo: {
      type: definePropType(String)
    },
    type: {
      type: String,
      values: ["shadow", "border", "border-thick"],
      default: ""
    },
    shape: {
      type: String,
      values: ["circle", "square", "default"],
      default: ""
    },
    effect: {
      type: String,
      values: ["light", "dark"],
      default: "dark"
    },
    showArrow: {
      type: Boolean,
      default: true
    },
    loading: { type: Boolean },
    offset: {
      type: Number,
      default: 8
    },
    bottom: Boolean,
    left: Boolean,
    right: Boolean,
    top: Boolean,
    notHover: Boolean,
    shadow: Boolean,
    border: Boolean,
    borderThick: Boolean,
    square: Boolean,
    circle: Boolean
  });

  const useTooltipDeprecated = (props) => {
    useDeprecated(
      {
        scope: "vs-tooltip",
        type: "Prop",
        from: "[top, right, bottom, left]",
        version: "0.0.2",
        replacement: "placement",
        ref: "https://vuesax-alpha.vercel.app/components/tooltip#props"
      },
      vue.computed(() => props.top || props.right || props.bottom || props.left)
    );
    useDeprecated(
      {
        scope: "vs-tooltip",
        type: "Prop",
        from: "notHover",
        version: "0.0.2",
        replacement: "trigger",
        ref: "https://vuesax-alpha.vercel.app/components/tooltip#props"
      },
      vue.computed(() => props.notHover)
    );
    useDeprecated(
      {
        scope: "vs-tooltip",
        type: "Prop",
        from: "[border, borderThick]",
        version: "0.0.2",
        replacement: "type",
        ref: "https://vuesax-alpha.vercel.app/components/tooltip#props"
      },
      vue.computed(() => props.border || props.borderThick)
    );
    useDeprecated(
      {
        scope: "vs-tooltip",
        type: "Prop",
        from: "shadow",
        version: "0.0.2",
        replacement: "type",
        ref: "https://vuesax-alpha.vercel.app/components/tooltip#props"
      },
      vue.computed(() => props.shadow)
    );
    useDeprecated(
      {
        scope: "vs-tooltip",
        type: "Prop",
        from: "square | circle",
        version: "0.0.2",
        replacement: "shape",
        ref: "https://vuesax-alpha.vercel.app/components/tooltip#props"
      },
      vue.computed(() => props.square || props.circle)
    );
  };

  const __default__$g = vue.defineComponent({
    name: "VsTooltip"
  });
  const _sfc_main$g = vue.defineComponent({
    ...__default__$g,
    props: tooltipProps,
    setup(__props, { expose: __expose }) {
      const props = __props;
      const ns = useNamespace("tooltip");
      const popperRef = vue.ref();
      const tooltipStyle = vue.computed(() => [
        ns.cssVar({
          color: getVsColor(props.color)
        })
      ]);
      const vsBaseClasses = useVuesaxBaseComponent(useColor());
      const tooltipKls = vue.computed(() => [
        ns.b(),
        vsBaseClasses,
        ns.is("loading", props.loading),
        ns.is(props.type, !!props.type),
        ns.is(props.shape, !!props.shape),
        ns.is("not-arrow", !props.showArrow),
        ns.is(props.effect)
      ]);
      useTooltipDeprecated(props);
      __expose({ popperRef });
      return (_ctx, _cache) => {
        var _a, _b;
        return vue.openBlock(), vue.createBlock(vue.unref(VsPopper), {
          ref_key: "popperRef",
          ref: popperRef,
          interactivity: _ctx.interactivity,
          "popper-class": [tooltipKls.value, (_a = _ctx.popperClass) != null ? _a : ""],
          "popper-style": [(_b = _ctx.popperStyle) != null ? _b : "", tooltipStyle.value],
          animation: _ctx.animation,
          "append-to": _ctx.appendTo,
          flip: _ctx.flip,
          shift: _ctx.shift,
          "window-resize": _ctx.windowResize,
          "window-scroll": _ctx.windowScroll,
          disabled: _ctx.disabled,
          fit: _ctx.fit,
          loading: _ctx.loading,
          "hide-after": _ctx.hideAfter,
          offset: _ctx.offset,
          placement: _ctx.placement,
          "show-after": _ctx.showAfter,
          "show-arrow": _ctx.showArrow,
          strategy: _ctx.strategy,
          teleported: _ctx.teleported,
          trigger: _ctx.trigger,
          "trigger-class": _ctx.triggerClass,
          "trigger-style": _ctx.triggerStyle,
          "virtual-ref": _ctx.virtualRef,
          "virtual-triggering": _ctx.virtualTriggering,
          "z-index": _ctx.zIndex,
          "on-blur": _ctx.onBlur,
          "on-click": _ctx.onClick,
          "on-focus": _ctx.onFocus,
          "on-keydown": _ctx.onKeydown,
          "on-contextmenu": _ctx.onContextmenu,
          "on-mouseenter": _ctx.onMouseenter,
          "on-mouseleave": _ctx.onMouseleave
        }, {
          content: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "content")
          ]),
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["interactivity", "popper-class", "popper-style", "animation", "append-to", "flip", "shift", "window-resize", "window-scroll", "disabled", "fit", "loading", "hide-after", "offset", "placement", "show-after", "show-arrow", "strategy", "teleported", "trigger", "trigger-class", "trigger-style", "virtual-ref", "virtual-triggering", "z-index", "on-blur", "on-click", "on-focus", "on-keydown", "on-contextmenu", "on-mouseenter", "on-mouseleave"]);
      };
    }
  });
  var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__file", "tooltip.vue"]]);

  const VsTooltip = withInstall(Tooltip);

  const popconfirmProps = buildProps({
    animation: tooltipProps.animation,
    title: { type: String },
    confirmButtonText: { type: String },
    cancelButtonText: { type: String },
    confirmButtonColor: {
      ...useColorProp,
      default: "primary"
    },
    confirmButtonType: {
      type: String,
      values: buttonTypes,
      default: "flat"
    },
    confirmButtonSize: {
      type: String,
      values: buttonSizes,
      default: "small"
    },
    cancelButtonColor: {
      ...useColorProp,
      default: "text"
    },
    cancelButtonType: {
      type: String,
      values: buttonTypes,
      default: "transparent"
    },
    cancelButtonSize: {
      type: String,
      values: buttonSizes,
      default: "small"
    },
    icon: {
      type: iconPropType,
      default: () => message_question_default
    },
    iconColor: {
      type: String,
      default: "#f90"
    },
    hideIcon: {
      type: Boolean,
      default: false
    },
    hideAfter: {
      type: Number,
      default: 200
    },
    teleported: popperContentProps.teleported,
    persistent: popperContentProps.persistent,
    width: {
      type: [String, Number],
      default: 200
    }
  });
  const popconfirmEmits = {
    confirm: (e) => e instanceof MouseEvent,
    cancel: (e) => e instanceof MouseEvent
  };

  const __default__$f = vue.defineComponent({
    name: "VsPopconfirm"
  });
  const _sfc_main$f = vue.defineComponent({
    ...__default__$f,
    props: popconfirmProps,
    emits: popconfirmEmits,
    setup(__props, { emit }) {
      const props = __props;
      const { t } = useLocale();
      const ns = useNamespace("popconfirm");
      const tooltipRef = vue.ref();
      const hidePopper = () => {
        var _a;
        (_a = tooltipRef.value) == null ? void 0 : _a.hide();
      };
      const style = vue.computed(() => {
        return {
          width: addUnit(props.width)
        };
      });
      const confirm = (e) => {
        emit("confirm", e);
        hidePopper();
      };
      const cancel = (e) => {
        emit("cancel", e);
        hidePopper();
      };
      const finalConfirmButtonText = vue.computed(
        () => props.confirmButtonText || t("vs.popconfirm.confirmButtonText")
      );
      const finalCancelButtonText = vue.computed(
        () => props.cancelButtonText || t("vs.popconfirm.cancelButtonText")
      );
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(VsPopper), vue.mergeProps({
          ref_key: "tooltipRef",
          ref: tooltipRef,
          trigger: "click",
          color: "light"
        }, _ctx.$attrs, {
          animation: _ctx.animation,
          "popper-class": `${vue.unref(ns).namespace.value}-popconfirm`,
          "popper-style": style.value,
          teleported: _ctx.teleported,
          "fallback-placements": ["bottom", "top", "right", "left"],
          "hide-after": _ctx.hideAfter,
          persistent: _ctx.persistent
        }), {
          content: vue.withCtx(() => [
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("main"))
              },
              [
                !_ctx.hideIcon && _ctx.icon ? (vue.openBlock(), vue.createBlock(vue.unref(VsIcon), {
                  key: 0,
                  class: vue.normalizeClass(vue.unref(ns).e("icon")),
                  style: vue.normalizeStyle({ color: _ctx.iconColor }),
                  size: "26"
                }, {
                  default: vue.withCtx(() => [
                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.icon)))
                  ]),
                  _: 1
                }, 8, ["class", "style"])) : vue.createCommentVNode("v-if", true),
                vue.createTextVNode(
                  " " + vue.toDisplayString(_ctx.title),
                  1
                )
              ],
              2
            ),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("action"))
              },
              [
                vue.createVNode(vue.unref(VsButton), {
                  size: _ctx.cancelButtonSize,
                  color: _ctx.cancelButtonColor,
                  type: _ctx.cancelButtonType,
                  onClick: cancel
                }, {
                  default: vue.withCtx(() => [
                    vue.createTextVNode(
                      vue.toDisplayString(finalCancelButtonText.value),
                      1
                    )
                  ]),
                  _: 1
                }, 8, ["size", "color", "type"]),
                vue.createVNode(vue.unref(VsButton), {
                  size: _ctx.confirmButtonSize,
                  color: _ctx.confirmButtonColor,
                  type: _ctx.confirmButtonType,
                  onClick: confirm
                }, {
                  default: vue.withCtx(() => [
                    vue.createTextVNode(
                      vue.toDisplayString(finalConfirmButtonText.value),
                      1
                    )
                  ]),
                  _: 1
                }, 8, ["size", "color", "type"])
              ],
              2
            )
          ]),
          default: vue.withCtx(() => [
            _ctx.$slots.reference ? vue.renderSlot(_ctx.$slots, "reference", { key: 0 }) : vue.createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 16, ["animation", "popper-class", "popper-style", "teleported", "hide-after", "persistent"]);
      };
    }
  });
  var Popconfirm = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__file", "popconfirm.vue"]]);

  const VsPopconfirm = withInstall(Popconfirm);

  const radioProps = buildProps({
    color: useColorProp,
    modelValue: {
      type: [Boolean, String, Number],
      default: null
    },
    value: {
      type: [Boolean, String, Number],
      default: ""
    },
    disabled: { type: Boolean, default: false },
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    name: { type: String, default: "" },
    loading: {
      type: Boolean,
      default: false
    },
    labelBefore: {
      type: Boolean,
      default: false
    }
  });
  const radioEmits = {
    [UPDATE_MODEL_EVENT]: (val) => isString(val) || isNumber(val) || isBoolean(val),
    [CHANGE_EVENT]: (val) => isString(val) || isNumber(val) || isBoolean(val)
  };

  const useRadio = (props, emit) => {
    const model = vue.computed({
      get: () => props.modelValue,
      set: () => {
        emit(UPDATE_MODEL_EVENT, props.value);
      }
    });
    const { disabled, loading } = vue.toRefs(props);
    const isDisabled = vue.computed(() => disabled.value || loading.value);
    const checked = vue.computed(() => props.modelValue === props.value);
    const focus = vue.ref(false);
    return {
      focus,
      disabled,
      isDisabled,
      checked,
      loading,
      model
    };
  };

  const _hoisted_1$5 = ["id", "disabled", "readonly", "name"];
  const _hoisted_2$2 = ["for"];
  const __default__$e = vue.defineComponent({
    name: "VsRadio"
  });
  const _sfc_main$e = vue.defineComponent({
    ...__default__$e,
    props: radioProps,
    emits: radioEmits,
    setup(__props, { emit }) {
      const props = __props;
      const ns = useNamespace("radio");
      const uid = useId();
      const { isDisabled, loading, model, focus, checked } = useRadio(props, emit);
      const color = useColor("primary");
      const vsBaseClasses = useVuesaxBaseComponent(color);
      const radioKls = vue.computed(() => [
        vsBaseClasses,
        ns.b("wrapper"),
        ns.is("loading", loading.value),
        ns.is("disabled", isDisabled.value),
        ns.is("active", checked.value),
        ns.is("label-before", props.labelBefore)
      ]);
      const radioStyles = vue.computed(() => [
        ns.cssVar({
          color: getVsColor(color.value)
        })
      ]);
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(radioKls.value),
            style: vue.normalizeStyle(radioStyles.value)
          },
          [
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).b())
              },
              [
                vue.withDirectives(vue.createElementVNode("input", {
                  id: vue.unref(uid),
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.isRef(model) ? model.value = $event : null),
                  type: "radio",
                  disabled: vue.unref(isDisabled),
                  readonly: vue.unref(isDisabled),
                  name: _ctx.name,
                  onFocus: _cache[1] || (_cache[1] = ($event) => focus.value = true),
                  onBlur: _cache[2] || (_cache[2] = ($event) => focus.value = false)
                }, null, 40, _hoisted_1$5), [
                  [vue.vModelRadio, vue.unref(model)]
                ]),
                vue.createElementVNode(
                  "span",
                  {
                    class: vue.normalizeClass(vue.unref(ns).e("effect"))
                  },
                  [
                    _ctx.$slots.icon ? (vue.openBlock(), vue.createElementBlock(
                      "span",
                      {
                        key: 0,
                        class: vue.normalizeClass(vue.unref(ns).em("effect", "icon"))
                      },
                      [
                        vue.renderSlot(_ctx.$slots, "icon")
                      ],
                      2
                    )) : vue.createCommentVNode("v-if", true),
                    vue.unref(loading) ? (vue.openBlock(), vue.createElementBlock(
                      "span",
                      {
                        key: 1,
                        class: vue.normalizeClass(vue.unref(ns).em("effect", "loading"))
                      },
                      [
                        vue.createVNode(vue.unref(IconLoading))
                      ],
                      2
                    )) : vue.createCommentVNode("v-if", true)
                  ],
                  2
                )
              ],
              2
            ),
            _ctx.$slots.default || _ctx.label ? (vue.openBlock(), vue.createElementBlock("label", {
              key: 0,
              for: vue.unref(uid),
              class: vue.normalizeClass(vue.unref(ns).e("label"))
            }, [
              vue.renderSlot(_ctx.$slots, "default", {}, () => [
                vue.createTextVNode(
                  vue.toDisplayString(_ctx.label),
                  1
                )
              ])
            ], 10, _hoisted_2$2)) : vue.createCommentVNode("v-if", true)
          ],
          6
        );
      };
    }
  });
  var Radio = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__file", "radio.vue"]]);

  const VsRadio = withInstall(Radio);

  const rateProps = buildProps({
    modelValue: {
      type: Number,
      default: 0
    },
    id: {
      type: String,
      default: void 0
    },
    lowThreshold: {
      type: Number,
      default: 2
    },
    highThreshold: {
      type: Number,
      default: 4
    },
    max: {
      type: Number,
      default: 5
    },
    colors: {
      type: definePropType([Array, Object]),
      default: () => mutable(["", "", ""])
    },
    voidColor: {
      type: String,
      default: ""
    },
    disabledVoidColor: {
      type: String,
      default: ""
    },
    icons: {
      type: definePropType([Array, Object]),
      default: () => [star_bold_default, star_bold_default, star_bold_default]
    },
    voidIcon: {
      type: iconPropType,
      default: () => star_default
    },
    disabledVoidIcon: {
      type: iconPropType,
      default: () => star_bold_default
    },
    disabled: {
      type: Boolean
    },
    allowHalf: {
      type: Boolean
    },
    showText: {
      type: Boolean
    },
    showScore: {
      type: Boolean
    },
    textColor: {
      type: String,
      default: ""
    },
    texts: {
      type: definePropType(Array),
      default: () => mutable([
        "Extremely bad",
        "Disappointed",
        "Fair",
        "Satisfied",
        "Surprise"
      ])
    },
    scoreTemplate: {
      type: String,
      default: "{value}"
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    label: {
      type: String,
      default: void 0
    },
    clearable: {
      type: Boolean,
      default: false
    }
  });
  const rateEmits = {
    [CHANGE_EVENT]: (value) => isNumber(value),
    [UPDATE_MODEL_EVENT]: (value) => isNumber(value)
  };

  const _hoisted_1$4 = ["aria-label", "aria-valuenow", "aria-valuetext", "aria-valuemax"];
  const _hoisted_2$1 = ["onMousemove", "onClick"];
  const __default__$d = vue.defineComponent({
    name: "VsRate"
  });
  const _sfc_main$d = vue.defineComponent({
    ...__default__$d,
    props: rateProps,
    emits: rateEmits,
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      function getValueFromMap(value, map) {
        const isExcludedObject = (val) => isObject(val);
        const matchedKeys = Object.keys(map).map((key) => +key).filter((key) => {
          const val = map[key];
          const excluded = isExcludedObject(val) ? val.excluded : false;
          return excluded ? value < key : value <= key;
        }).sort((a, b) => a - b);
        const matchedValue = map[matchedKeys[0]];
        return isExcludedObject(matchedValue) && matchedValue.value || matchedValue;
      }
      const rateSize = useSize();
      const ns = useNamespace("rate");
      const currentValue = vue.ref(props.modelValue);
      const hoverIndex = vue.ref(-1);
      const pointerAtLeftHalf = vue.ref(true);
      const rateClasses = vue.computed(() => [ns.b(), ns.m(rateSize.value)]);
      const rateDisabled = vue.computed(() => props.disabled);
      const rateStyles = vue.computed(() => {
        return ns.cssVarBlock({
          "void-color": props.voidColor,
          "disabled-void-color": props.disabledVoidColor,
          "fill-color": activeColor.value
        });
      });
      const text = vue.computed(() => {
        let result = "";
        if (props.showScore) {
          result = props.scoreTemplate.replace(
            /\{\s*value\s*\}/,
            rateDisabled.value ? `${props.modelValue}` : `${currentValue.value}`
          );
        } else if (props.showText) {
          result = props.texts[Math.ceil(currentValue.value) - 1];
        }
        return result;
      });
      const valueDecimal = vue.computed(
        () => props.modelValue * 100 - Math.floor(props.modelValue) * 100
      );
      const colorMap = vue.computed(
        () => isArray(props.colors) ? {
          [props.lowThreshold]: props.colors[0],
          [props.highThreshold]: { value: props.colors[1], excluded: true },
          [props.max]: props.colors[2]
        } : props.colors
      );
      const activeColor = vue.computed(() => {
        const color = getValueFromMap(currentValue.value, colorMap.value);
        return isObject(color) ? "" : color;
      });
      const decimalStyle = vue.computed(() => {
        let width = "";
        if (rateDisabled.value) {
          width = `${valueDecimal.value}%`;
        } else if (props.allowHalf) {
          width = "50%";
        }
        return {
          color: activeColor.value,
          width
        };
      });
      const componentMap = vue.computed(() => {
        let icons = isArray(props.icons) ? [...props.icons] : { ...props.icons };
        icons = vue.markRaw(icons);
        return isArray(icons) ? {
          [props.lowThreshold]: icons[0],
          [props.highThreshold]: {
            value: icons[1],
            excluded: true
          },
          [props.max]: icons[2]
        } : icons;
      });
      const decimalIconComponent = vue.computed(
        () => getValueFromMap(props.modelValue, componentMap.value)
      );
      const voidComponent = vue.computed(
        () => rateDisabled.value ? isString(props.disabledVoidIcon) ? props.disabledVoidIcon : vue.markRaw(props.disabledVoidIcon) : isString(props.voidIcon) ? props.voidIcon : vue.markRaw(props.voidIcon)
      );
      const activeComponent = vue.computed(
        () => getValueFromMap(currentValue.value, componentMap.value)
      );
      function showDecimalIcon(item) {
        const showWhenDisabled = rateDisabled.value && valueDecimal.value > 0 && item - 1 < props.modelValue && item > props.modelValue;
        const showWhenAllowHalf = props.allowHalf && pointerAtLeftHalf.value && item - 0.5 <= currentValue.value && item > currentValue.value;
        return showWhenDisabled || showWhenAllowHalf;
      }
      function emitValue(value) {
        if (props.clearable && value === props.modelValue) {
          value = 0;
        }
        emit(UPDATE_MODEL_EVENT, value);
        if (props.modelValue !== value) {
          emit("change", value);
        }
      }
      function selectValue(value) {
        if (rateDisabled.value) {
          return;
        }
        if (props.allowHalf && pointerAtLeftHalf.value) {
          emitValue(currentValue.value);
        } else {
          emitValue(value);
        }
      }
      function handleKey(e) {
        if (rateDisabled.value) {
          return;
        }
        let _currentValue = currentValue.value;
        const code = e.code;
        if (code === EVENT_CODE.up || code === EVENT_CODE.right) {
          if (props.allowHalf) {
            _currentValue += 0.5;
          } else {
            _currentValue += 1;
          }
          e.stopPropagation();
          e.preventDefault();
        } else if (code === EVENT_CODE.left || code === EVENT_CODE.down) {
          if (props.allowHalf) {
            _currentValue -= 0.5;
          } else {
            _currentValue -= 1;
          }
          e.stopPropagation();
          e.preventDefault();
        }
        _currentValue = _currentValue < 0 ? 0 : _currentValue;
        _currentValue = _currentValue > props.max ? props.max : _currentValue;
        emit(UPDATE_MODEL_EVENT, _currentValue);
        emit("change", _currentValue);
        return _currentValue;
      }
      function setCurrentValue(value, event) {
        if (rateDisabled.value) {
          return;
        }
        if (props.allowHalf) {
          let target = event.target;
          if (hasClass(target, ns.e("item"))) {
            target = target.querySelector(`.${ns.e("icon")}`);
          }
          if (target.clientWidth === 0 || hasClass(target, ns.e("decimal"))) {
            target = target.parentNode;
          }
          pointerAtLeftHalf.value = event.offsetX * 2 <= target.clientWidth;
          currentValue.value = pointerAtLeftHalf.value ? value - 0.5 : value;
        } else {
          currentValue.value = value;
        }
        hoverIndex.value = value;
      }
      function resetCurrentValue() {
        if (rateDisabled.value) {
          return;
        }
        if (props.allowHalf) {
          pointerAtLeftHalf.value = props.modelValue !== Math.floor(props.modelValue);
        }
        currentValue.value = props.modelValue;
        hoverIndex.value = -1;
      }
      vue.watch(
        () => props.modelValue,
        (val) => {
          currentValue.value = val;
          pointerAtLeftHalf.value = props.modelValue !== Math.floor(props.modelValue);
        }
      );
      if (!props.modelValue) {
        emit(UPDATE_MODEL_EVENT, 0);
      }
      __expose({
        setCurrentValue,
        resetCurrentValue
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("div", {
          class: vue.normalizeClass([rateClasses.value, vue.unref(ns).is("disabled", rateDisabled.value)]),
          role: "slider",
          "aria-label": _ctx.label || "rating",
          "aria-valuenow": currentValue.value,
          "aria-valuetext": text.value || void 0,
          "aria-valuemin": "0",
          "aria-valuemax": _ctx.max,
          tabindex: "0",
          style: vue.normalizeStyle(rateStyles.value),
          onKeydown: handleKey
        }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.max, (item, key) => {
              return vue.openBlock(), vue.createElementBlock("span", {
                key,
                class: vue.normalizeClass(vue.unref(ns).e("item")),
                onMousemove: ($event) => setCurrentValue(item, $event),
                onMouseleave: resetCurrentValue,
                onClick: ($event) => selectValue(item)
              }, [
                vue.createVNode(vue.unref(VsIcon), {
                  class: vue.normalizeClass([
                    vue.unref(ns).e("icon"),
                    { hover: hoverIndex.value === item },
                    vue.unref(ns).is("active", item <= currentValue.value)
                  ])
                }, {
                  default: vue.withCtx(() => [
                    !showDecimalIcon(item) ? (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 0 },
                      [
                        vue.withDirectives((vue.openBlock(), vue.createBlock(
                          vue.resolveDynamicComponent(activeComponent.value),
                          null,
                          null,
                          512
                        )), [
                          [vue.vShow, item <= currentValue.value]
                        ]),
                        vue.withDirectives((vue.openBlock(), vue.createBlock(
                          vue.resolveDynamicComponent(voidComponent.value),
                          null,
                          null,
                          512
                        )), [
                          [vue.vShow, !(item <= currentValue.value)]
                        ])
                      ],
                      64
                    )) : vue.createCommentVNode("v-if", true),
                    showDecimalIcon(item) ? (vue.openBlock(), vue.createBlock(vue.unref(VsIcon), {
                      key: 1,
                      style: vue.normalizeStyle(decimalStyle.value),
                      class: vue.normalizeClass([vue.unref(ns).e("icon"), vue.unref(ns).e("decimal")])
                    }, {
                      default: vue.withCtx(() => [
                        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(decimalIconComponent.value)))
                      ]),
                      _: 1
                    }, 8, ["style", "class"])) : vue.createCommentVNode("v-if", true)
                  ]),
                  _: 2
                }, 1032, ["class"])
              ], 42, _hoisted_2$1);
            }),
            128
          )),
          _ctx.showText || _ctx.showScore ? (vue.openBlock(), vue.createElementBlock(
            "span",
            {
              key: 0,
              class: vue.normalizeClass(vue.unref(ns).e("text"))
            },
            vue.toDisplayString(text.value),
            3
          )) : vue.createCommentVNode("v-if", true)
        ], 46, _hoisted_1$4);
      };
    }
  });
  var Rate = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__file", "rate.vue"]]);

  const VsRate = withInstall(Rate);

  const RowJustify = [
    "start",
    "center",
    "end",
    "space-around",
    "space-between",
    "space-evenly"
  ];
  const RowAlign = ["top", "middle", "bottom"];
  const RowDerection = [
    "row",
    "row-reverse",
    "column",
    "column-reverse"
  ];
  const rowProps = buildProps({
    gutter: {
      type: Number,
      default: 0
    },
    justify: {
      type: String,
      values: RowJustify,
      default: "start"
    },
    direction: {
      type: String,
      values: RowDerection,
      default: "row"
    },
    align: {
      type: String,
      values: RowAlign,
      default: "top"
    }
  });

  const __default__$c = vue.defineComponent({
    name: "VsRow"
  });
  const _sfc_main$c = vue.defineComponent({
    ...__default__$c,
    props: rowProps,
    setup(__props) {
      const props = __props;
      const ns = useNamespace("row");
      const gutter = vue.computed(() => props.gutter);
      vue.provide(rowContextKey, {
        gutter
      });
      const style = vue.computed(() => {
        const styles = {};
        if (!props.gutter) {
          return styles;
        }
        styles.marginRight = styles.marginLeft = `-${props.gutter / 2}px`;
        return styles;
      });
      const rowKls = vue.computed(() => [
        ns.b(),
        ns.is(`justify-${props.justify}`, props.justify !== "start"),
        ns.is(`align-${props.align}`, props.align !== "top"),
        ns.is(`direction-${props.direction}`, props.direction !== "row")
      ]);
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(rowKls.value),
            style: vue.normalizeStyle(style.value)
          },
          [
            vue.renderSlot(_ctx.$slots, "default")
          ],
          6
        );
      };
    }
  });
  var Row = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__file", "row.vue"]]);

  const VsRow = withInstall(Row);

  const sidebarGroupProps = buildProps({
    open: { type: Boolean, default: false }
  });

  const __default__$b = vue.defineComponent({
    name: "VsSidebarGroup"
  });
  const _sfc_main$b = vue.defineComponent({
    ...__default__$b,
    props: sidebarGroupProps,
    setup(__props) {
      const props = __props;
      const ns = useNamespace("sidebar-group");
      const groupRef = vue.ref();
      const contentRef = vue.ref();
      const openState = vue.ref(false);
      const onClickHeader = () => {
        openState.value = !openState.value;
      };
      vue.watch(
        () => props.open,
        (val) => {
          vue.nextTick(() => {
            if (!contentRef.value)
              return;
            const h = contentRef.value.scrollHeight || 0;
            const content = contentRef.value;
            if (val) {
              content.style.height = `${content.scrollHeight + h - 1}px`;
            } else {
              content.style.height = `${content.scrollHeight - h + 1}px`;
            }
          });
        }
      );
      vue.onMounted(() => {
        if (props.open) {
          openState.value = true;
        }
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            ref_key: "groupRef",
            ref: groupRef,
            class: vue.normalizeClass([vue.unref(ns).b(), vue.unref(ns).is("open", openState.value)])
          },
          [
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("header")),
                onClick: onClickHeader
              },
              [
                vue.renderSlot(_ctx.$slots, "header")
              ],
              2
            ),
            vue.createVNode(vue.unref(_CollapseTransition), null, {
              default: vue.withCtx(() => [
                vue.withDirectives(vue.createElementVNode(
                  "div",
                  {
                    ref_key: "contentRef",
                    ref: contentRef,
                    class: vue.normalizeClass(vue.unref(ns).e("content"))
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "default")
                  ],
                  2
                ), [
                  [vue.vShow, openState.value]
                ])
              ]),
              _: 3
            })
          ],
          2
        );
      };
    }
  });
  var SidebarGroup = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__file", "sidebar-group.vue"]]);

  const sidebarItemProps = buildProps({
    to: { type: String },
    href: { type: String },
    target: {
      type: String,
      default: "_blank"
    },
    id: { type: String },
    arrow: { type: Boolean },
    active: { type: Boolean }
  });

  const __default__$a = vue.defineComponent({
    name: "VsSidebarItem"
  });
  const _sfc_main$a = vue.defineComponent({
    ...__default__$a,
    props: sidebarItemProps,
    setup(__props) {
      const props = __props;
      const slots = vue.useSlots();
      const ns = useNamespace("sidebar-item");
      const sidebar = vue.inject(sidebarContextKey);
      if (!sidebar) {
        throwError("sidebar-item", "need to call inside the sidebar component");
      }
      const handleClickItem = (router) => {
        if (props.id) {
          sidebar.handleClickItem(props.id);
        }
        if (props.to) {
          router.push(props.to);
        } else if (props.href) {
          window.open(props.href, props.target);
        }
      };
      const itemKls = vue.computed(() => [
        ns.b(),
        ns.is("active", props.active || sidebar.modelValue.value == props.id),
        ns.is("has-icon", Boolean(slots.icon))
      ]);
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "button",
          {
            class: vue.normalizeClass(itemKls.value),
            onClick: _cache[0] || (_cache[0] = ($event) => handleClickItem(_ctx.$router))
          },
          [
            _ctx.$slots.icon ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).e("icon"))
              },
              [
                vue.renderSlot(_ctx.$slots, "icon")
              ],
              2
            )) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("text"))
              },
              [
                vue.renderSlot(_ctx.$slots, "default")
              ],
              2
            ),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("text-tooltip"))
              },
              [
                vue.renderSlot(_ctx.$slots, "default")
              ],
              2
            ),
            _ctx.$slots.arrow ? vue.renderSlot(_ctx.$slots, "arrow", { key: 1 }) : _ctx.arrow ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 2,
                class: vue.normalizeClass(vue.unref(ns).e("arrow"))
              },
              [
                vue.createVNode(vue.unref(IconArrow))
              ],
              2
            )) : vue.createCommentVNode("v-if", true)
          ],
          2
        );
      };
    }
  });
  var SidebarItem = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__file", "sidebar-item.vue"]]);

  const sidebarProps = buildProps({
    color: useColorProp,
    background: useColorProp,
    modelValue: {
      type: String,
      default: null
    },
    reduce: {
      type: Boolean,
      default: false
    },
    hoverExpand: {
      type: Boolean,
      default: false
    },
    open: {
      type: Boolean,
      default: false
    },
    notLineActive: {
      type: Boolean,
      default: false
    },
    shape: {
      type: String,
      values: ["square"],
      default: ""
    },
    textWhite: {
      type: Boolean,
      default: false
    },
    notShadow: {
      type: Boolean,
      default: false
    },
    absolute: { type: Boolean },
    right: {
      type: Boolean,
      default: false
    }
  });
  const sidebarEmits = {
    [UPDATE_MODEL_EVENT]: (val) => isString(val),
    "update:open": (val) => isBoolean(val)
  };

  const __default__$9 = vue.defineComponent({
    name: "VsSidebar"
  });
  const _sfc_main$9 = vue.defineComponent({
    ...__default__$9,
    props: sidebarProps,
    emits: sidebarEmits,
    setup(__props, { emit }) {
      const props = __props;
      const ns = useNamespace("sidebar");
      const color = useColor("primary");
      const sidebarRef = vue.ref();
      const staticWidth = vue.ref(260);
      const reduceInternal = vue.ref(false);
      const vsBaseClasses = useVuesaxBaseComponent(color);
      const sidebarKls = vue.computed(() => [
        ns.b(),
        vsBaseClasses,
        ns.is("reduce", reduceInternal.value),
        ns.is("open", props.open),
        ns.is("not-line-active", props.notLineActive),
        ns.is("not-shadow", props.notShadow),
        ns.is("text-white", props.textWhite),
        ns.is("absolute", props.absolute),
        ns.is(props.shape, !!props.shape),
        ns.is("right", props.right)
      ]);
      const sidebarStyles = vue.computed(() => [
        ns.cssVar({
          color: getVsColor(color.value)
        })
      ]);
      const mouseEnterSidebar = () => {
        if (props.hoverExpand) {
          reduceInternal.value = false;
        }
      };
      const mouseLeaveSidebar = () => {
        if (props.hoverExpand) {
          reduceInternal.value = true;
        }
      };
      const clickCloseSidebar = () => {
        emit("update:open", false);
      };
      const handleClickItem = (id) => {
        emit("update:modelValue", id);
        clickCloseSidebar();
      };
      vue.watch(
        () => props.reduce,
        (val) => {
          const wrapper = sidebarRef.value;
          if (!wrapper)
            return;
          reduceInternal.value = val;
          if (val) {
            wrapper.style.width = "50px";
          } else {
            wrapper.style.width = `${staticWidth.value}px`;
          }
        }
      );
      vue.watch(reduceInternal, (val) => {
        const wrapper = sidebarRef.value;
        if (!wrapper)
          return;
        if (val) {
          wrapper.style.width = "50px";
        } else {
          wrapper.style.width = `${staticWidth.value}px`;
        }
      });
      vue.watch(
        () => props.background,
        () => {
          setColor(
            "background",
            props.background || "",
            sidebarRef.value,
            true,
            ns.namespace.value
          );
        }
      );
      vue.provide(sidebarContextKey, {
        modelValue: vue.computed(() => props.modelValue),
        reduce: vue.computed(() => props.reduce),
        handleClickItem
      });
      vue.onMounted(() => {
        staticWidth.value = sidebarRef.value.offsetWidth;
        reduceInternal.value = props.reduce;
        setColor(
          "background",
          props.background || "",
          sidebarRef.value,
          true,
          ns.namespace.value
        );
        if (props.textWhite) {
          setColor("text", "#fff", sidebarRef.value, true, ns.namespace.value);
        }
      });
      return (_ctx, _cache) => {
        return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
          "div",
          {
            ref_key: "sidebarRef",
            ref: sidebarRef,
            class: vue.normalizeClass(sidebarKls.value),
            style: vue.normalizeStyle(sidebarStyles.value),
            onMouseenter: mouseEnterSidebar,
            onMouseleave: mouseLeaveSidebar
          },
          [
            _ctx.$slots.logo ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).e("logo"))
              },
              [
                vue.renderSlot(_ctx.$slots, "logo")
              ],
              2
            )) : vue.createCommentVNode("v-if", true),
            _ctx.$slots.header ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 1,
                class: vue.normalizeClass(vue.unref(ns).e("header"))
              },
              [
                vue.renderSlot(_ctx.$slots, "header")
              ],
              2
            )) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("body"))
              },
              [
                vue.renderSlot(_ctx.$slots, "default")
              ],
              2
            ),
            _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 2,
                class: vue.normalizeClass(vue.unref(ns).e("footer"))
              },
              [
                vue.renderSlot(_ctx.$slots, "footer")
              ],
              2
            )) : vue.createCommentVNode("v-if", true)
          ],
          38
        )), [
          [vue.unref(ClickOutside), clickCloseSidebar]
        ]);
      };
    }
  });
  var Sidebar = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__file", "sidebar.vue"]]);

  const VsSidebar = withInstall(Sidebar, {
    SidebarGroup,
    SidebarItem
  });
  const VsSidebarGroup = withNoopInstall(SidebarGroup);
  const VsSidebarItem = withNoopInstall(SidebarItem);

  const switchProps = buildProps({
    color: useColorProp,
    modelValue: {
      type: [Boolean, String, Number],
      default: false
    },
    activeValue: {
      type: [Boolean, String, Number],
      default: true
    },
    inactiveValue: {
      type: [Boolean, String, Number],
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    shape: {
      type: String,
      values: ["square"],
      default: null
    },
    indeterminate: {
      type: Boolean,
      default: false
    },
    icon: {
      type: Boolean,
      default: false
    }
  });
  const switchEmits = {
    [UPDATE_MODEL_EVENT]: (val) => isBoolean(val) || isString(val) || isNumber(val),
    [CHANGE_EVENT]: (val) => isBoolean(val) || isString(val) || isNumber(val),
    [INPUT_EVENT]: (val) => isBoolean(val) || isString(val) || isNumber(val)
  };

  const useSwitch = (props, emit) => {
    const checked = vue.computed(() => props.modelValue === props.activeValue);
    const isLoading = vue.computed(() => props.loading);
    const isDisabled = vue.computed(() => props.disabled || isLoading.value);
    if (![props.activeValue, props.inactiveValue].includes(props.modelValue)) {
      emit(UPDATE_MODEL_EVENT, props.inactiveValue);
      emit(CHANGE_EVENT, props.inactiveValue);
      emit(INPUT_EVENT, props.inactiveValue);
    }
    const handleChange = () => {
      const val = checked.value ? props.inactiveValue : props.activeValue;
      emit(UPDATE_MODEL_EVENT, val);
      emit(CHANGE_EVENT, val);
      emit(INPUT_EVENT, val);
    };
    const switchValue = () => {
      if (isDisabled.value)
        return;
      handleChange();
    };
    return {
      checked,
      isDisabled,
      isLoading,
      handleChange,
      switchValue
    };
  };

  const _hoisted_1$3 = ["checked", "disabled", "readonly"];
  const __default__$8 = vue.defineComponent({
    name: "VsSwitch",
    inheritAttrs: false
  });
  const _sfc_main$8 = vue.defineComponent({
    ...__default__$8,
    props: switchProps,
    emits: switchEmits,
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const ns = useNamespace("switch");
      const color = useColor("primary");
      const { isLoading, checked, isDisabled, handleChange, switchValue } = useSwitch(
        props,
        emit
      );
      const vsBaseClasses = useVuesaxBaseComponent(color);
      const switchKls = vue.computed(() => [
        vsBaseClasses,
        ns.b(),
        ns.is("loading", isLoading.value),
        ns.is(props.shape),
        ns.is("indeterminate", props.indeterminate),
        ns.is("icon", props.icon),
        ns.is("disabled", isDisabled.value)
      ]);
      const switchStyles = vue.computed(() => [
        ns.cssVar({
          color: getVsColor(color.value)
        })
      ]);
      __expose({
        checked
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            type: "checkbox",
            class: vue.normalizeClass(switchKls.value),
            style: vue.normalizeStyle(switchStyles.value),
            onClick: _cache[1] || (_cache[1] = (...args) => vue.unref(switchValue) && vue.unref(switchValue)(...args))
          },
          [
            vue.createElementVNode("input", {
              type: "checkbox",
              checked: vue.unref(checked),
              disabled: vue.unref(isDisabled),
              readonly: vue.unref(isDisabled),
              class: vue.normalizeClass(vue.unref(ns).e("input")),
              onChange: _cache[0] || (_cache[0] = (...args) => vue.unref(handleChange) && vue.unref(handleChange)(...args))
            }, null, 42, _hoisted_1$3),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("circle"))
              },
              [
                vue.renderSlot(_ctx.$slots, "circle"),
                vue.unref(isLoading) ? (vue.openBlock(), vue.createBlock(vue.unref(IconLoading), { key: 0 })) : vue.createCommentVNode("v-if", true)
              ],
              2
            ),
            _ctx.$slots.on || _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass([vue.unref(ns).e("text"), vue.unref(ns).is("on")])
              },
              [
                _ctx.$slots.on ? vue.renderSlot(_ctx.$slots, "on", { key: 0 }) : _ctx.$slots.default ? vue.renderSlot(_ctx.$slots, "default", { key: 1 }) : vue.createCommentVNode("v-if", true)
              ],
              2
            )) : vue.createCommentVNode("v-if", true),
            _ctx.$slots.off || _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 1,
                class: vue.normalizeClass([vue.unref(ns).e("text"), vue.unref(ns).is("off")])
              },
              [
                _ctx.$slots.off ? vue.renderSlot(_ctx.$slots, "off", { key: 0 }) : _ctx.$slots.default ? vue.renderSlot(_ctx.$slots, "default", { key: 1 }) : vue.createCommentVNode("v-if", true)
              ],
              2
            )) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("background"))
              },
              null,
              2
            )
          ],
          6
        );
      };
    }
  });
  var Switch = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__file", "switch.vue"]]);

  const VsSwitch = withInstall(Switch);

  const tableProps = buildProps({
    modelValue: {
      type: definePropType([
        Array,
        String,
        Number,
        Object
      ]),
      default: null
    },
    striped: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    multiple: { type: Boolean, default: false }
  });
  const tableEmits = {
    [UPDATE_MODEL_EVENT]: (value) => isArray(value) || isString(value) || isNumber(value) || isObject(value)
  };

  const useTable = (props, emit) => {
    const ns = useNamespace("table");
    const colspan = vue.ref(0);
    const theadRef = vue.ref();
    const isMultipleSelected = vue.computed(
      () => props.multiple && isArray(props.modelValue)
    );
    const tableKls = vue.computed(() => [
      ns.b(),
      ns.is("striped", props.striped),
      ns.is("multiple", props.multiple)
    ]);
    const selectedMultiple = (val) => {
      const newVal = props.modelValue;
      if (props.modelValue.includes(val)) {
        newVal.splice(props.modelValue.indexOf(val), 1);
      } else {
        newVal.push(val);
      }
      emit(UPDATE_MODEL_EVENT, newVal);
    };
    const selected = (val) => {
      if (isMultipleSelected.value) {
        selectedMultiple(val);
      } else {
        emit(UPDATE_MODEL_EVENT, val);
      }
    };
    vue.onMounted(() => {
      var _a;
      if (props.multiple) {
        if (!isArray(props.modelValue)) {
          const value = props.modelValue ? [props.modelValue] : [];
          emit(UPDATE_MODEL_EVENT, [...value]);
        }
      }
      const tds = (_a = theadRef.value) == null ? void 0 : _a.querySelectorAll("th");
      colspan.value = (tds == null ? void 0 : tds.length) || 0;
    });
    return {
      tableKls,
      colspan,
      isMultipleSelected,
      selected,
      theadRef
    };
  };

  const _hoisted_1$2 = ["colspan"];
  const __default__$7 = vue.defineComponent({
    name: "VsTable"
  });
  const _sfc_main$7 = vue.defineComponent({
    ...__default__$7,
    props: tableProps,
    emits: tableEmits,
    setup(__props, { emit }) {
      const props = __props;
      const ns = useNamespace("table");
      const { t } = useLocale();
      const { tableKls, colspan, selected, theadRef } = useTable(props, emit);
      vue.provide(tableContextKey, {
        selected,
        colspan,
        multiple: vue.computed(() => props.multiple),
        modelValue: vue.computed(() => props.modelValue)
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(vue.unref(ns).b("wrapper"))
          },
          [
            _ctx.$slots.header ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).be("wrapper", "header"))
              },
              [
                vue.renderSlot(_ctx.$slots, "header")
              ],
              2
            )) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(tableKls))
              },
              [
                vue.createElementVNode("table", null, [
                  vue.createElementVNode(
                    "thead",
                    {
                      ref_key: "theadRef",
                      ref: theadRef,
                      class: vue.normalizeClass(vue.unref(ns).e("thead"))
                    },
                    [
                      vue.renderSlot(_ctx.$slots, "thead")
                    ],
                    2
                  ),
                  vue.createElementVNode(
                    "tbody",
                    {
                      class: vue.normalizeClass(vue.unref(ns).e("tbody"))
                    },
                    [
                      vue.renderSlot(_ctx.$slots, "tbody")
                    ],
                    2
                  ),
                  vue.createElementVNode(
                    "tbody",
                    {
                      class: vue.normalizeClass(vue.unref(ns).e("not-found"))
                    },
                    [
                      vue.createElementVNode("tr", null, [
                        vue.createElementVNode("td", { colspan: vue.unref(colspan) }, [
                          vue.renderSlot(_ctx.$slots, "notFound", {}, () => [
                            vue.createTextVNode(
                              vue.toDisplayString(vue.unref(t)("vs.table.noMatch")),
                              1
                            )
                          ])
                        ], 8, _hoisted_1$2)
                      ])
                    ],
                    2
                  )
                ])
              ],
              2
            ),
            _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 1,
                class: vue.normalizeClass(vue.unref(ns).e("footer"))
              },
              [
                vue.renderSlot(_ctx.$slots, "footer")
              ],
              2
            )) : vue.createCommentVNode("v-if", true)
          ],
          2
        );
      };
    }
  });
  var Table = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__file", "table.vue"]]);

  const tableTdProps = buildProps({
    checkbox: { type: Boolean },
    edit: { type: Boolean }
  });
  const tableTdEmits = {
    click: (event) => event instanceof Event
  };

  const __default__$6 = vue.defineComponent({
    name: "VsTd"
  });
  const _sfc_main$6 = vue.defineComponent({
    ...__default__$6,
    props: tableTdProps,
    emits: tableTdEmits,
    setup(__props, { emit }) {
      const props = __props;
      const ns = useNamespace("table");
      const tdKls = vue.computed(() => [
        ns.b("td"),
        ns.is("has-checkbox", props.checkbox),
        ns.is("edit", props.edit)
      ]);
      const onClick = (e) => {
        emit("click", e);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "td",
          {
            class: vue.normalizeClass(tdKls.value),
            onClick
          },
          [
            vue.renderSlot(_ctx.$slots, "default")
          ],
          2
        );
      };
    }
  });
  var Td = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__file", "td.vue"]]);

  const tableThProps = buildProps({
    sort: { type: Boolean }
  });

  const __default__$5 = vue.defineComponent({
    name: "VsTh"
  });
  const _sfc_main$5 = vue.defineComponent({
    ...__default__$5,
    props: tableThProps,
    setup(__props) {
      const props = __props;
      const ns = useNamespace("table");
      const thRef = vue.ref();
      const thKls = vue.computed(() => [ns.b("th"), ns.is("sort", props.sort)]);
      vue.onMounted(() => {
        thRef.value.style.width = `${thRef.value.scrollWidth}px`;
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "th",
          {
            ref_key: "thRef",
            ref: thRef,
            class: vue.normalizeClass(thKls.value)
          },
          [
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).be("th", "content"))
              },
              [
                vue.renderSlot(_ctx.$slots, "default"),
                _ctx.sort ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 0,
                    class: vue.normalizeClass(vue.unref(ns).be("th", "icons"))
                  },
                  [
                    vue.createVNode(vue.unref(IconArrow), { class: "icon-sort-1" }),
                    vue.createVNode(vue.unref(IconArrow), { class: "icon-sort-2" })
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true)
              ],
              2
            )
          ],
          2
        );
      };
    }
  });
  var Th = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__file", "th.vue"]]);

  const tableTrProps = buildProps({
    color: useColorProp,
    data: {
      type: definePropType([String, Number, Object]),
      default: null
    },
    isSelected: {
      type: Boolean,
      default: null
    },
    notClickSelected: { type: Boolean },
    openExpandOnlyTd: { type: Boolean }
  });
  const tableTrEmits = {
    click: (event) => event instanceof Event,
    selected: (value) => isString(value) || isNumber(value) || isObject(value)
  };

  const _hoisted_1$1 = ["colspan"];
  const __default__$4 = vue.defineComponent({
    name: "VsTr"
  });
  const _sfc_main$4 = vue.defineComponent({
    ...__default__$4,
    props: tableTrProps,
    emits: tableTrEmits,
    setup(__props, { emit }) {
      const props = __props;
      const ns = useNamespace("table");
      const slots = vue.useSlots();
      const table = vue.inject(tableContextKey);
      if (!table) {
        throwError("vs-tr", "component must be called inside table component");
      }
      const trRef = vue.ref();
      const contentExpandRef = vue.ref();
      const expand = vue.ref(false);
      const isSelected = vue.computed(() => {
        if (props.isSelected != null)
          return props.isSelected;
        const modelValue = isArray(table.modelValue.value) ? table.modelValue.value : [table.modelValue.value];
        return modelValue.some((e) => isEqual(e, props.data));
      });
      const vsBaseClasses = useVuesaxBaseComponent(useColor());
      const trKls = vue.computed(() => [
        vsBaseClasses,
        ns.b("tr"),
        ns.is("selected", isSelected.value),
        ns.is("expand", expand.value),
        ns.is("has-expand-slot", !!slots.expand)
      ]);
      const trStyles = vue.computed(() => [
        ns.cssVar({
          color: getVsColor(props.color)
        })
      ]);
      const click = (evs) => {
        if (slots.expand) {
          if (!evs.target.className.includes(ns.is("edit"))) {
            expand.value = !expand.value;
          }
        }
        if (evs.target.nodeName == "TD" && !props.notClickSelected) {
          table.selected(props.data);
          emit("selected", props.data);
        }
        emit("click", evs);
      };
      vue.watch(expand, (val) => {
        if (val) {
          vue.nextTick(() => {
            const content = contentExpandRef.value;
            if (!content)
              return;
            content.style.height = `${content.scrollHeight}px`;
          });
        }
      });
      vue.watch(
        () => props.data,
        () => {
          var _a;
          (_a = trRef.value) == null ? void 0 : _a.style.removeProperty(ns.cssVarName("color"));
          expand.value = false;
        }
      );
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          null,
          [
            vue.createElementVNode(
              "tr",
              {
                ref_key: "trRef",
                ref: trRef,
                class: vue.normalizeClass(trKls.value),
                style: vue.normalizeStyle(trStyles.value),
                onClick: click
              },
              [
                vue.renderSlot(_ctx.$slots, "default")
              ],
              6
            ),
            _ctx.$slots.expand ? (vue.openBlock(), vue.createBlock(vue.Transition, {
              key: 0,
              name: "fade-expand"
            }, {
              default: vue.withCtx(() => [
                expand.value ? (vue.openBlock(), vue.createElementBlock(
                  "tr",
                  {
                    key: 0,
                    ref_key: "trRef",
                    ref: trRef,
                    class: vue.normalizeClass(vue.unref(ns).b("tr-expand"))
                  },
                  [
                    vue.createElementVNode("td", {
                      class: vue.normalizeClass(vue.unref(ns).be("tr-expand", "td")),
                      colspan: vue.unref(vue.unref(table).colspan)
                    }, [
                      vue.createElementVNode(
                        "div",
                        {
                          ref_key: "contentExpandRef",
                          ref: contentExpandRef,
                          class: vue.normalizeClass(vue.unref(ns).be("tr-expand", "content"))
                        },
                        [
                          vue.createElementVNode(
                            "div",
                            {
                              class: vue.normalizeClass(vue.unref(ns).bem("tr-expand", "content", "inner"))
                            },
                            [
                              vue.renderSlot(_ctx.$slots, "expand")
                            ],
                            2
                          )
                        ],
                        2
                      )
                    ], 10, _hoisted_1$1)
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true)
              ]),
              _: 3
            })) : vue.createCommentVNode("v-if", true)
          ],
          64
        );
      };
    }
  });
  var Tr = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__file", "tr.vue"]]);

  const toggleSelectAll = (selected, data) => {
    if (selected.length !== data.length) {
      return [...data];
    }
    return [];
  };
  const sortData = (event, data, sortKey, type = "desc") => {
    const _sortKey = String(sortKey);
    let sortType = type;
    const ns = useNamespace("table");
    const el = event.target;
    data = [...data].sort(returnOriginalIndex);
    if (!el)
      return [];
    if (el.dataset[`sortType${_sortKey}`] === "desc") {
      sortType = "asc";
    } else if (el.dataset[`sortType${_sortKey}`] === "asc") {
      sortType = void 0;
    }
    if (sortType === "desc") {
      data.forEach((item, index) => {
        item[`originalIndex${_sortKey}`] = index;
      });
    }
    el.dataset[`sortType${_sortKey}`] = sortType;
    el.dataset["sortType"] = sortType;
    el.dataset["sortKey"] = `sortType${_sortKey}`;
    const parent = el.closest(ns.e("tr"));
    const thsort = parent == null ? void 0 : parent.querySelectorAll("th.is-sort");
    thsort == null ? void 0 : thsort.forEach((th) => {
      if (th !== el) {
        th.dataset.sortType = null;
        th.dataset[th.dataset[`sortKey`]] = null;
      }
    });
    function compare(a, b) {
      if (a[_sortKey] < b[_sortKey]) {
        return sortType !== "desc" ? 1 : -1;
      }
      if (a[_sortKey] > b[_sortKey]) {
        return sortType !== "desc" ? -1 : 1;
      }
      return 0;
    }
    function returnOriginalIndex(a, b) {
      return a[`originalIndex${_sortKey}`] - b[`originalIndex${_sortKey}`];
    }
    return sortType !== void 0 ? [...data].sort(compare) : [...data].sort(returnOriginalIndex);
  };
  const getPage = (data, page, maxItems = 5) => {
    const max = Math.ceil(page * maxItems);
    const min = max - maxItems;
    return data.filter((_, index) => index >= min && index < max);
  };

  const VsTable = withInstall(Table, {
    Td,
    Th,
    Tr
  });
  const VsTd = withNoopInstall(Td);
  const VsTh = withNoopInstall(Th);
  const VsTr = withNoopInstall(Tr);

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var dayjs_min = {exports: {}};

  (function(module, exports) {
    !function(t, e) {
      module.exports = e() ;
    }(commonjsGlobal, function() {
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = function(t2) {
        return t2 instanceof _;
      }, S = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, w = function(t2, e2) {
        if (p(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, O = v;
      O.l = S, O.i = p, O.w = function(t2, e2) {
        return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = S(t2.locale, null, true), this.parse(t2);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return new Date(NaN);
            if (O.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.$x = t2.x || {}, this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return O;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = w(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return w(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < w(t2);
        }, m2.$g = function(t2, e2, n2) {
          return O.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!O.u(e2) || e2, h2 = O.p(t2), l2 = function(t3, e3) {
            var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (h2) {
            case c:
              return r2 ? l2(1, 0) : l2(31, 11);
            case f:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = O.p(t2), h2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = h2 + "Date", n2[d] = h2 + "Date", n2[f] = h2 + "Month", n2[c] = h2 + "FullYear", n2[u] = h2 + "Hours", n2[s] = h2 + "Minutes", n2[i] = h2 + "Seconds", n2[r] = h2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === f || o2 === c) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[O.p(t2)]();
        }, m2.add = function(r2, h2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = O.p(h2), y2 = function(t2) {
            var e2 = w(l2);
            return O.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === f)
            return this.set(f, this.$M + r2);
          if ($2 === c)
            return this.set(c, this.$y + r2);
          if ($2 === a)
            return y2(1);
          if ($2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return O.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, c2 = function(t3) {
            return O.s(s2 % 12 || 12, t3, "0");
          }, d2 = n2.meridiem || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          }, $2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n2.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n2.weekdaysMin, this.$W, o2, 2), ddd: h2(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
          return r2.replace(y, function(t3, e3) {
            return e3 || $2[t3] || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, v2 = this - M3, g2 = O.m(this, M3);
          return g2 = ($2 = {}, $2[c] = g2 / 12, $2[f] = g2, $2[h] = g2 / 3, $2[o] = (v2 - m3) / 6048e5, $2[a] = (v2 - m3) / 864e5, $2[u] = v2 / n, $2[s] = v2 / e, $2[i] = v2 / t, $2)[y2] || v2, l2 ? g2 : O.a(g2);
        }, m2.daysInMonth = function() {
          return this.endOf(f).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = S(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return O.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), T = _.prototype;
      return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
        T[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), w.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, w), t2.$i = true), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
        return w(1e3 * t2);
      }, w.en = D[g], w.Ls = D, w.p = {}, w;
    });
  })(dayjs_min);
  var dayjs = dayjs_min.exports;

  var customParseFormat$1 = {exports: {}};

  (function(module, exports) {
    !function(e, t) {
      module.exports = t() ;
    }(commonjsGlobal, function() {
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o = {}, s = function(e2) {
        return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
      };
      var a = function(e2) {
        return function(t2) {
          this[e2] = +t2;
        };
      }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
        (this.zone || (this.zone = {})).offset = function(e3) {
          if (!e3)
            return 0;
          if ("Z" === e3)
            return 0;
          var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
          return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
        }(e2);
      }], h = function(e2) {
        var t2 = o[e2];
        return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
      }, u = function(e2, t2) {
        var n2, r2 = o.meridiem;
        if (r2) {
          for (var i2 = 1; i2 <= 24; i2 += 1)
            if (e2.indexOf(r2(i2, 0, t2)) > -1) {
              n2 = i2 > 12;
              break;
            }
        } else
          n2 = e2 === (t2 ? "pm" : "PM");
        return n2;
      }, d = { A: [i, function(e2) {
        this.afternoon = u(e2, false);
      }], a: [i, function(e2) {
        this.afternoon = u(e2, true);
      }], S: [/\d/, function(e2) {
        this.milliseconds = 100 * +e2;
      }], SS: [n, function(e2) {
        this.milliseconds = 10 * +e2;
      }], SSS: [/\d{3}/, function(e2) {
        this.milliseconds = +e2;
      }], s: [r, a("seconds")], ss: [r, a("seconds")], m: [r, a("minutes")], mm: [r, a("minutes")], H: [r, a("hours")], h: [r, a("hours")], HH: [r, a("hours")], hh: [r, a("hours")], D: [r, a("day")], DD: [n, a("day")], Do: [i, function(e2) {
        var t2 = o.ordinal, n2 = e2.match(/\d+/);
        if (this.day = n2[0], t2)
          for (var r2 = 1; r2 <= 31; r2 += 1)
            t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
      }], M: [r, a("month")], MM: [n, a("month")], MMM: [i, function(e2) {
        var t2 = h("months"), n2 = (h("monthsShort") || t2.map(function(e3) {
          return e3.slice(0, 3);
        })).indexOf(e2) + 1;
        if (n2 < 1)
          throw new Error();
        this.month = n2 % 12 || n2;
      }], MMMM: [i, function(e2) {
        var t2 = h("months").indexOf(e2) + 1;
        if (t2 < 1)
          throw new Error();
        this.month = t2 % 12 || t2;
      }], Y: [/[+-]?\d+/, a("year")], YY: [n, function(e2) {
        this.year = s(e2);
      }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
      function c(n2) {
        var r2, i2;
        r2 = n2, i2 = o && o.formats;
        for (var s2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
          var o2 = r3 && r3.toUpperCase();
          return n3 || i2[r3] || e[r3] || i2[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
            return t3 || n4.slice(1);
          });
        })).match(t), a2 = s2.length, f2 = 0; f2 < a2; f2 += 1) {
          var h2 = s2[f2], u2 = d[h2], c2 = u2 && u2[0], l = u2 && u2[1];
          s2[f2] = l ? { regex: c2, parser: l } : h2.replace(/^\[|\]$/g, "");
        }
        return function(e2) {
          for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
            var i3 = s2[n3];
            if ("string" == typeof i3)
              r3 += i3.length;
            else {
              var o2 = i3.regex, f3 = i3.parser, h3 = e2.slice(r3), u3 = o2.exec(h3)[0];
              f3.call(t2, u3), e2 = e2.replace(u3, "");
            }
          }
          return function(e3) {
            var t3 = e3.afternoon;
            if (void 0 !== t3) {
              var n4 = e3.hours;
              t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
            }
          }(t2), t2;
        };
      }
      return function(e2, t2, n2) {
        n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (s = e2.parseTwoDigitYear);
        var r2 = t2.prototype, i2 = r2.parse;
        r2.parse = function(e3) {
          var t3 = e3.date, r3 = e3.utc, s2 = e3.args;
          this.$u = r3;
          var a2 = s2[1];
          if ("string" == typeof a2) {
            var f2 = true === s2[2], h2 = true === s2[3], u2 = f2 || h2, d2 = s2[2];
            h2 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n2.Ls[d2]), this.$d = function(e4, t4, n3) {
              try {
                if (["x", "X"].indexOf(t4) > -1)
                  return new Date(("X" === t4 ? 1e3 : 1) * e4);
                var r4 = c(t4)(e4), i3 = r4.year, o2 = r4.month, s3 = r4.day, a3 = r4.hours, f3 = r4.minutes, h3 = r4.seconds, u3 = r4.milliseconds, d3 = r4.zone, l2 = new Date(), m2 = s3 || (i3 || o2 ? 1 : l2.getDate()), M2 = i3 || l2.getFullYear(), Y = 0;
                i3 && !o2 || (Y = o2 > 0 ? o2 - 1 : l2.getMonth());
                var p = a3 || 0, v = f3 || 0, D = h3 || 0, g = u3 || 0;
                return d3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g + 60 * d3.offset * 1e3)) : n3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g)) : new Date(M2, Y, m2, p, v, D, g);
              } catch (e5) {
                return new Date("");
              }
            }(t3, a2, r3), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = new Date("")), o = {};
          } else if (a2 instanceof Array)
            for (var l = a2.length, m = 1; m <= l; m += 1) {
              s2[1] = a2[m - 1];
              var M = n2.apply(this, s2);
              if (M.isValid()) {
                this.$d = M.$d, this.$L = M.$L, this.init();
                break;
              }
              m === l && (this.$d = new Date(""));
            }
          else
            i2.call(this, e3);
        };
      };
    });
  })(customParseFormat$1);
  var customParseFormat = customParseFormat$1.exports;

  const parseTime = (time) => {
    const values = (time || "").split(":");
    if (values.length >= 2) {
      let hours = Number.parseInt(values[0], 10);
      const minutes = Number.parseInt(values[1], 10);
      const timeUpper = time.toUpperCase();
      if (timeUpper.includes("AM") && hours === 12) {
        hours = 0;
      } else if (timeUpper.includes("PM") && hours !== 12) {
        hours += 12;
      }
      return {
        hours,
        minutes
      };
    }
    return null;
  };
  const compareTime = (time1, time2) => {
    const value1 = parseTime(time1);
    if (!value1)
      return -1;
    const value2 = parseTime(time2);
    if (!value2)
      return -1;
    const minutes1 = value1.minutes + value1.hours * 60;
    const minutes2 = value2.minutes + value2.hours * 60;
    if (minutes1 === minutes2) {
      return 0;
    }
    return minutes1 > minutes2 ? 1 : -1;
  };
  const padTime = (time) => {
    return `${time}`.padStart(2, "0");
  };
  const formatTime = (time) => {
    return `${padTime(time.hours)}:${padTime(time.minutes)}`;
  };
  const nextTime = (time, step) => {
    const timeValue = parseTime(time);
    if (!timeValue)
      return "";
    const stepValue = parseTime(step);
    if (!stepValue)
      return "";
    const next = {
      hours: timeValue.hours,
      minutes: timeValue.minutes
    };
    next.minutes += stepValue.minutes;
    next.hours += stepValue.hours;
    next.hours += Math.floor(next.minutes / 60);
    next.minutes = next.minutes % 60;
    return formatTime(next);
  };

  const timeSelectProps = {
    format: {
      type: String,
      default: "HH:mm"
    },
    modelValue: { type: String },
    disabled: { type: Boolean },
    editable: {
      type: Boolean,
      default: true
    },
    effect: {
      type: String,
      default: null
    },
    clearable: {
      type: Boolean,
      default: true
    },
    placeholder: { type: String },
    start: {
      type: String,
      default: "09:00"
    },
    end: {
      type: String,
      default: "18:00"
    },
    step: {
      type: String,
      default: "00:30"
    },
    minTime: { type: String },
    maxTime: { type: String },
    name: { type: String },
    clearIcon: {
      type: definePropType([String, Object]),
      default: () => close_circle_default
    },
    disabledItems: {
      type: definePropType(Array),
      default: () => []
    }
  };

  const __default__$3 = vue.defineComponent({
    name: "VsTimeSelect"
  });
  const _sfc_main$3 = vue.defineComponent({
    ...__default__$3,
    props: timeSelectProps,
    emits: ["change", "blur", "focus", UPDATE_MODEL_EVENT],
    setup(__props, { expose: __expose }) {
      const props = __props;
      dayjs.extend(customParseFormat);
      const selectInstance = vue.ref();
      const value = vue.computed(
        () => dayjs(props.modelValue || start.value, "HH:mm").format(props.format)
      );
      const start = vue.computed(() => {
        const time = parseTime(props.start);
        return time ? formatTime(time) : null;
      });
      const end = vue.computed(() => {
        const time = parseTime(props.end);
        return time ? formatTime(time) : null;
      });
      const step = vue.computed(() => {
        const time = parseTime(props.step);
        return time ? formatTime(time) : null;
      });
      const minTime = vue.computed(() => {
        const time = parseTime(props.minTime || "");
        return time ? formatTime(time) : null;
      });
      const maxTime = vue.computed(() => {
        const time = parseTime(props.maxTime || "");
        return time ? formatTime(time) : null;
      });
      const items = vue.computed(() => {
        const result = [];
        if (props.start && props.end && props.step) {
          let current = start.value;
          let currentTime;
          while (current && end.value && compareTime(current, end.value) <= 0) {
            currentTime = dayjs(current, "HH:mm").format(props.format);
            result.push({
              value: currentTime,
              disabled: props.disabledItems.includes(current) || compareTime(current, minTime.value || "-1:-1") <= 0 || compareTime(current, maxTime.value || "100:100") >= 0
            });
            current = nextTime(current, step.value);
          }
        }
        return result;
      });
      const focus = () => {
        var _a;
        (_a = selectInstance.value) == null ? void 0 : _a.focus();
      };
      const blur = () => {
        var _a;
        (_a = selectInstance.value) == null ? void 0 : _a.blur();
      };
      __expose({
        focus,
        blur
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(VsSelect), {
          ref_key: "selectInstance",
          ref: selectInstance,
          "model-value": value.value,
          disabled: _ctx.disabled,
          clearable: _ctx.clearable,
          "clear-icon": _ctx.clearIcon,
          effect: _ctx.effect,
          placeholder: _ctx.placeholder,
          "default-first-option": "",
          filter: _ctx.editable,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = (event) => _ctx.$emit("update:modelValue", event)),
          onChange: _cache[1] || (_cache[1] = (event) => _ctx.$emit("change", event)),
          onBlur: _cache[2] || (_cache[2] = (event) => _ctx.$emit("blur", event)),
          onFocus: _cache[3] || (_cache[3] = (event) => _ctx.$emit("focus", event))
        }, {
          default: vue.withCtx(() => [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(items.value, (item) => {
                return vue.openBlock(), vue.createBlock(vue.unref(VsOption), {
                  key: item.value,
                  label: item.value,
                  value: item.value,
                  disabled: item.disabled
                }, null, 8, ["label", "value", "disabled"]);
              }),
              128
            ))
          ]),
          _: 1
        }, 8, ["model-value", "disabled", "clearable", "clear-icon", "effect", "placeholder", "filter"]);
      };
    }
  });
  var TimeSelect = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__file", "time-select.vue"]]);

  const VsTimeSelect = withInstall(TimeSelect);

  var Components = [
    VsAlert,
    VsAvatar,
    VsAvatarGroup,
    VsBadge,
    VsButton,
    VsButtonGroup,
    VsCard,
    VsCardGroup,
    VsCheckbox,
    VsCheckboxGroup,
    VsCol,
    VsCollapseTransition,
    VsDialog,
    VsIcon,
    VsInput,
    VsInputNumber,
    VsOptionGroup,
    VsOption,
    VsNavbar,
    VsNavbarGroup,
    VsNavbarItem,
    VsPagination,
    VsPopconfirm,
    VsPopper,
    VsRadio,
    VsRate,
    VsRow,
    VsScrollbar,
    VsSelect,
    VsSwitch,
    VsSidebar,
    VsSidebarGroup,
    VsSidebarItem,
    VsTable,
    VsTd,
    VsTh,
    VsTr,
    VsTimeSelect,
    VsTooltip
  ];

  const SCOPE = "VsInfiniteScroll";
  const CHECK_INTERVAL = 50;
  const DEFAULT_DELAY = 200;
  const DEFAULT_DISTANCE = 0;
  const attributes = {
    delay: {
      type: Number,
      default: DEFAULT_DELAY
    },
    distance: {
      type: Number,
      default: DEFAULT_DISTANCE
    },
    disabled: {
      type: Boolean,
      default: false
    },
    immediate: {
      type: Boolean,
      default: true
    }
  };
  const getScrollOptions = (el, instance) => {
    return Object.entries(attributes).reduce((acm, [name, option]) => {
      var _a, _b;
      const { type, default: defaultValue } = option;
      const attrVal = el.getAttribute(`infinite-scroll-${name}`);
      let value = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue;
      value = value === "false" ? false : value;
      value = type(value);
      acm[name] = Number.isNaN(value) ? defaultValue : value;
      return acm;
    }, {});
  };
  const destroyObserver = (el) => {
    const { observer } = el[SCOPE];
    if (observer) {
      observer.disconnect();
      delete el[SCOPE].observer;
    }
  };
  const handleScroll = (el, cb) => {
    const { container, containerEl, instance, observer, lastScrollTop } = el[SCOPE];
    const { disabled, distance } = getScrollOptions(el, instance);
    const { clientHeight, scrollHeight, scrollTop } = containerEl;
    const delta = scrollTop - lastScrollTop;
    el[SCOPE].lastScrollTop = scrollTop;
    if (observer || disabled || delta < 0)
      return;
    let shouldTrigger = false;
    if (container === el) {
      shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;
    } else {
      const { clientTop, scrollHeight: height } = el;
      const offsetTop = getOffsetTopDistance(el, containerEl);
      shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;
    }
    if (shouldTrigger) {
      cb.call(instance);
    }
  };
  function checkFull(el, cb) {
    const { containerEl, instance } = el[SCOPE];
    const { disabled } = getScrollOptions(el, instance);
    if (disabled || containerEl.clientHeight === 0)
      return;
    if (containerEl.scrollHeight <= containerEl.clientHeight) {
      cb.call(instance);
    } else {
      destroyObserver(el);
    }
  }
  const InfiniteScroll = {
    async mounted(el, binding) {
      const { instance, value: cb } = binding;
      if (!isFunction(cb)) {
        throwError(SCOPE, "'v-infinite-scroll' binding value must be a function");
      }
      await vue.nextTick();
      const { delay, immediate } = getScrollOptions(el, instance);
      const container = getScrollContainer(el, true);
      const containerEl = container === window ? document.documentElement : container;
      const onScroll = throttle(handleScroll.bind(null, el, cb), delay);
      if (!container)
        return;
      el[SCOPE] = {
        instance,
        container,
        containerEl,
        delay,
        cb,
        onScroll,
        lastScrollTop: containerEl.scrollTop
      };
      if (immediate) {
        const observer = new MutationObserver(
          throttle(checkFull.bind(null, el, cb), CHECK_INTERVAL)
        );
        el[SCOPE].observer = observer;
        observer.observe(el, { childList: true, subtree: true });
        checkFull(el, cb);
      }
      container.addEventListener("scroll", onScroll);
    },
    unmounted(el) {
      const { container, onScroll } = el[SCOPE];
      container == null ? void 0 : container.removeEventListener("scroll", onScroll);
      destroyObserver(el);
    },
    async updated(el) {
      if (!el[SCOPE]) {
        await vue.nextTick();
      }
      const { containerEl, cb, observer } = el[SCOPE];
      if (containerEl.clientHeight && observer) {
        checkFull(el, cb);
      }
    }
  };
  var InfiniteScroll$1 = InfiniteScroll;

  const _InfiniteScroll = InfiniteScroll$1;
  _InfiniteScroll.install = (app) => {
    app.directive("InfiniteScroll", _InfiniteScroll);
  };
  const VsInfiniteScroll = _InfiniteScroll;

  const loadingTypes = [
    "atom",
    "ball",
    "scale",
    "waves",
    "border",
    "points",
    "square",
    "circles",
    "corners",
    "default",
    "gradient",
    "rectangle",
    "square-rotate"
  ];
  const loadingProps = buildProps({
    type: {
      type: definePropType(String),
      values: loadingTypes,
      default: "default"
    },
    text: { type: String },
    scale: {
      type: definePropType([String, Number]),
      validator: (scale) => isNumber(scale) || isStringNumber(scale),
      default: 1
    },
    color: useColorProp,
    target: {
      type: definePropType([String, Object])
    },
    opacity: {
      type: definePropType([String, Number]),
      validator: (scale) => isNumber(scale) || isStringNumber(scale),
      default: 0.6
    },
    percent: {
      type: definePropType([String, Number]),
      validator: (scale) => isNumber(scale) || isStringNumber(scale)
    },
    progress: {
      type: definePropType([String, Number]),
      validator: (progress) => isNumber(progress) || isStringNumber(progress)
    },
    background: useColorProp
  });

  const __default__$2 = vue.defineComponent({
    name: "VsLoading"
  });
  const _sfc_main$2 = vue.defineComponent({
    ...__default__$2,
    props: loadingProps,
    setup(__props, { expose: __expose }) {
      const props = __props;
      const { ns, zIndex } = useGlobalComponentSettings("loading");
      const { currentZIndex } = zIndex;
      const loadingRef = vue.ref();
      const color = useColor("primary");
      const background = useProp("background");
      const type = useProp("type");
      const loadingKls = vue.computed(() => [
        ns.b(),
        type.value && ns.m(type.value),
        ns.is("has-target", !!vue.unref(props.target))
      ]);
      const loadingStyles = vue.computed(() => [
        ns.cssVar({
          color: getVsColor(color),
          background: getVsColor(background),
          opacity: `${vue.unref(props.opacity)}`
        }),
        { zIndex: vue.unref(currentZIndex) }
      ]);
      const close = () => {
        var _a;
        (_a = loadingRef.value) == null ? void 0 : _a.remove();
      };
      __expose({
        close
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            ref_key: "loadingRef",
            ref: loadingRef,
            class: vue.normalizeClass(loadingKls.value),
            style: vue.normalizeStyle(loadingStyles.value)
          },
          [
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(vue.unref(ns).e("load")),
                style: vue.normalizeStyle([{ transform: `scale(${vue.unref(_ctx.scale)})` }])
              },
              [
                vue.createElementVNode(
                  "div",
                  {
                    class: vue.normalizeClass(vue.unref(ns).e("animation"))
                  },
                  [
                    vue.unref(_ctx.percent) ? (vue.openBlock(), vue.createElementBlock(
                      "div",
                      {
                        key: 0,
                        class: vue.normalizeClass(vue.unref(ns).em("load", "percent"))
                      },
                      vue.toDisplayString(vue.unref(_ctx.percent)),
                      3
                    )) : vue.createCommentVNode("v-if", true),
                    vue.unref(vue.unref(type)) === "default" ? (vue.openBlock(), vue.createBlock(vue.unref(IconLoading), { key: 1 })) : vue.createCommentVNode("v-if", true),
                    vue.createElementVNode(
                      "div",
                      {
                        class: vue.normalizeClass([vue.unref(ns).em("animation", "item"), vue.unref(ns).em("animation", "item-1")])
                      },
                      null,
                      2
                    ),
                    vue.createElementVNode(
                      "div",
                      {
                        class: vue.normalizeClass([vue.unref(ns).em("animation", "item"), vue.unref(ns).em("animation", "item-2")])
                      },
                      null,
                      2
                    ),
                    vue.createElementVNode(
                      "div",
                      {
                        class: vue.normalizeClass([vue.unref(ns).em("animation", "item"), vue.unref(ns).em("animation", "item-3")])
                      },
                      null,
                      2
                    ),
                    vue.unref(vue.unref(type)) === "ball" ? (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 2 },
                      [
                        vue.createElementVNode(
                          "div",
                          {
                            class: vue.normalizeClass([
                              vue.unref(ns).em("animation", "shadow"),
                              vue.unref(ns).em("animation", "shadow-1")
                            ])
                          },
                          null,
                          2
                        ),
                        vue.createElementVNode(
                          "div",
                          {
                            class: vue.normalizeClass([
                              vue.unref(ns).em("animation", "shadow"),
                              vue.unref(ns).em("animation", "shadow-2")
                            ])
                          },
                          null,
                          2
                        ),
                        vue.createElementVNode(
                          "div",
                          {
                            class: vue.normalizeClass([
                              vue.unref(ns).em("animation", "shadow"),
                              vue.unref(ns).em("animation", "shadow-3")
                            ])
                          },
                          null,
                          2
                        )
                      ],
                      64
                    )) : vue.createCommentVNode("v-if", true)
                  ],
                  2
                ),
                vue.unref(_ctx.text) ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 0,
                    class: vue.normalizeClass(vue.unref(ns).e("text"))
                  },
                  vue.toDisplayString(vue.unref(_ctx.text)),
                  3
                )) : vue.createCommentVNode("v-if", true)
              ],
              6
            ),
            vue.unref(_ctx.progress) ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).e("progress"))
              },
              [
                vue.createElementVNode(
                  "div",
                  {
                    class: vue.normalizeClass(vue.unref(ns).e("progress-bar")),
                    style: vue.normalizeStyle([{ width: `${vue.unref(_ctx.progress)}%` }])
                  },
                  null,
                  6
                )
              ],
              2
            )) : vue.createCommentVNode("v-if", true)
          ],
          6
        );
      };
    }
  });
  var LoadingConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__file", "loading.vue"]]);

  const loading = (options = {}) => {
    if (!options || !isClient)
      return {
        setPercent: () => void 0,
        setProgress: () => void 0,
        close: () => void 0,
        setText: () => void 0
      };
    const getOption = (key) => {
      const data = (options == null ? void 0 : options[key]) || key;
      if (vue.unref(data))
        return vue.ref(data);
      return data;
    };
    const optionsRef = {};
    Object.keys(options).forEach((e) => {
      optionsRef[e] = getOption(e);
    });
    let appendTo = document.body;
    if (isElement$2(unrefElement(optionsRef.target))) {
      appendTo = unrefElement(optionsRef.target);
    } else if (isString(vue.unref(optionsRef.target))) {
      appendTo = document.querySelector(vue.unref(optionsRef.target));
    }
    if (!isElement$2(appendTo)) {
      appendTo = document.body;
      optionsRef.target.value = void 0;
    }
    if (appendTo.clientHeight < LOADING_RECT.height) {
      const eightyPercentParentHeight = appendTo.clientHeight * SCALE_PARENT;
      const loadingScale = eightyPercentParentHeight / LOADING_RECT.height;
      optionsRef.scale = vue.ref(loadingScale);
    }
    const vm = vue.createVNode(LoadingConstructor, vue.reactive(optionsRef));
    const container = document.createElement("div");
    vue.render(vm, container);
    appendTo.appendChild(container.firstChild);
    const close = () => {
      vm.component.exposed.close();
    };
    const setText = (val) => {
      optionsRef.text.value = val;
    };
    const setProgress = (val) => {
      optionsRef.progress.value = val;
    };
    const setPercent = (val) => {
      optionsRef.percent.value = val;
    };
    return {
      close,
      setText,
      setProgress,
      setPercent
    };
  };

  const INSTANCE_KEY = Symbol("VsLoading");
  const createInstance = (el, binding) => {
    var _a;
    const vm = binding.instance;
    const getBindingProp = (key) => isObject(binding.value) ? binding.value[key] : void 0;
    const resolveExpression = (key) => {
      const data = isString(key) && (vm == null ? void 0 : vm[key]) || key;
      if (data)
        return vue.ref(data);
      return data;
    };
    const getProp = (name, def) => {
      var _a2, _b;
      return resolveExpression(
        (_b = (_a2 = getBindingProp(name)) != null ? _a2 : el.getAttribute(`element-loading-${hyphenate(name)}`)) != null ? _b : def
      );
    };
    const options = {
      text: getProp("text"),
      color: getProp("color"),
      background: getProp("background"),
      target: (_a = getBindingProp("target")) != null ? _a : el,
      opacity: getProp("opacity"),
      progress: getProp("progress"),
      percent: getProp("percent"),
      scale: getProp("scale"),
      type: getProp("type")
    };
    el[INSTANCE_KEY] = {
      options,
      instance: loading(options)
    };
  };
  const updateOptions = (newOptions, originalOptions) => {
    for (const key of Object.keys(originalOptions)) {
      if (vue.isRef(originalOptions[key])) {
        originalOptions[key].value = newOptions[key];
      }
    }
  };
  const vLoading = {
    mounted(el, binding) {
      if (binding.value == true || isObject(binding.value) && binding.value.visible) {
        createInstance(el, binding);
      }
    },
    updated(el, binding) {
      var _a;
      const instance = el[INSTANCE_KEY];
      if (!isEqual(binding.value, binding.oldValue)) {
        if (isObject(binding.value)) {
          if (binding.value.visible) {
            if (!((_a = binding.oldValue) == null ? void 0 : _a.visible)) {
              createInstance(el, binding);
            }
            if (instance)
              updateOptions(binding.value, instance.options);
          } else {
            instance == null ? void 0 : instance.instance.close();
          }
        } else {
          if (binding.value) {
            createInstance(el, binding);
          } else {
            instance == null ? void 0 : instance.instance.close();
          }
        }
      }
    },
    unmounted(el) {
      var _a;
      (_a = el[INSTANCE_KEY]) == null ? void 0 : _a.instance.close();
    }
  };

  const VsLoading = {
    install(app) {
      app.directive("loading", vLoading);
      app.config.globalProperties.$loading = loading;
    },
    directive: vLoading,
    service: loading
  };

  const notificationPosition = [
    "top-right",
    "top-center",
    "top-left",
    "bottom-right",
    "bottom-center",
    "bottom-left"
  ];
  const notificationProps = buildProps({
    border: useColorProp,
    color: useColorProp,
    customClass: {
      type: String,
      default: ""
    },
    duration: {
      type: Number,
      default: 4500
    },
    flat: { type: Boolean },
    icon: {
      type: iconPropType
    },
    iconSize: {
      type: String,
      default: "1.2rem"
    },
    id: {
      type: String,
      default: ""
    },
    dangerousHtmlString: {
      type: Boolean,
      default: false
    },
    content: {
      type: definePropType([String, Object]),
      default: ""
    },
    loading: Boolean,
    notPadding: Boolean,
    offset: {
      type: Number,
      default: 0
    },
    onClick: {
      type: definePropType(Function),
      default: () => void 0
    },
    onClickClose: {
      type: definePropType(Function),
      default: () => true
    },
    onClose: {
      type: definePropType(Function),
      default: () => void 0
    },
    position: {
      type: definePropType(String),
      values: notificationPosition,
      default: "bottom-right"
    },
    progressAuto: { type: Boolean },
    shape: {
      type: String,
      values: ["square", ""],
      default: ""
    },
    showClose: {
      type: Boolean,
      default: true
    },
    sticky: { type: Boolean },
    title: {
      type: String,
      default: ""
    },
    zIndex: { type: Number },
    width: {
      type: definePropType([String, Number]),
      validator: (prop) => ["auto", "full"].includes(prop) || isNumber(prop) || isStringNumber(prop),
      default: null
    }
  });
  const notificationEmits = {
    destroy: () => true
  };

  const _hoisted_1 = ["innerHTML"];
  const _hoisted_2 = ["innerHTML"];
  const _hoisted_3 = { key: 1 };
  const __default__$1 = vue.defineComponent({
    name: "VsNotification"
  });
  const _sfc_main$1 = vue.defineComponent({
    ...__default__$1,
    props: notificationProps,
    setup(__props, { expose: __expose }) {
      const props = __props;
      const { ns, zIndex } = useGlobalComponentSettings("notification");
      const { currentZIndex, nextZIndex } = zIndex;
      const color = useColor();
      const notifyRef = vue.ref();
      const visible = vue.ref(false);
      let timer = void 0;
      const vsBaseClasses = useVuesaxBaseComponent(color);
      const notifyKls = vue.computed(() => [
        ns.b(),
        vsBaseClasses,
        ns.is("flat", props.flat),
        ns.is("sticky", props.sticky),
        ns.is("border", !!props.border),
        ns.is("color", !!color.value),
        ns.is("icon", !!props.icon),
        ns.is("on-click", !!props.onClick),
        ns.is("on-click-close", !!props.onClickClose),
        props.shape && ns.is(props.shape),
        ns.is("loading", props.loading),
        ns.is("not-padding", props.notPadding),
        ns.is("width-full", props.width == "full"),
        ns.is("width-auto", props.width == "auto")
      ]);
      const notifyStyles = vue.computed(() => [
        {
          zIndex: vue.unref(currentZIndex)
        },
        ns.cssVar({
          color: getVsColor(color),
          border: getVsColor(props.border)
        })
      ]);
      const handleClick = () => {
        var _a;
        (_a = props.onClick) == null ? void 0 : _a.call(props);
      };
      const handleClickClose = () => {
        var _a, _b;
        if (!((_a = props.onClickClose) == null ? void 0 : _a.call(props))) {
          return;
        }
        visible.value = false;
        (_b = props.onClose) == null ? void 0 : _b.call(props);
      };
      const onTransitionBeforeEnter = (el) => {
        nextZIndex();
        const _el = el;
        _el.style.maxHeight = `0`;
        _el.style.padding = `0 20px`;
      };
      const onTransitionEnter = (el, done) => {
        const h = el.scrollHeight;
        const _el = el;
        _el.style.maxHeight = `${h + 40}px`;
        if (window.innerWidth < 600) {
          _el.style.padding = `15px`;
        } else {
          _el.style.padding = `20px`;
        }
        done();
      };
      const onTransitionLeave = (_, done) => {
        setTimeout(() => {
          var _a, _b;
          (_a = notifyRef.value) == null ? void 0 : _a.remove();
          done();
          (_b = props.onClose) == null ? void 0 : _b.call(props);
        }, 150);
      };
      const startTimer = () => {
        if (props.duration > 0) {
          ({ stop: timer } = useTimeoutFn(() => {
            if (visible.value)
              close();
          }, props.duration));
        }
      };
      const clearTimer = () => {
        timer == null ? void 0 : timer();
      };
      const open = () => {
        clearTimer();
        startTimer();
        nextZIndex();
        visible.value = true;
      };
      const close = () => {
        visible.value = false;
      };
      let intervalProgress = 0;
      const currentProgress = vue.ref(0);
      const handleProgress = () => {
        if (props.progressAuto && props.duration > 0) {
          intervalProgress = setInterval(() => {
            currentProgress.value += 1;
          }, props.duration / 100);
        }
      };
      vue.onMounted(() => {
        open();
        handleProgress();
      });
      vue.onBeforeUnmount(() => {
        clearInterval(intervalProgress);
      });
      __expose({
        visible,
        close,
        open
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.Transition, {
          name: "vs-notification",
          onBeforeEnter: onTransitionBeforeEnter,
          onEnter: onTransitionEnter,
          onLeave: onTransitionLeave,
          persisted: ""
        }, {
          default: vue.withCtx(() => [
            vue.withDirectives(vue.createElementVNode(
              "div",
              {
                ref_key: "notifyRef",
                ref: notifyRef,
                class: vue.normalizeClass(notifyKls.value),
                style: vue.normalizeStyle(notifyStyles.value),
                onClick: handleClick
              },
              [
                !_ctx.loading ? (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 0 },
                  [
                    _ctx.icon ? (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 0 },
                      [
                        typeof _ctx.icon === "string" ? (vue.openBlock(), vue.createElementBlock("div", {
                          key: 0,
                          class: vue.normalizeClass(vue.unref(ns).e("icon")),
                          style: vue.normalizeStyle({ fontSize: vue.unref(addUnit)(_ctx.iconSize) }),
                          innerHTML: _ctx.icon
                        }, null, 14, _hoisted_1)) : (vue.openBlock(), vue.createElementBlock(
                          "div",
                          {
                            key: 1,
                            class: vue.normalizeClass(vue.unref(ns).e("icon"))
                          },
                          [
                            vue.createVNode(vue.unref(VsIcon), {
                              size: vue.unref(addUnit)(_ctx.iconSize)
                            }, {
                              default: vue.withCtx(() => [
                                (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.icon)))
                              ]),
                              _: 1
                            }, 8, ["size"])
                          ],
                          2
                        ))
                      ],
                      64
                    )) : vue.createCommentVNode("v-if", true),
                    vue.createElementVNode(
                      "div",
                      {
                        class: vue.normalizeClass(vue.unref(ns).e("content"))
                      },
                      [
                        _ctx.title ? (vue.openBlock(), vue.createElementBlock(
                          "div",
                          {
                            key: 0,
                            class: vue.normalizeClass(vue.unref(ns).e("title"))
                          },
                          [
                            vue.createElementVNode(
                              "h4",
                              null,
                              vue.toDisplayString(_ctx.title),
                              1
                            )
                          ],
                          2
                        )) : vue.createCommentVNode("v-if", true),
                        _ctx.content ? (vue.openBlock(), vue.createElementBlock(
                          "div",
                          {
                            key: 1,
                            class: vue.normalizeClass(vue.unref(ns).e("text"))
                          },
                          [
                            vue.renderSlot(_ctx.$slots, "default", {}, () => [
                              _ctx.dangerousHtmlString ? (vue.openBlock(), vue.createElementBlock("p", {
                                key: 0,
                                innerHTML: _ctx.content
                              }, null, 8, _hoisted_2)) : (vue.openBlock(), vue.createElementBlock(
                                "p",
                                _hoisted_3,
                                vue.toDisplayString(_ctx.content),
                                1
                              ))
                            ])
                          ],
                          2
                        )) : vue.createCommentVNode("v-if", true)
                      ],
                      2
                    )
                  ],
                  64
                )) : (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 1,
                    class: vue.normalizeClass(vue.unref(ns).e("loading"))
                  },
                  null,
                  2
                )),
                _ctx.showClose ? (vue.openBlock(), vue.createElementBlock(
                  "button",
                  {
                    key: 2,
                    class: vue.normalizeClass(vue.unref(ns).e("close")),
                    onClick: handleClickClose
                  },
                  [
                    vue.createVNode(vue.unref(IconClose), { hover: "less" })
                  ],
                  2
                )) : vue.createCommentVNode("v-if", true),
                _ctx.progressAuto ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 3,
                    class: vue.normalizeClass(vue.unref(ns).e("progress")),
                    style: vue.normalizeStyle({ width: `${currentProgress.value}%` })
                  },
                  null,
                  6
                )) : vue.createCommentVNode("v-if", true)
              ],
              6
            ), [
              [vue.vShow, visible.value]
            ])
          ]),
          _: 3
        });
      };
    }
  });
  var NotificationConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__file", "notification.vue"]]);

  const useNotificationContainerId = () => {
    const namespace = useGlobalConfig("namespace", defaultNamespace);
    const idInjection = useIdInjection();
    const id = vue.computed(() => {
      return `${namespace.value}-notification-container-${idInjection.prefix}`;
    });
    const selector = vue.computed(() => `#${id.value}`);
    return {
      id,
      selector
    };
  };

  const globalContainer = {
    "top-right": null,
    "top-center": null,
    "top-left": null,
    "bottom-right": null,
    "bottom-center": null,
    "bottom-left": null
  };
  const notification = (options = {}) => {
    var _a, _b;
    if (!isClient)
      return {
        close: () => void 0
      };
    if (typeof options === "string" || vue.isVNode(options)) {
      options = { content: options };
    }
    const position = options.position || "bottom-right";
    const { id, selector } = useNotificationContainerId();
    if (!globalContainer[position] && !document.body.querySelector(selector.value)) {
      globalContainer[position] = createContainer(`${id.value}-${position}`);
      const { ns } = useGlobalComponentSettings("notification");
      (_a = globalContainer[position]) == null ? void 0 : _a.classList.add(ns.is(position));
    }
    const vm = vue.createVNode(
      NotificationConstructor,
      { ...options, position },
      vue.isVNode(options.content) ? {
        default: () => isObject(options) ? options.content : null
      } : null
    );
    const container = document.createElement("div");
    vue.render(vm, container);
    (_b = globalContainer[position]) == null ? void 0 : _b.appendChild(container.firstChild);
    const close = () => {
      vm.component.exposed.close();
    };
    return {
      close
    };
  };
  var Notification = notification;

  const VsNotification = withInstallFunction(Notification, "$notification");

  var Plugins = [VsInfiniteScroll, VsLoading, VsNotification];

  var installer = makeInstaller([...Components, ...Plugins]);

  const configProviderProps = buildProps({
    zIndex: {
      type: Number
    },
    namespace: {
      type: String,
      default: "vs"
    },
    color: {
      type: definePropType(Object)
    },
    locale: {
      type: definePropType(Object)
    }
  });
  const ConfigProvider = vue.defineComponent({
    name: "VsConfigProvider",
    props: configProviderProps,
    setup(props, { slots }) {
      const config = provideGlobalConfig(props);
      return () => vue.renderSlot(slots, "default", { config: config == null ? void 0 : config.value });
    }
  });

  const VsConfigProvider = withInstall(ConfigProvider);

  const focusTrapProps = buildProps({
    loop: {
      type: Boolean
    },
    trapped: {
      type: Boolean
    },
    focusTrapEl: {
      type: definePropType(Object)
    },
    focusStartEl: {
      type: definePropType([Object, String]),
      default: "first"
    }
  });
  const focusTrapEmits = {
    [onTrapFocusEvent]: (e) => e instanceof Event,
    [onReleaseFocusEvent]: (e) => e,
    focusin: (e) => e instanceof Event,
    focusout: (e) => e instanceof Event,
    focusoutPrevented: (e) => e,
    releaseRequested: (e) => e instanceof Event
  };

  const focusReason = vue.ref();
  const lastUserFocusTimestamp = vue.ref(0);
  const lastAutomatedFocusTimestamp = vue.ref(0);
  let focusReasonUserCount = 0;
  const obtainAllFocusableElements = (element) => {
    const nodes = [];
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput)
          return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode())
      nodes.push(walker.currentNode);
    return nodes;
  };
  const getVisibleElement = (elements, container) => {
    for (const element of elements) {
      if (!isHidden(element, container))
        return element;
    }
  };
  const isHidden = (element, container) => {
    if (getComputedStyle(element).visibility === "hidden")
      return true;
    while (element) {
      if (container && element === container)
        return false;
      if (getComputedStyle(element).display === "none")
        return true;
      element = element.parentElement;
    }
    return false;
  };
  const getEdges = (container) => {
    const focusable = obtainAllFocusableElements(container);
    const first = getVisibleElement(focusable, container);
    const last = getVisibleElement(focusable.reverse(), container);
    return [first, last];
  };
  const isSelectable = (element) => {
    return element instanceof HTMLInputElement && "select" in element;
  };
  const tryFocus = (element, shouldSelect) => {
    if (element && element.focus) {
      const prevFocusedElement = document.activeElement;
      element.focus({ preventScroll: true });
      lastAutomatedFocusTimestamp.value = window.performance.now();
      if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
        element.select();
      }
    }
  };
  function removeFromStack(list, item) {
    const copy = [...list];
    const idx = list.indexOf(item);
    if (idx !== -1) {
      copy.splice(idx, 1);
    }
    return copy;
  }
  const createFocusableStack = () => {
    let stack = [];
    const push = (layer) => {
      const currentLayer = stack[0];
      if (currentLayer && layer !== currentLayer) {
        currentLayer.pause();
      }
      stack = removeFromStack(stack, layer);
      stack.unshift(layer);
    };
    const remove = (layer) => {
      var _a, _b;
      stack = removeFromStack(stack, layer);
      (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);
    };
    return {
      push,
      remove
    };
  };
  const focusFirstDescendant = (elements, shouldSelect = false) => {
    const prevFocusedElement = document.activeElement;
    for (const element of elements) {
      tryFocus(element, shouldSelect);
      if (document.activeElement !== prevFocusedElement)
        return;
    }
  };
  const focusableStack = createFocusableStack();
  const isFocusCausedByUserEvent = () => {
    return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
  };
  const notifyFocusReasonPointer = () => {
    focusReason.value = "pointer";
    lastUserFocusTimestamp.value = window.performance.now();
  };
  const notifyFocusReasonKeydown = () => {
    focusReason.value = "keyboard";
    lastUserFocusTimestamp.value = window.performance.now();
  };
  const useFocusReason = () => {
    vue.onMounted(() => {
      if (focusReasonUserCount === 0) {
        document.addEventListener("mousedown", notifyFocusReasonPointer);
        document.addEventListener("touchstart", notifyFocusReasonPointer);
        document.addEventListener("keydown", notifyFocusReasonKeydown);
      }
      focusReasonUserCount++;
    });
    vue.onBeforeUnmount(() => {
      focusReasonUserCount--;
      if (focusReasonUserCount <= 0) {
        document.removeEventListener("mousedown", notifyFocusReasonPointer);
        document.removeEventListener("touchstart", notifyFocusReasonPointer);
        document.removeEventListener("keydown", notifyFocusReasonKeydown);
      }
    });
    return {
      focusReason,
      lastUserFocusTimestamp,
      lastAutomatedFocusTimestamp
    };
  };
  const createFocusOutPreventedEvent = (detail) => {
    return new CustomEvent(focusoutPrevented, {
      ...focusoutPreventedOpts,
      detail
    });
  };

  const __default__ = vue.defineComponent({
    name: "VsFocusTrap",
    inheritAttrs: false
  });
  const _sfc_main = vue.defineComponent({
    ...__default__,
    props: focusTrapProps,
    emits: focusTrapEmits,
    setup(__props, { emit }) {
      const props = __props;
      const forwardRef = vue.ref();
      let lastFocusBeforeTrapped = null;
      let lastFocusAfterTrapped = null;
      const { focusReason } = useFocusReason();
      useEscapeKeydown((event) => {
        if (props.trapped && !focusLayer.paused) {
          emit("releaseRequested", event);
        }
      });
      const focusLayer = {
        paused: false,
        pause() {
          this.paused = true;
        },
        resume() {
          this.paused = false;
        }
      };
      const onKeydown = (e) => {
        if (!props.loop && !props.trapped)
          return;
        if (focusLayer.paused)
          return;
        const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
        const { loop } = props;
        const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
        const currentFocusingEl = document.activeElement;
        if (isTabbing && currentFocusingEl) {
          const container = currentTarget;
          const [first, last] = getEdges(container);
          const isTabbable = first && last;
          if (!isTabbable) {
            if (currentFocusingEl === container) {
              const focusoutPreventedEvent = createFocusOutPreventedEvent({
                focusReason: focusReason.value
              });
              emit("focusoutPrevented", focusoutPreventedEvent);
              if (!focusoutPreventedEvent.defaultPrevented) {
                e.preventDefault();
              }
            }
          } else {
            if (!shiftKey && currentFocusingEl === last) {
              const focusoutPreventedEvent = createFocusOutPreventedEvent({
                focusReason: focusReason.value
              });
              emit("focusoutPrevented", focusoutPreventedEvent);
              if (!focusoutPreventedEvent.defaultPrevented) {
                e.preventDefault();
                if (loop)
                  tryFocus(first, true);
              }
            } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
              const focusoutPreventedEvent = createFocusOutPreventedEvent({
                focusReason: focusReason.value
              });
              emit("focusoutPrevented", focusoutPreventedEvent);
              if (!focusoutPreventedEvent.defaultPrevented) {
                e.preventDefault();
                if (loop)
                  tryFocus(last, true);
              }
            }
          }
        }
      };
      vue.provide(focusTrapInjectionKey, {
        focusTrapRef: forwardRef,
        onKeydown
      });
      vue.watch(
        () => props.focusTrapEl,
        (focusTrapEl) => {
          if (focusTrapEl) {
            forwardRef.value = focusTrapEl;
          }
        },
        { immediate: true }
      );
      vue.watch(forwardRef, (forwardRef2, oldForwardRef) => {
        if (forwardRef2) {
          forwardRef2.addEventListener("keydown", onKeydown);
          forwardRef2.addEventListener("focusin", onFocusIn);
          forwardRef2.addEventListener("focusout", onFocusOut);
        }
        if (oldForwardRef instanceof HTMLElement) {
          oldForwardRef.removeEventListener("keydown", onKeydown);
          oldForwardRef.removeEventListener("focusin", onFocusIn);
          oldForwardRef.removeEventListener("focusout", onFocusOut);
        }
      });
      const trapOnFocus = (e) => {
        emit(onTrapFocusEvent, e);
      };
      const releaseOnFocus = (e) => emit(onReleaseFocusEvent, e);
      const onFocusIn = (e) => {
        const trapContainer = vue.unref(forwardRef);
        if (!trapContainer)
          return;
        const target = e.target;
        const relatedTarget = e.relatedTarget;
        const isFocusedInTrap = target && trapContainer.contains(target);
        if (!props.trapped) {
          const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
          if (!isPrevFocusedInTrap) {
            lastFocusBeforeTrapped = relatedTarget;
          }
        }
        if (isFocusedInTrap)
          emit("focusin", e);
        if (focusLayer.paused)
          return;
        if (props.trapped) {
          if (isFocusedInTrap) {
            lastFocusAfterTrapped = target;
          } else {
            tryFocus(lastFocusAfterTrapped, true);
          }
        }
      };
      const onFocusOut = (e) => {
        const trapContainer = vue.unref(forwardRef);
        if (focusLayer.paused || !trapContainer)
          return;
        if (props.trapped) {
          const relatedTarget = e.relatedTarget;
          if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
            setTimeout(() => {
              if (!focusLayer.paused && props.trapped) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason.value
                });
                emit("focusoutPrevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  tryFocus(lastFocusAfterTrapped, true);
                }
              }
            }, 0);
          }
        } else {
          const target = e.target;
          const isFocusedInTrap = target && trapContainer.contains(target);
          if (!isFocusedInTrap)
            emit("focusout", e);
        }
      };
      const startTrap = async () => {
        await vue.nextTick();
        const trapContainer = vue.unref(forwardRef);
        if (trapContainer) {
          focusableStack.push(focusLayer);
          const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
          lastFocusBeforeTrapped = prevFocusedElement;
          const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
          if (!isPrevFocusContained) {
            const focusEvent = new Event(focusAfterTrapped, focusAfterTrappedOpts);
            trapContainer.addEventListener(focusAfterTrapped, trapOnFocus);
            trapContainer.dispatchEvent(focusEvent);
            if (!focusEvent.defaultPrevented) {
              vue.nextTick(() => {
                let focusStartEl = props.focusStartEl;
                if (!isString(focusStartEl)) {
                  tryFocus(focusStartEl);
                  if (document.activeElement !== focusStartEl) {
                    focusStartEl = "first";
                  }
                }
                if (focusStartEl === "first") {
                  focusFirstDescendant(
                    obtainAllFocusableElements(trapContainer),
                    true
                  );
                }
                if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                  tryFocus(trapContainer);
                }
              });
            }
          }
        }
      };
      const stopTrap = () => {
        const trapContainer = vue.unref(forwardRef);
        if (trapContainer) {
          trapContainer.removeEventListener(focusAfterTrapped, trapOnFocus);
          const releasedEvent = new CustomEvent(focusAfterReleased, {
            ...focusAfterTrappedOpts,
            detail: {
              focusReason: focusReason.value
            }
          });
          trapContainer.addEventListener(focusAfterReleased, releaseOnFocus);
          trapContainer.dispatchEvent(releasedEvent);
          if (!releasedEvent.defaultPrevented && (focusReason.value == "keyboard" || !isFocusCausedByUserEvent())) {
            tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
          }
          trapContainer.removeEventListener(focusAfterReleased, trapOnFocus);
          focusableStack.remove(focusLayer);
        }
      };
      vue.onMounted(() => {
        if (props.trapped) {
          startTrap();
        }
        vue.watch(
          () => props.trapped,
          (trapped) => {
            if (trapped) {
              startTrap();
            } else {
              stopTrap();
            }
          }
        );
      });
      vue.onBeforeUnmount(() => {
        if (props.trapped) {
          stopTrap();
        }
      });
      return (_ctx, _cache) => {
        return vue.renderSlot(_ctx.$slots, "default", { handleKeydown: onKeydown });
      };
    }
  });
  var FocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main, [["__file", "focus-trap.vue"]]);

  const VsFocusTrap = withInstall(FocusTrap);

  const overlayProps = buildProps({
    mask: {
      type: Boolean,
      default: true
    },
    customMaskEvent: {
      type: Boolean,
      default: false
    },
    overlayClass: {
      type: definePropType([
        String,
        Array,
        Object
      ])
    },
    zIndex: {
      type: definePropType([String, Number])
    }
  });
  const overlayEmits = {
    click: (evt) => evt instanceof MouseEvent
  };
  var Overlay = vue.defineComponent({
    name: "VsOverlay",
    props: overlayProps,
    emits: overlayEmits,
    setup(props, { slots, emit }) {
      const ns = useNamespace("overlay");
      const onMaskClick = (e) => {
        emit("click", e);
      };
      const { onClick, onMousedown, onMouseup } = useSameTarget(
        props.customMaskEvent ? void 0 : onMaskClick
      );
      return () => {
        return props.mask ? vue.createVNode(
          "div",
          {
            class: [ns.b(), props.overlayClass],
            style: {
              zIndex: props.zIndex
            },
            onClick,
            onMousedown,
            onMouseup
          },
          [vue.renderSlot(slots, "default")],
          PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS,
          ["onClick", "onMouseup", "onMousedown"]
        ) : vue.h(
          "div",
          {
            class: props.overlayClass,
            style: {
              zIndex: props.zIndex,
              position: "fixed",
              top: "0px",
              right: "0px",
              bottom: "0px",
              left: "0px"
            }
          },
          [vue.renderSlot(slots, "default")]
        );
      };
    }
  });

  const VsOverlay = Overlay;

  const install = installer.install;
  const version = installer.version;

  exports.BAR_MAP = BAR_MAP;
  exports.CHANGE_EVENT = CHANGE_EVENT;
  exports.ClickOutside = ClickOutside;
  exports.EVENT_CODE = EVENT_CODE;
  exports.FORWARD_REF_INJECTION_KEY = FORWARD_REF_INJECTION_KEY;
  exports.GAP = GAP;
  exports.ID_INJECTION_KEY = ID_INJECTION_KEY;
  exports.INPUT_EVENT = INPUT_EVENT;
  exports.INSTALLED_KEY = INSTALLED_KEY;
  exports.IconArrow = IconArrow;
  exports.IconCheck = IconCheck;
  exports.IconClose = IconClose;
  exports.IconLoading = IconLoading;
  exports.IconPlus = IconPlus;
  exports.IconStar = IconStar;
  exports.IconStarFilled = IconStarFilled;
  exports.LOADING_RECT = LOADING_RECT;
  exports.Loading = loading$1;
  exports.Mousewheel = Mousewheel;
  exports.OnlyChild = OnlyChild;
  exports.RepeatClick = RepeatClick;
  exports.RowAlign = RowAlign;
  exports.RowDerection = RowDerection;
  exports.RowJustify = RowJustify;
  exports.SCALE_PARENT = SCALE_PARENT;
  exports.TrapFocus = TrapFocus;
  exports.UPDATE_MODEL_EVENT = UPDATE_MODEL_EVENT;
  exports.VsAlert = VsAlert;
  exports.VsAvatar = VsAvatar;
  exports.VsAvatarGroup = VsAvatarGroup;
  exports.VsBadge = VsBadge;
  exports.VsButton = VsButton;
  exports.VsButtonGroup = VsButtonGroup;
  exports.VsCard = VsCard;
  exports.VsCardGroup = VsCardGroup;
  exports.VsCheckbox = VsCheckbox;
  exports.VsCheckboxGroup = VsCheckboxGroup;
  exports.VsCol = VsCol;
  exports.VsCollapseTransition = VsCollapseTransition;
  exports.VsConfigProvider = VsConfigProvider;
  exports.VsDialog = VsDialog;
  exports.VsFocusTrap = VsFocusTrap;
  exports.VsIcon = VsIcon;
  exports.VsInfiniteScroll = VsInfiniteScroll;
  exports.VsInput = VsInput;
  exports.VsInputNumber = VsInputNumber;
  exports.VsLoading = VsLoading;
  exports.VsLoadingDirective = vLoading;
  exports.VsLoadingFn = loading;
  exports.VsNavbar = VsNavbar;
  exports.VsNavbarGroup = VsNavbarGroup;
  exports.VsNavbarItem = VsNavbarItem;
  exports.VsNotification = VsNotification;
  exports.VsOnlyChild = OnlyChild;
  exports.VsOption = VsOption;
  exports.VsOptionGroup = VsOptionGroup;
  exports.VsOverlay = VsOverlay;
  exports.VsPagination = VsPagination;
  exports.VsPopconfirm = VsPopconfirm;
  exports.VsPopper = VsPopper;
  exports.VsRadio = VsRadio;
  exports.VsRate = VsRate;
  exports.VsRow = VsRow;
  exports.VsScrollbar = VsScrollbar;
  exports.VsSelect = VsSelect;
  exports.VsSidebar = VsSidebar;
  exports.VsSidebarGroup = VsSidebarGroup;
  exports.VsSidebarItem = VsSidebarItem;
  exports.VsSwitch = VsSwitch;
  exports.VsTable = VsTable;
  exports.VsTd = VsTd;
  exports.VsTh = VsTh;
  exports.VsTimeSelect = VsTimeSelect;
  exports.VsTooltip = VsTooltip;
  exports.VsTr = VsTr;
  exports.alertEmits = alertEmits;
  exports.alertProps = alertProps;
  exports.arrow = arrow;
  exports.arrowProps = arrowProps;
  exports.avatarGroupContextKey = avatarGroupContextKey;
  exports.avatarGroupProps = avatarGroupProps;
  exports.avatarProps = avatarProps;
  exports.badgeProps = badgeProps;
  exports.buildLocaleContext = buildLocaleContext;
  exports.buildTranslator = buildTranslator;
  exports.buttonProps = buttonProps;
  exports.buttonSizes = buttonSizes;
  exports.buttonTypes = buttonTypes;
  exports.cardProps = cardProps;
  exports.checkProps = checkProps;
  exports.checkboxEmits = checkboxEmits;
  exports.checkboxGroupContextKey = checkboxGroupContextKey;
  exports.checkboxGroupEmits = checkboxGroupEmits;
  exports.checkboxGroupProps = checkboxGroupProps;
  exports.checkboxProps = checkboxProps;
  exports.closeProps = closeProps;
  exports.colProps = colProps;
  exports.componentColors = componentColors;
  exports.componentSizeMap = componentSizeMap;
  exports.componentSizes = componentSizes;
  exports.computePosition = computePosition;
  exports.configProviderContextKey = configProviderContextKey;
  exports.configProviderProps = configProviderProps;
  exports.createContainer = createContainer;
  exports.createModelToggleComposable = createModelToggleComposable;
  exports.dayjs = dayjs;
  exports["default"] = installer;
  exports.defaultInitialZIndex = defaultInitialZIndex;
  exports.defaultNamespace = defaultNamespace;
  exports.defaultZIndex = defaultZIndex;
  exports.detectOverflow = detectOverflow;
  exports.dialogEmits = dialogEmits;
  exports.dialogProps = dialogProps;
  exports.flip = flip;
  exports.focusAfterReleased = focusAfterReleased;
  exports.focusAfterTrapped = focusAfterTrapped;
  exports.focusAfterTrappedOpts = focusAfterTrappedOpts;
  exports.focusTrapEmits = focusTrapEmits;
  exports.focusTrapInjectionKey = focusTrapInjectionKey;
  exports.focusTrapProps = focusTrapProps;
  exports.focusoutPrevented = focusoutPrevented;
  exports.focusoutPreventedOpts = focusoutPreventedOpts;
  exports.getPage = getPage;
  exports.hexFullRE = hexFullRE;
  exports.hexShorthandRE = hexShorthandRE;
  exports.iconProps = iconProps;
  exports.inputEmits = inputEmits;
  exports.inputNumberEmits = inputNumberEmits;
  exports.inputNumberProps = inputNumberProps;
  exports.inputProps = inputProps;
  exports.install = install;
  exports.leadingHashRE = leadingHashRE;
  exports.limitShift = limitShift;
  exports.loadingProps = loadingProps;
  exports.loadingTypes = loadingTypes;
  exports.localeContextKey = localeContextKey;
  exports.makeInstaller = makeInstaller;
  exports.namespaceContextKey = namespaceContextKey;
  exports.navbarEmits = navbarEmits;
  exports.navbarItemProps = navbarItemProps;
  exports.navbarProps = navbarProps;
  exports.notificationEmits = notificationEmits;
  exports.notificationPosition = notificationPosition;
  exports.notificationProps = notificationProps;
  exports.offset = offset;
  exports.onReleaseFocusEvent = onReleaseFocusEvent;
  exports.onTrapFocusEvent = onTrapFocusEvent;
  exports.optionGroupProps = optionGroupProps;
  exports.optionProps = optionProps;
  exports.overlayEmits = overlayEmits;
  exports.overlayProps = overlayProps;
  exports.paginationContextKey = paginationContextKey;
  exports.paginationEmits = paginationEmits;
  exports.paginationProps = paginationProps;
  exports.placements = placements;
  exports.platform = platform;
  exports.plusProps = plusProps;
  exports.popconfirmEmits = popconfirmEmits;
  exports.popconfirmProps = popconfirmProps;
  exports.popperContentContextKey = popperContentContextKey;
  exports.popperContentEmits = popperContentEmits;
  exports.popperContentProps = popperContentProps;
  exports.popperContextKey = popperContextKey;
  exports.popperEmits = popperEmits;
  exports.popperProps = popperProps;
  exports.popperTriggerProps = popperTriggerProps;
  exports.provideGlobalConfig = provideGlobalConfig;
  exports.radioEmits = radioEmits;
  exports.radioProps = radioProps;
  exports.rateEmits = rateEmits;
  exports.rateProps = rateProps;
  exports.renderThumbStyle = renderThumbStyle;
  exports.rgbNumberRE = rgbNumberRE;
  exports.rgbRE = rgbRE;
  exports.rowContextKey = rowContextKey;
  exports.rowProps = rowProps;
  exports.scrollbarContextKey = scrollbarContextKey;
  exports.scrollbarEmits = scrollbarEmits;
  exports.scrollbarProps = scrollbarProps;
  exports.selectEmits = selectEmits;
  exports.selectProps = selectProps;
  exports.shift = shift;
  exports.sidebarContextKey = sidebarContextKey;
  exports.sidebarEmits = sidebarEmits;
  exports.sidebarGroupProps = sidebarGroupProps;
  exports.sidebarItemProps = sidebarItemProps;
  exports.sidebarProps = sidebarProps;
  exports.sortData = sortData;
  exports.switchEmits = switchEmits;
  exports.switchProps = switchProps;
  exports.tableContextKey = tableContextKey;
  exports.tableEmits = tableEmits;
  exports.tableProps = tableProps;
  exports.thumbProps = thumbProps;
  exports.timeSelectProps = timeSelectProps;
  exports.toggleSelectAll = toggleSelectAll;
  exports.tooltipProps = tooltipProps;
  exports.translate = translate;
  exports.useAttrs = useAttrs;
  exports.useColor = useColor;
  exports.useColorProp = useColorProp;
  exports.useCursor = useCursor;
  exports.useDelayedRender = useDelayedRender;
  exports.useDelayedToggle = useDelayedToggle;
  exports.useDelayedToggleProps = useDelayedToggleProps;
  exports.useDeprecated = useDeprecated;
  exports.useDisabled = useDisabled;
  exports.useDraggable = useDraggable;
  exports.useEscapeKeydown = useEscapeKeydown;
  exports.useFloating = useFloating;
  exports.useFocus = useFocus;
  exports.useForwardRef = useForwardRef;
  exports.useForwardRefDirective = useForwardRefDirective;
  exports.useGetDerivedNamespace = useGetDerivedNamespace;
  exports.useGlobalComponentSettings = useGlobalComponentSettings;
  exports.useGlobalConfig = useGlobalConfig;
  exports.useGroupInject = useGroupInject;
  exports.useGroupProvide = useGroupProvide;
  exports.useId = useId;
  exports.useIdInjection = useIdInjection;
  exports.useLocale = useLocale;
  exports.useLockscreen = useLockscreen;
  exports.useModal = useModal;
  exports.useModelToggle = useModelToggle;
  exports.useModelToggleEmits = useModelToggleEmits;
  exports.useModelToggleProps = useModelToggleProps;
  exports.useNamespace = useNamespace;
  exports.useOrderedChildren = useOrderedChildren;
  exports.usePopperContainer = usePopperContainer;
  exports.usePopperContainerId = usePopperContainerId;
  exports.usePopperModelToggle = usePopperModelToggle;
  exports.usePopperModelToggleEmits = usePopperModelToggleEmits;
  exports.usePopperModelToggleProps = usePopperModelToggleProps;
  exports.usePreventGlobal = usePreventGlobal;
  exports.useProp = useProp;
  exports.useRestoreActive = useRestoreActive;
  exports.useSameTarget = useSameTarget;
  exports.useSize = useSize;
  exports.useSizeProp = useSizeProp;
  exports.useTeleport = useTeleport;
  exports.useThrottleRender = useThrottleRender;
  exports.useTimeout = useTimeout;
  exports.useTransitionFallthrough = useTransitionFallthrough;
  exports.useTransitionFallthroughEmits = useTransitionFallthroughEmits;
  exports.useVuesaxBaseComponent = useVuesaxBaseComponent;
  exports.useZIndex = useZIndex;
  exports.vLoading = vLoading;
  exports.version = version;
  exports.vuesaxColors = vuesaxColors;
  exports.zIndexContextKey = zIndexContextKey;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
